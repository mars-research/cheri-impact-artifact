CVE ID,URL,OS,Description,Causes,Symptoms,Solved by CHERI?,Solved by Rust?,Notes,Column 1
CVE-2024-26907,https://www.cve.org/CVERecord?id=CVE-2024-26907,Linux,"RDMA/mlx5: Fix fortify source warning while accessing Eth segment\n\n ------------[ cut here ]------------\n memcpy: detected field-spanning write (size 56) of single field ""eseg->inline_hdr.start"" at /var/lib/dkms/mlnx-ofed-kernel/5.8/build/drivers/infiniband/hw/mlx5/wr.c:131 (size 2)\n WARNING: CPU: 0 PID: 293779 at /var/lib/dkms/mlnx-ofed-kernel/5.8/build/drivers/infiniband/hw/mlx5/wr.c:131 mlx5_ib_post_send+0x191b/0x1a60 [mlx5_ib]\n Modules linked in: 8021q garp mrp stp llc rdma_ucm(OE) rdma_cm(OE) iw_cm(OE) ib_ipoib(OE) ib_cm(OE) ib_umad(OE) mlx5_ib(OE) ib_uverbs(OE) ib_core(OE) mlx5_core(OE) pci_hyperv_intf mlxdevm(OE) mlx_compat(OE) tls mlxfw(OE) psample nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip_set nf_tables libcrc32c nfnetlink mst_pciconf(OE) knem(OE) vfio_pci vfio_pci_core vfio_iommu_type1 vfio iommufd irqbypass cuse nfsv3 nfs fscache netfs xfrm_user xfrm_algo ipmi_devintf ipmi_msghandler binfmt_misc crct10dif_pclmul crc32_pclmul polyval_clmulni polyval_generic ghash_clmulni_intel sha512_ssse3 snd_pcsp aesni_intel crypto_simd cryptd snd_pcm snd_timer joydev snd soundcore input_leds serio_raw evbug nfsd auth_rpcgss nfs_acl lockd grace sch_fq_codel sunrpc drm efi_pstore ip_tables x_tables autofs4 psmouse virtio_net net_failover failover floppy\n  [last unloaded: mlx_compat(OE)]\n CPU: 0 PID: 293779 Comm: ssh Tainted: G           OE      6.2.0-32-generic #32~22.04.1-Ubuntu\n Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011\n RIP: 0010:mlx5_ib_post_send+0x191b/0x1a60 [mlx5_ib]\n Code: 0c 01 00 a8 01 75 25 48 8b 75 a0 b9 02 00 00 00 48 c7 c2 10 5b fd c0 48 c7 c7 80 5b fd c0 c6 05 57 0c 03 00 01 e8 95 4d 93 da <0f> 0b 44 8b 4d b0 4c 8b 45 c8 48 8b 4d c0 e9 49 fb ff ff 41 0f b7\n RSP: 0018:ffffb5b48478b570 EFLAGS: 00010046\n RAX: 0000000000000000 RBX: 0000000000000001 RCX: 0000000000000000\n RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000\n RBP: ffffb5b48478b628 R08: 0000000000000000 R09: 0000000000000000\n R10: 0000000000000000 R11: 0000000000000000 R12: ffffb5b48478b5e8\n R13: ffff963a3c609b5e R14: ffff9639c3fbd800 R15: ffffb5b480475a80\n FS:  00007fc03b444c80(0000) GS:ffff963a3dc00000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000556f46bdf000 CR3: 0000000006ac6003 CR4: 00000000003706f0\n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n Call Trace:\n  <TASK>\n  ? show_regs+0x72/0x90\n  ? mlx5_ib_post_send+0x191b/0x1a60 [mlx5_ib]\n  ? __warn+0x8d/0x160\n  ? mlx5_ib_post_send+0x191b/0x1a60 [mlx5_ib]\n  ? report_bug+0x1bb/0x1d0\n  ? handle_bug+0x46/0x90\n  ? exc_invalid_op+0x19/0x80\n  ? asm_exc_invalid_op+0x1b/0x20\n  ? mlx5_ib_post_send+0x191b/0x1a60 [mlx5_ib]\n  mlx5_ib_post_send_nodrain+0xb/0x20 [mlx5_ib]\n  ipoib_send+0x2ec/0x770 [ib_ipoib]\n  ipoib_start_xmit+0x5a0/0x770 [ib_ipoib]\n  dev_hard_start_xmit+0x8e/0x1e0\n  ? validate_xmit_skb_list+0x4d/0x80\n  sch_direct_xmit+0x116/0x3a0\n  __dev_xmit_skb+0x1fd/0x580\n  __dev_queue_xmit+0x284/0x6b0\n  ? _raw_spin_unlock_irq+0xe/0x50\n  ? __flush_work.isra.0+0x20d/0x370\n  ? push_pseudo_header+0x17/0x40 [ib_ipoib]\n  neigh_connected_output+0xcd/0x110\n  ip_finish_output2+0x179/0x480\n  ? __smp_call_single_queue+0x61/0xa0\n  __ip_finish_output+0xc3/0x190\n  ip_finish_output+0x2e/0xf0\n  ip_output+0x78/0x110\n  ? __pfx_ip_finish_output+0x10/0x10\n  ip_local_out+0x64/0x70\n  __ip_queue_xmit+0x18a/0x460\n  ip_queue_xmit+0x15/0x30\n  __tcp_transmit_skb+0x914/0x9c0\n  tcp_write_xmit+0x334/0x8d0\n  tcp_push_one+0x3c/0x60\n  tcp_sendmsg_locked+0x2e1/0xac0\n  tcp_sendmsg+0x2d/0x50\n  inet_sendmsg+0x43/0x90\n  sock_sendmsg+0x68/0x80\n  sock_write_iter+0x93/0x100\n  vfs_write+0x326/0x3c0\n  ksys_write+0xbd/0xf0\n  ? do_syscall_64+0x69/0x90\n  __x64_sys_write+0x19/0x30\n  do_syscall_\n---truncated---",Language -  Polymorphism,OOB access,TRUE,TRUE,OOB write,
CVE-2024-26895,https://www.cve.org/CVERecord?id=CVE-2024-26895,Linux,"wifi: wilc1000: prevent use-after-free on vif when cleaning up all interfaces\n\nwilc_netdev_cleanup currently triggers a KASAN warning, which can be\nobserved on interface registration error path, or simply by\nremoving the module/unbinding device from driver:\n\necho spi0.1 > /sys/bus/spi/drivers/wilc1000_spi/unbind\n\n==================================================================\nBUG: KASAN: slab-use-after-free in wilc_netdev_cleanup+0x508/0x5cc\nRead of size 4 at addr c54d1ce8 by task sh/86\n\nCPU: 0 PID: 86 Comm: sh Not tainted 6.8.0-rc1+ #117\nHardware name: Atmel SAMA5\n unwind_backtrace from show_stack+0x18/0x1c\n show_stack from dump_stack_lvl+0x34/0x58\n dump_stack_lvl from print_report+0x154/0x500\n print_report from kasan_report+0xac/0xd8\n kasan_report from wilc_netdev_cleanup+0x508/0x5cc\n wilc_netdev_cleanup from wilc_bus_remove+0xc8/0xec\n wilc_bus_remove from spi_remove+0x8c/0xac\n spi_remove from device_release_driver_internal+0x434/0x5f8\n device_release_driver_internal from unbind_store+0xbc/0x108\n unbind_store from kernfs_fop_write_iter+0x398/0x584\n kernfs_fop_write_iter from vfs_write+0x728/0xf88\n vfs_write from ksys_write+0x110/0x1e4\n ksys_write from ret_fast_syscall+0x0/0x1c\n\n[...]\n\nAllocated by task 1:\n kasan_save_track+0x30/0x5c\n __kasan_kmalloc+0x8c/0x94\n __kmalloc_node+0x1cc/0x3e4\n kvmalloc_node+0x48/0x180\n alloc_netdev_mqs+0x68/0x11dc\n alloc_etherdev_mqs+0x28/0x34\n wilc_netdev_ifc_init+0x34/0x8ec\n wilc_cfg80211_init+0x690/0x910\n wilc_bus_probe+0xe0/0x4a0\n spi_probe+0x158/0x1b0\n really_probe+0x270/0xdf4\n __driver_probe_device+0x1dc/0x580\n driver_probe_device+0x60/0x140\n __driver_attach+0x228/0x5d4\n bus_for_each_dev+0x13c/0x1a8\n bus_add_driver+0x2a0/0x608\n driver_register+0x24c/0x578\n do_one_initcall+0x180/0x310\n kernel_init_freeable+0x424/0x484\n kernel_init+0x20/0x148\n ret_from_fork+0x14/0x28\n\nFreed by task 86:\n kasan_save_track+0x30/0x5c\n kasan_save_free_info+0x38/0x58\n __kasan_slab_free+0xe4/0x140\n kfree+0xb0/0x238\n device_release+0xc0/0x2a8\n kobject_put+0x1d4/0x46c\n netdev_run_todo+0x8fc/0x11d0\n wilc_netdev_cleanup+0x1e4/0x5cc\n wilc_bus_remove+0xc8/0xec\n spi_remove+0x8c/0xac\n device_release_driver_internal+0x434/0x5f8\n unbind_store+0xbc/0x108\n kernfs_fop_write_iter+0x398/0x584\n vfs_write+0x728/0xf88\n ksys_write+0x110/0x1e4\n ret_fast_syscall+0x0/0x1c\n [...]\n\nDavid Mosberger-Tan initial investigation [1] showed that this\nuse-after-free is due to netdevice unregistration during vif list\ntraversal. When unregistering a net device, since the needs_free_netdev has\nbeen set to true during registration, the netdevice object is also freed,\nand as a consequence, the corresponding vif object too, since it is\nattached to it as private netdevice data. The next occurrence of the loop\nthen tries to access freed vif pointer to the list to move forward in the\nlist.\n\nFix this use-after-free thanks to two mechanisms:\n- navigate in the list with list_for_each_entry_safe, which allows to\n  safely modify the list as we go through each element. For each element,\n  remove it from the list with list_del_rcu\n- make sure to wait for RCU grace period end after each vif removal to make\n  sure it is safe to free the corresponding vif too (through\n  unregister_netdev)\n\nSince we are in a RCU ""modifier"" path (not a ""reader"" path), and because\nsuch path is expected not to be concurrent to any other modifier (we are\nusing the vif_mutex lock), we do not need to use RCU list API, that's why\nwe can benefit from list_for_each_entry_safe.\n\n[1] https://lore.kernel.org/linux-wireless/ab077dbe58b1ea5de0a3b2ca21f275a07af967d2.camel@egauge.net/",Language - Lifetime violation,Use after free,TRUE,TRUE,The freeing was implicitly triggered outside the current code (needs_free_netdev).,
CVE-2024-26882,https://www.cve.org/CVERecord?id=CVE-2024-26882,Linux,"net: ip_tunnel: make sure to pull inner header in ip_tunnel_rcv()\n\nApply the same fix than ones found in :\n\n8d975c15c0cd (""ip6_tunnel: make sure to pull inner header in __ip6_tnl_rcv()"")\n1ca1ba465e55 (""geneve: make sure to pull inner header in geneve_rx()"")\n\nWe have to save skb->network_header in a temporary variable\nin order to be able to recompute the network_header pointer\nafter a pskb_inet_may_pull() call.\n\npskb_inet_may_pull() makes sure the needed headers are in skb->head.\n\nsyzbot reported:\nBUG: KMSAN: uninit-value in __INET_ECN_decapsulate include/net/inet_ecn.h:253 [inline]\n BUG: KMSAN: uninit-value in INET_ECN_decapsulate include/net/inet_ecn.h:275 [inline]\n BUG: KMSAN: uninit-value in IP_ECN_decapsulate include/net/inet_ecn.h:302 [inline]\n BUG: KMSAN: uninit-value in ip_tunnel_rcv+0xed9/0x2ed0 net/ipv4/ip_tunnel.c:409\n  __INET_ECN_decapsulate include/net/inet_ecn.h:253 [inline]\n  INET_ECN_decapsulate include/net/inet_ecn.h:275 [inline]\n  IP_ECN_decapsulate include/net/inet_ecn.h:302 [inline]\n  ip_tunnel_rcv+0xed9/0x2ed0 net/ipv4/ip_tunnel.c:409\n  __ipgre_rcv+0x9bc/0xbc0 net/ipv4/ip_gre.c:389\n  ipgre_rcv net/ipv4/ip_gre.c:411 [inline]\n  gre_rcv+0x423/0x19f0 net/ipv4/ip_gre.c:447\n  gre_rcv+0x2a4/0x390 net/ipv4/gre_demux.c:163\n  ip_protocol_deliver_rcu+0x264/0x1300 net/ipv4/ip_input.c:205\n  ip_local_deliver_finish+0x2b8/0x440 net/ipv4/ip_input.c:233\n  NF_HOOK include/linux/netfilter.h:314 [inline]\n  ip_local_deliver+0x21f/0x490 net/ipv4/ip_input.c:254\n  dst_input include/net/dst.h:461 [inline]\n  ip_rcv_finish net/ipv4/ip_input.c:449 [inline]\n  NF_HOOK include/linux/netfilter.h:314 [inline]\n  ip_rcv+0x46f/0x760 net/ipv4/ip_input.c:569\n  __netif_receive_skb_one_core net/core/dev.c:5534 [inline]\n  __netif_receive_skb+0x1a6/0x5a0 net/core/dev.c:5648\n  netif_receive_skb_internal net/core/dev.c:5734 [inline]\n  netif_receive_skb+0x58/0x660 net/core/dev.c:5793\n  tun_rx_batched+0x3ee/0x980 drivers/net/tun.c:1556\n  tun_get_user+0x53b9/0x66e0 drivers/net/tun.c:2009\n  tun_chr_write_iter+0x3af/0x5d0 drivers/net/tun.c:2055\n  call_write_iter include/linux/fs.h:2087 [inline]\n  new_sync_write fs/read_write.c:497 [inline]\n  vfs_write+0xb6b/0x1520 fs/read_write.c:590\n  ksys_write+0x20f/0x4c0 fs/read_write.c:643\n  __do_sys_write fs/read_write.c:655 [inline]\n  __se_sys_write fs/read_write.c:652 [inline]\n  __x64_sys_write+0x93/0xd0 fs/read_write.c:652\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcf/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x63/0x6b\n\nUninit was created at:\n  __alloc_pages+0x9a6/0xe00 mm/page_alloc.c:4590\n  alloc_pages_mpol+0x62b/0x9d0 mm/mempolicy.c:2133\n  alloc_pages+0x1be/0x1e0 mm/mempolicy.c:2204\n  skb_page_frag_refill+0x2bf/0x7c0 net/core/sock.c:2909\n  tun_build_skb drivers/net/tun.c:1686 [inline]\n  tun_get_user+0xe0a/0x66e0 drivers/net/tun.c:1826\n  tun_chr_write_iter+0x3af/0x5d0 drivers/net/tun.c:2055\n  call_write_iter include/linux/fs.h:2087 [inline]\n  new_sync_write fs/read_write.c:497 [inline]\n  vfs_write+0xb6b/0x1520 fs/read_write.c:590\n  ksys_write+0x20f/0x4c0 fs/read_write.c:643\n  __do_sys_write fs/read_write.c:655 [inline]\n  __se_sys_write fs/read_write.c:652 [inline]\n  __x64_sys_write+0x93/0xd0 fs/read_write.c:652\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcf/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x63/0x6b",Semantic - Logic error,Uninitialized memory access,FALSE,TRUE,The previous code didn't recompute the network header offset and causes invalid access to uninitalized data.,
CVE-2024-26867,https://www.cve.org/CVERecord?id=CVE-2024-26867,Linux,"comedi: comedi_8255: Correct error in subdevice initialization\n\nThe refactoring done in commit 5c57b1ccecc7 (""comedi: comedi_8255: Rework\nsubdevice initialization functions"") to the initialization of the io\nfield of struct subdev_8255_private broke all cards using the\ndrivers/comedi/drivers/comedi_8255.c module.\n\nPrior to 5c57b1ccecc7, __subdev_8255_init() initialized the io field\nin the newly allocated struct subdev_8255_private to the non-NULL\ncallback given to the function, otherwise it used a flag parameter to\nselect between subdev_8255_mmio and subdev_8255_io. The refactoring\nremoved that logic and the flag, as subdev_8255_mm_init() and\nsubdev_8255_io_init() now explicitly pass subdev_8255_mmio and\nsubdev_8255_io respectively to __subdev_8255_init(), only\n__subdev_8255_init() never sets spriv->io to the supplied\ncallback. That spriv->io is NULL leads to a later BUG:\n\nBUG: kernel NULL pointer dereference, address: 0000000000000000\nPGD 0 P4D 0\nOops: 0010 [#1] SMP PTI\nCPU: 1 PID: 1210 Comm: systemd-udevd Not tainted 6.7.3-x86_64 #1\nHardware name: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nRIP: 0010:0x0\nCode: Unable to access opcode bytes at 0xffffffffffffffd6.\nRSP: 0018:ffffa3f1c02d7b78 EFLAGS: 00010202\nRAX: 0000000000000000 RBX: ffff91f847aefd00 RCX: 000000000000009b\nRDX: 0000000000000003 RSI: 0000000000000001 RDI: ffff91f840f6fc00\nRBP: ffff91f840f6fc00 R08: 0000000000000000 R09: 0000000000000001\nR10: 0000000000000000 R11: 000000000000005f R12: 0000000000000000\nR13: 0000000000000000 R14: ffffffffc0102498 R15: ffff91f847ce6ba8\nFS:  00007f72f4e8f500(0000) GS:ffff91f8d5c80000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: ffffffffffffffd6 CR3: 000000010540e000 CR4: 00000000000406f0\nCall Trace:\n <TASK>\n ? __die_body+0x15/0x57\n ? page_fault_oops+0x2ef/0x33c\n ? insert_vmap_area.constprop.0+0xb6/0xd5\n ? alloc_vmap_area+0x529/0x5ee\n ? exc_page_fault+0x15a/0x489\n ? asm_exc_page_fault+0x22/0x30\n __subdev_8255_init+0x79/0x8d [comedi_8255]\n pci_8255_auto_attach+0x11a/0x139 [8255_pci]\n comedi_auto_config+0xac/0x117 [comedi]\n ? __pfx___driver_attach+0x10/0x10\n pci_device_probe+0x88/0xf9\n really_probe+0x101/0x248\n __driver_probe_device+0xbb/0xed\n driver_probe_device+0x1a/0x72\n __driver_attach+0xd4/0xed\n bus_for_each_dev+0x76/0xb8\n bus_add_driver+0xbe/0x1be\n driver_register+0x9a/0xd8\n comedi_pci_driver_register+0x28/0x48 [comedi_pci]\n ? __pfx_pci_8255_driver_init+0x10/0x10 [8255_pci]\n do_one_initcall+0x72/0x183\n do_init_module+0x5b/0x1e8\n init_module_from_file+0x86/0xac\n __do_sys_finit_module+0x151/0x218\n do_syscall_64+0x72/0xdb\n entry_SYSCALL_64_after_hwframe+0x6e/0x76\nRIP: 0033:0x7f72f50a0cb9\nCode: ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 47 71 0c 00 f7 d8 64 89 01 48\nRSP: 002b:00007ffd47e512d8 EFLAGS: 00000246 ORIG_RAX: 0000000000000139\nRAX: ffffffffffffffda RBX: 0000562dd06ae070 RCX: 00007f72f50a0cb9\nRDX: 0000000000000000 RSI: 00007f72f52d32df RDI: 000000000000000e\nRBP: 0000000000000000 R08: 00007f72f5168b20 R09: 0000000000000000\nR10: 0000000000000050 R11: 0000000000000246 R12: 00007f72f52d32df\nR13: 0000000000020000 R14: 0000562dd06785c0 R15: 0000562dcfd0e9a8\n </TASK>\nModules linked in: 8255_pci(+) comedi_8255 comedi_pci comedi intel_gtt e100(+) acpi_cpufreq rtc_cmos usbhid\nCR2: 0000000000000000\n---[ end trace 0000000000000000 ]---\nRIP: 0010:0x0\nCode: Unable to access opcode bytes at 0xffffffffffffffd6.\nRSP: 0018:ffffa3f1c02d7b78 EFLAGS: 00010202\nRAX: 0000000000000000 RBX: ffff91f847aefd00 RCX: 000000000000009b\nRDX: 0000000000000003 RSI: 0000000000000001 RDI: ffff91f840f6fc00\nRBP: ffff91f840f6fc00 R08: 0000000000000000 R09: 0000000000000001\nR10: 0000000000000000 R11: 000000000000005f R12: 0000000000000000\nR13: 0000000000000000 R14: ffffffffc0102498 R15: ffff91f847ce6ba8\nFS: \n---truncated---",Language - Improper memory initialization,Invalid pointer dereference,TRUE,TRUE,"The previous code didn't initialize the pointer which stayed NULL. In Rust, this would be modeled as Option which forces explicit unwrapping.",
CVE-2024-26857,https://www.cve.org/CVERecord?id=CVE-2024-26857,Linux,"geneve: make sure to pull inner header in geneve_rx()\n\nsyzbot triggered a bug in geneve_rx() [1]\n\nIssue is similar to the one I fixed in commit 8d975c15c0cd\n(""ip6_tunnel: make sure to pull inner header in __ip6_tnl_rcv()"")\n\nWe have to save skb->network_header in a temporary variable\nin order to be able to recompute the network_header pointer\nafter a pskb_inet_may_pull() call.\n\npskb_inet_may_pull() makes sure the needed headers are in skb->head.\n\n[1]\nBUG: KMSAN: uninit-value in IP_ECN_decapsulate include/net/inet_ecn.h:302 [inline]\n BUG: KMSAN: uninit-value in geneve_rx drivers/net/geneve.c:279 [inline]\n BUG: KMSAN: uninit-value in geneve_udp_encap_recv+0x36f9/0x3c10 drivers/net/geneve.c:391\n  IP_ECN_decapsulate include/net/inet_ecn.h:302 [inline]\n  geneve_rx drivers/net/geneve.c:279 [inline]\n  geneve_udp_encap_recv+0x36f9/0x3c10 drivers/net/geneve.c:391\n  udp_queue_rcv_one_skb+0x1d39/0x1f20 net/ipv4/udp.c:2108\n  udp_queue_rcv_skb+0x6ae/0x6e0 net/ipv4/udp.c:2186\n  udp_unicast_rcv_skb+0x184/0x4b0 net/ipv4/udp.c:2346\n  __udp4_lib_rcv+0x1c6b/0x3010 net/ipv4/udp.c:2422\n  udp_rcv+0x7d/0xa0 net/ipv4/udp.c:2604\n  ip_protocol_deliver_rcu+0x264/0x1300 net/ipv4/ip_input.c:205\n  ip_local_deliver_finish+0x2b8/0x440 net/ipv4/ip_input.c:233\n  NF_HOOK include/linux/netfilter.h:314 [inline]\n  ip_local_deliver+0x21f/0x490 net/ipv4/ip_input.c:254\n  dst_input include/net/dst.h:461 [inline]\n  ip_rcv_finish net/ipv4/ip_input.c:449 [inline]\n  NF_HOOK include/linux/netfilter.h:314 [inline]\n  ip_rcv+0x46f/0x760 net/ipv4/ip_input.c:569\n  __netif_receive_skb_one_core net/core/dev.c:5534 [inline]\n  __netif_receive_skb+0x1a6/0x5a0 net/core/dev.c:5648\n  process_backlog+0x480/0x8b0 net/core/dev.c:5976\n  __napi_poll+0xe3/0x980 net/core/dev.c:6576\n  napi_poll net/core/dev.c:6645 [inline]\n  net_rx_action+0x8b8/0x1870 net/core/dev.c:6778\n  __do_softirq+0x1b7/0x7c5 kernel/softirq.c:553\n  do_softirq+0x9a/0xf0 kernel/softirq.c:454\n  __local_bh_enable_ip+0x9b/0xa0 kernel/softirq.c:381\n  local_bh_enable include/linux/bottom_half.h:33 [inline]\n  rcu_read_unlock_bh include/linux/rcupdate.h:820 [inline]\n  __dev_queue_xmit+0x2768/0x51c0 net/core/dev.c:4378\n  dev_queue_xmit include/linux/netdevice.h:3171 [inline]\n  packet_xmit+0x9c/0x6b0 net/packet/af_packet.c:276\n  packet_snd net/packet/af_packet.c:3081 [inline]\n  packet_sendmsg+0x8aef/0x9f10 net/packet/af_packet.c:3113\n  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg net/socket.c:745 [inline]\n  __sys_sendto+0x735/0xa10 net/socket.c:2191\n  __do_sys_sendto net/socket.c:2203 [inline]\n  __se_sys_sendto net/socket.c:2199 [inline]\n  __x64_sys_sendto+0x125/0x1c0 net/socket.c:2199\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcf/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x63/0x6b\n\nUninit was created at:\n  slab_post_alloc_hook mm/slub.c:3819 [inline]\n  slab_alloc_node mm/slub.c:3860 [inline]\n  kmem_cache_alloc_node+0x5cb/0xbc0 mm/slub.c:3903\n  kmalloc_reserve+0x13d/0x4a0 net/core/skbuff.c:560\n  __alloc_skb+0x352/0x790 net/core/skbuff.c:651\n  alloc_skb include/linux/skbuff.h:1296 [inline]\n  alloc_skb_with_frags+0xc8/0xbd0 net/core/skbuff.c:6394\n  sock_alloc_send_pskb+0xa80/0xbf0 net/core/sock.c:2783\n  packet_alloc_skb net/packet/af_packet.c:2930 [inline]\n  packet_snd net/packet/af_packet.c:3024 [inline]\n  packet_sendmsg+0x70c2/0x9f10 net/packet/af_packet.c:3113\n  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg net/socket.c:745 [inline]\n  __sys_sendto+0x735/0xa10 net/socket.c:2191\n  __do_sys_sendto net/socket.c:2203 [inline]\n  __se_sys_sendto net/socket.c:2199 [inline]\n  __x64_sys_sendto+0x125/0x1c0 net/socket.c:2199\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcf/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x63/0x6b",Semantic - Logic error,Uninitialized memory access,FALSE,FALSE,See CVE-2024-26882,
CVE-2024-26798,https://www.cve.org/CVERecord?id=CVE-2024-26798,Linux,"fbcon: always restore the old font data in fbcon_do_set_font()\n\nCommit a5a923038d70 (fbdev: fbcon: Properly revert changes when\nvc_resize() failed) started restoring old font data upon failure (of\nvc_resize()). But it performs so only for user fonts. It means that the\n""system""/internal fonts are not restored at all. So in result, the very\nfirst call to fbcon_do_set_font() performs no restore at all upon\nfailing vc_resize().\n\nThis can be reproduced by Syzkaller to crash the system on the next\ninvocation of font_get(). It's rather hard to hit the allocation failure\nin vc_resize() on the first font_set(), but not impossible. Esp. if\nfault injection is used to aid the execution/failure. It was\ndemonstrated by Sirius:\n  BUG: unable to handle page fault for address: fffffffffffffff8\n  #PF: supervisor read access in kernel mode\n  #PF: error_code(0x0000) - not-present page\n  PGD cb7b067 P4D cb7b067 PUD cb7d067 PMD 0\n  Oops: 0000 [#1] PREEMPT SMP KASAN\n  CPU: 1 PID: 8007 Comm: poc Not tainted 6.7.0-g9d1694dc91ce #20\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\n  RIP: 0010:fbcon_get_font+0x229/0x800 drivers/video/fbdev/core/fbcon.c:2286\n  Call Trace:\n   <TASK>\n   con_font_get drivers/tty/vt/vt.c:4558 [inline]\n   con_font_op+0x1fc/0xf20 drivers/tty/vt/vt.c:4673\n   vt_k_ioctl drivers/tty/vt/vt_ioctl.c:474 [inline]\n   vt_ioctl+0x632/0x2ec0 drivers/tty/vt/vt_ioctl.c:752\n   tty_ioctl+0x6f8/0x1570 drivers/tty/tty_io.c:2803\n   vfs_ioctl fs/ioctl.c:51 [inline]\n  ...\n\nSo restore the font data in any case, not only for user fonts. Note the\nlater 'if' is now protected by 'old_userfont' and not 'old_data' as the\nlatter is always set now. (And it is supposed to be non-NULL. Otherwise\nwe would see the bug above again.)",Protocol - Missing Protocol Steps,Invalid pointer dereference,TRUE,TRUE,Page fault due to uninitialized memory access,
CVE-2024-26797,https://www.cve.org/CVERecord?id=CVE-2024-26797,Linux,"drm/amd/display: Prevent potential buffer overflow in map_hw_resources\n\nAdds a check in the map_hw_resources function to prevent a potential\nbuffer overflow. The function was accessing arrays using an index that\ncould potentially be greater than the size of the arrays, leading to a\nbuffer overflow.\n\nAdds a check to ensure that the index is within the bounds of the\narrays. If the index is out of bounds, an error message is printed and\nbreak it will continue execution with just ignoring extra data early to\nprevent the buffer overflow.\n\nReported by smatch:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dml2/dml2_wrapper.c:79 map_hw_resources() error: buffer overflow 'dml2->v20.scratch.dml_to_dc_pipe_mapping.disp_cfg_to_stream_id' 6 <= 7\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dml2/dml2_wrapper.c:81 map_hw_resources() error: buffer overflow 'dml2->v20.scratch.dml_to_dc_pipe_mapping.disp_cfg_to_plane_id' 6 <= 7",Semantic - Logic error,OOB access,TRUE,TRUE,,
CVE-2024-26753,https://www.cve.org/CVERecord?id=CVE-2024-26753,Linux,"crypto: virtio/akcipher - Fix stack overflow on memcpy\n\nsizeof(struct virtio_crypto_akcipher_session_para) is less than\nsizeof(struct virtio_crypto_op_ctrl_req::u), copying more bytes from\nstack variable leads stack overflow. Clang reports this issue by\ncommands:\nmake -j CC=clang-14 mrproper >/dev/null 2>&1\nmake -j O=/tmp/crypto-build CC=clang-14 allmodconfig >/dev/null 2>&1\nmake -j O=/tmp/crypto-build W=1 CC=clang-14 drivers/crypto/virtio/\n  virtio_crypto_akcipher_algs.o",Semantic - Logic error,OOB access,TRUE,TRUE,memcpy to wrong type,
CVE-2024-26687,https://www.cve.org/CVERecord?id=CVE-2024-26687,Linux,"xen/events: close evtchn after mapping cleanup\n\nshutdown_pirq and startup_pirq are not taking the\nirq_mapping_update_lock because they can't due to lock inversion. Both\nare called with the irq_desc->lock being taking. The lock order,\nhowever, is first irq_mapping_update_lock and then irq_desc->lock.\n\nThis opens multiple races:\n- shutdown_pirq can be interrupted by a function that allocates an event\n  channel:\n\n  CPU0                        CPU1\n  shutdown_pirq {\n    xen_evtchn_close(e)\n                              __startup_pirq {\n                                EVTCHNOP_bind_pirq\n                                  -> returns just freed evtchn e\n                                set_evtchn_to_irq(e, irq)\n                              }\n    xen_irq_info_cleanup() {\n      set_evtchn_to_irq(e, -1)\n    }\n  }\n\n  Assume here event channel e refers here to the same event channel\n  number.\n  After this race the evtchn_to_irq mapping for e is invalid (-1).\n\n- __startup_pirq races with __unbind_from_irq in a similar way. Because\n  __startup_pirq doesn't take irq_mapping_update_lock it can grab the\n  evtchn that __unbind_from_irq is currently freeing and cleaning up. In\n  this case even though the event channel is allocated, its mapping can\n  be unset in evtchn_to_irq.\n\nThe fix is to first cleanup the mappings and then close the event\nchannel. In this way, when an event channel gets allocated it's\npotential previous evtchn_to_irq mappings are guaranteed to be unset already.\nThis is also the reverse order of the allocation where first the event\nchannel is allocated and then the mappings are setup.\n\nOn a 5.10 kernel prior to commit 3fcdaf3d7634 (""xen/events: modify internal\n[un]bind interfaces""), we hit a BUG like the following during probing of NVMe\ndevices. The issue is that during nvme_setup_io_queues, pci_free_irq\nis called for every device which results in a call to shutdown_pirq.\nWith many nvme devices it's therefore likely to hit this race during\nboot because there will be multiple calls to shutdown_pirq and\nstartup_pirq are running potentially in parallel.\n\n  ------------[ cut here ]------------\n  blkfront: xvda: barrier or flush: disabled; persistent grants: enabled; indirect descriptors: enabled; bounce buffer: enabled\n  kernel BUG at drivers/xen/events/events_base.c:499!\n  invalid opcode: 0000 [#1] SMP PTI\n  CPU: 44 PID: 375 Comm: kworker/u257:23 Not tainted 5.10.201-191.748.amzn2.x86_64 #1\n  Hardware name: Xen HVM domU, BIOS 4.11.amazon 08/24/2006\n  Workqueue: nvme-reset-wq nvme_reset_work\n  RIP: 0010:bind_evtchn_to_cpu+0xdf/0xf0\n  Code: 5d 41 5e c3 cc cc cc cc 44 89 f7 e8 2b 55 ad ff 49 89 c5 48 85 c0 0f 84 64 ff ff ff 4c 8b 68 30 41 83 fe ff 0f 85 60 ff ff ff <0f> 0b 66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 0f 1f 44 00 00\n  RSP: 0000:ffffc9000d533b08 EFLAGS: 00010046\n  RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000006\n  RDX: 0000000000000028 RSI: 00000000ffffffff RDI: 00000000ffffffff\n  RBP: ffff888107419680 R08: 0000000000000000 R09: ffffffff82d72b00\n  R10: 0000000000000000 R11: 0000000000000000 R12: 00000000000001ed\n  R13: 0000000000000000 R14: 00000000ffffffff R15: 0000000000000002\n  FS:  0000000000000000(0000) GS:ffff88bc8b500000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 0000000000000000 CR3: 0000000002610001 CR4: 00000000001706e0\n  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n  Call Trace:\n   ? show_trace_log_lvl+0x1c1/0x2d9\n   ? show_trace_log_lvl+0x1c1/0x2d9\n   ? set_affinity_irq+0xdc/0x1c0\n   ? __die_body.cold+0x8/0xd\n   ? die+0x2b/0x50\n   ? do_trap+0x90/0x110\n   ? bind_evtchn_to_cpu+0xdf/0xf0\n   ? do_error_trap+0x65/0x80\n   ? bind_evtchn_to_cpu+0xdf/0xf0\n   ? exc_invalid_op+0x4e/0x70\n   ? bind_evtchn_to_cpu+0xdf/0xf0\n   ? asm_exc_invalid_op+0x12/0x20\n   ? bind_evtchn_to_cpu+0xdf/0x\n---truncated---",Race condition - Improper usage of synchronization primitives,Failure to release CPU,FALSE,TRUE,,
CVE-2024-26681,https://www.cve.org/CVERecord?id=CVE-2024-26681,Linux,"netdevsim: avoid potential loop in nsim_dev_trap_report_work()\n\nMany syzbot reports include the following trace [1]\n\nIf nsim_dev_trap_report_work() can not grab the mutex,\nit should rearm itself at least one jiffie later.\n\n[1]\nSending NMI from CPU 1 to CPUs 0:\nNMI backtrace for cpu 0\nCPU: 0 PID: 32383 Comm: kworker/0:2 Not tainted 6.8.0-rc2-syzkaller-00031-g861c0981648f #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 11/17/2023\nWorkqueue: events nsim_dev_trap_report_work\n RIP: 0010:bytes_is_nonzero mm/kasan/generic.c:89 [inline]\n RIP: 0010:memory_is_nonzero mm/kasan/generic.c:104 [inline]\n RIP: 0010:memory_is_poisoned_n mm/kasan/generic.c:129 [inline]\n RIP: 0010:memory_is_poisoned mm/kasan/generic.c:161 [inline]\n RIP: 0010:check_region_inline mm/kasan/generic.c:180 [inline]\n RIP: 0010:kasan_check_range+0x101/0x190 mm/kasan/generic.c:189\nCode: 07 49 39 d1 75 0a 45 3a 11 b8 01 00 00 00 7c 0b 44 89 c2 e8 21 ed ff ff 83 f0 01 5b 5d 41 5c c3 48 85 d2 74 4f 48 01 ea eb 09 <48> 83 c0 01 48 39 d0 74 41 80 38 00 74 f2 eb b6 41 bc 08 00 00 00\nRSP: 0018:ffffc90012dcf998 EFLAGS: 00000046\nRAX: fffffbfff258af1e RBX: fffffbfff258af1f RCX: ffffffff8168eda3\nRDX: fffffbfff258af1f RSI: 0000000000000004 RDI: ffffffff92c578f0\nRBP: fffffbfff258af1e R08: 0000000000000000 R09: fffffbfff258af1e\nR10: ffffffff92c578f3 R11: ffffffff8acbcbc0 R12: 0000000000000002\nR13: ffff88806db38400 R14: 1ffff920025b9f42 R15: ffffffff92c578e8\nFS:  0000000000000000(0000) GS:ffff8880b9800000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 000000c00994e078 CR3: 000000002c250000 CR4: 00000000003506f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <NMI>\n </NMI>\n <TASK>\n  instrument_atomic_read include/linux/instrumented.h:68 [inline]\n  atomic_read include/linux/atomic/atomic-instrumented.h:32 [inline]\n  queued_spin_is_locked include/asm-generic/qspinlock.h:57 [inline]\n  debug_spin_unlock kernel/locking/spinlock_debug.c:101 [inline]\n  do_raw_spin_unlock+0x53/0x230 kernel/locking/spinlock_debug.c:141\n  __raw_spin_unlock_irqrestore include/linux/spinlock_api_smp.h:150 [inline]\n  _raw_spin_unlock_irqrestore+0x22/0x70 kernel/locking/spinlock.c:194\n  debug_object_activate+0x349/0x540 lib/debugobjects.c:726\n  debug_work_activate kernel/workqueue.c:578 [inline]\n  insert_work+0x30/0x230 kernel/workqueue.c:1650\n  __queue_work+0x62e/0x11d0 kernel/workqueue.c:1802\n  __queue_delayed_work+0x1bf/0x270 kernel/workqueue.c:1953\n  queue_delayed_work_on+0x106/0x130 kernel/workqueue.c:1989\n  queue_delayed_work include/linux/workqueue.h:563 [inline]\n  schedule_delayed_work include/linux/workqueue.h:677 [inline]\n  nsim_dev_trap_report_work+0x9c0/0xc80 drivers/net/netdevsim/dev.c:842\n  process_one_work+0x886/0x15d0 kernel/workqueue.c:2633\n  process_scheduled_works kernel/workqueue.c:2706 [inline]\n  worker_thread+0x8b9/0x1290 kernel/workqueue.c:2787\n  kthread+0x2c6/0x3a0 kernel/kthread.c:388\n  ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:147\n  ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:242\n </TASK>",Semantic - Spec error,Failure to release CPU,FALSE,FALSE,"Potential wasteful loop caused by retrying to take a lock immediately. According to spec, after fail to aquire lock wait 0 units of time and try again, changes it to wait 1 unit of time.",
CVE-2024-26675,https://www.cve.org/CVERecord?id=CVE-2024-26675,Linux,"ppp_async: limit MRU to 64K\n\nsyzbot triggered a warning [1] in __alloc_pages():\n\nWARN_ON_ONCE_GFP(order > MAX_PAGE_ORDER, gfp)\n\nWillem fixed a similar issue in commit c0a2a1b0d631 (""ppp: limit MRU to 64K"")\n\nAdopt the same sanity check for ppp_async_ioctl(PPPIOCSMRU)\n\n[1]:\n\n WARNING: CPU: 1 PID: 11 at mm/page_alloc.c:4543 __alloc_pages+0x308/0x698 mm/page_alloc.c:4543\nModules linked in:\nCPU: 1 PID: 11 Comm: kworker/u4:0 Not tainted 6.8.0-rc2-syzkaller-g41bccc98fb79 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 11/17/2023\nWorkqueue: events_unbound flush_to_ldisc\npstate: 204000c5 (nzCv daIF +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n pc : __alloc_pages+0x308/0x698 mm/page_alloc.c:4543\n lr : __alloc_pages+0xc8/0x698 mm/page_alloc.c:4537\nsp : ffff800093967580\nx29: ffff800093967660 x28: ffff8000939675a0 x27: dfff800000000000\nx26: ffff70001272ceb4 x25: 0000000000000000 x24: ffff8000939675c0\nx23: 0000000000000000 x22: 0000000000060820 x21: 1ffff0001272ceb8\nx20: ffff8000939675e0 x19: 0000000000000010 x18: ffff800093967120\nx17: ffff800083bded5c x16: ffff80008ac97500 x15: 0000000000000005\nx14: 1ffff0001272cebc x13: 0000000000000000 x12: 0000000000000000\nx11: ffff70001272cec1 x10: 1ffff0001272cec0 x9 : 0000000000000001\nx8 : ffff800091c91000 x7 : 0000000000000000 x6 : 000000000000003f\nx5 : 00000000ffffffff x4 : 0000000000000000 x3 : 0000000000000020\nx2 : 0000000000000008 x1 : 0000000000000000 x0 : ffff8000939675e0\nCall trace:\n  __alloc_pages+0x308/0x698 mm/page_alloc.c:4543\n  __alloc_pages_node include/linux/gfp.h:238 [inline]\n  alloc_pages_node include/linux/gfp.h:261 [inline]\n  __kmalloc_large_node+0xbc/0x1fc mm/slub.c:3926\n  __do_kmalloc_node mm/slub.c:3969 [inline]\n  __kmalloc_node_track_caller+0x418/0x620 mm/slub.c:4001\n  kmalloc_reserve+0x17c/0x23c net/core/skbuff.c:590\n  __alloc_skb+0x1c8/0x3d8 net/core/skbuff.c:651\n  __netdev_alloc_skb+0xb8/0x3e8 net/core/skbuff.c:715\n  netdev_alloc_skb include/linux/skbuff.h:3235 [inline]\n  dev_alloc_skb include/linux/skbuff.h:3248 [inline]\n  ppp_async_input drivers/net/ppp/ppp_async.c:863 [inline]\n  ppp_asynctty_receive+0x588/0x186c drivers/net/ppp/ppp_async.c:341\n  tty_ldisc_receive_buf+0x12c/0x15c drivers/tty/tty_buffer.c:390\n  tty_port_default_receive_buf+0x74/0xac drivers/tty/tty_port.c:37\n  receive_buf drivers/tty/tty_buffer.c:444 [inline]\n  flush_to_ldisc+0x284/0x6e4 drivers/tty/tty_buffer.c:494\n  process_one_work+0x694/0x1204 kernel/workqueue.c:2633\n  process_scheduled_works kernel/workqueue.c:2706 [inline]\n  worker_thread+0x938/0xef4 kernel/workqueue.c:2787\n  kthread+0x288/0x310 kernel/kthread.c:388\n  ret_from_fork+0x10/0x20 arch/arm64/kernel/entry.S:860",Semantic - Improper input validation,High level spec violation,FALSE,FALSE,"ppp_async_ioctl(PPPIOCSMRU) can allow userspace to trigger allocation of a buffer that's too big to be allocated, causing a BUG/DOS. The same can also happen in regular Rust, but RFL's liballoc configuration enforces fallible allocation so the programmable can handle it.",
CVE-2024-26672,https://www.cve.org/CVERecord?id=CVE-2024-26672,Linux,"drm/amdgpu: Fix variable 'mca_funcs' dereferenced before NULL check in 'amdgpu_mca_smu_get_mca_entry()'\n\nFixes the below:\n\ndrivers/gpu/drm/amd/amdgpu/amdgpu_mca.c:377 amdgpu_mca_smu_get_mca_entry() warn: variable dereferenced before check 'mca_funcs' (see line 368)\n\n357 int amdgpu_mca_smu_get_mca_entry(struct amdgpu_device *adev,\n\t\t\t\t     enum amdgpu_mca_error_type type,\n358                                  int idx, struct mca_bank_entry *entry)\n359 {\n360         const struct amdgpu_mca_smu_funcs *mca_funcs =\n\t\t\t\t\t\tadev->mca.mca_funcs;\n361         int count;\n362\n363         switch (type) {\n364         case AMDGPU_MCA_ERROR_TYPE_UE:\n365                 count = mca_funcs->max_ue_count;\n\nmca_funcs is dereferenced here.\n\n366                 break;\n367         case AMDGPU_MCA_ERROR_TYPE_CE:\n368                 count = mca_funcs->max_ce_count;\n\nmca_funcs is dereferenced here.\n\n369                 break;\n370         default:\n371                 return -EINVAL;\n372         }\n373\n374         if (idx >= count)\n375                 return -EINVAL;\n376\n377         if (mca_funcs && mca_funcs->mca_get_mca_entry)\n\t        ^^^^^^^^^\n\nChecked too late!",Semantic - Improper input validation,Invalid pointer dereference,TRUE,TRUE,,
CVE-2024-26671,https://www.cve.org/CVERecord?id=CVE-2024-26671,Linux,"blk-mq: fix IO hang from sbitmap wakeup race\n\nIn blk_mq_mark_tag_wait(), __add_wait_queue() may be re-ordered\nwith the following blk_mq_get_driver_tag() in case of getting driver\ntag failure.\n\nThen in __sbitmap_queue_wake_up(), waitqueue_active() may not observe\nthe added waiter in blk_mq_mark_tag_wait() and wake up nothing, meantime\nblk_mq_mark_tag_wait() can't get driver tag successfully.\n\nThis issue can be reproduced by running the following test in loop, and\nfio hang can be observed in < 30min when running it on my test VM\nin laptop.\n\n\tmodprobe -r scsi_debug\n\tmodprobe scsi_debug delay=0 dev_size_mb=4096 max_queue=1 host_max_queue=1 submit_queues=4\n\tdev=`ls -d /sys/bus/pseudo/drivers/scsi_debug/adapter*/host*/target*/*/block/* | head -1 | xargs basename`\n\tfio --filename=/dev/""$dev"" --direct=1 --rw=randrw --bs=4k --iodepth=1 \\n       \t\t--runtime=100 --numjobs=40 --time_based --name=test \\n        \t--ioengine=libaio\n\nFix the issue by adding one explicit barrier in blk_mq_mark_tag_wait(), which\nis just fine in case of running out of tag.",Race condition - TOUTOC,Failure to release CPU,FALSE,TRUE,Manual write barrier,
CVE-2024-26662,https://www.cve.org/CVERecord?id=CVE-2024-26662,Linux,"drm/amd/display: Fix 'panel_cntl' could be null in 'dcn21_set_backlight_level()'\n\n'panel_cntl' structure used to control the display panel could be null,\ndereferencing it could lead to a null pointer access.\n\nFixes the below:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn21/dcn21_hwseq.c:269 dcn21_set_backlight_level() error: we previously assumed 'panel_cntl' could be null (see line 250)",Semantic - Improper input validation,Invalid pointer dereference,TRUE,TRUE,,
CVE-2024-26660,https://www.cve.org/CVERecord?id=CVE-2024-26660,Linux,"drm/amd/display: Implement bounds check for stream encoder creation in DCN301\n\n'stream_enc_regs' array is an array of dcn10_stream_enc_registers\nstructures. The array is initialized with four elements, corresponding\nto the four calls to stream_enc_regs() in the array initializer. This\nmeans that valid indices for this array are 0, 1, 2, and 3.\n\nThe error message 'stream_enc_regs' 4 <= 5 below, is indicating that\nthere is an attempt to access this array with an index of 5, which is\nout of bounds. This could lead to undefined behavior\n\nHere, eng_id is used as an index to access the stream_enc_regs array. If\neng_id is 5, this would result in an out-of-bounds access on the\nstream_enc_regs array.\n\nThus fixing OOB access error in dcn301_stream_encoder_create\nreported by Smatch:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/resource/dcn301/dcn301_resource.c:1011 dcn301_stream_encoder_create() error: buffer overflow 'stream_enc_regs' 4 <= 5",Semantic - Improper input validation,OOB access,TRUE,TRUE,,
CVE-2024-26648,https://www.cve.org/CVERecord?id=CVE-2024-26648,Linux,"drm/amd/display: Fix variable deferencing before NULL check in edp_setup_replay()\n\nIn edp_setup_replay(), 'struct dc *dc' & 'struct dmub_replay *replay'\nwas dereferenced before the pointer 'link' & 'replay' NULL check.\n\nFixes the below:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/link/protocols/link_edp_panel_control.c:947 edp_setup_replay() warn: variable dereferenced before check 'link' (see line 933)",Semantic - Logic error,Invalid pointer dereference,TRUE,TRUE,,
CVE-2024-26647,https://www.cve.org/CVERecord?id=CVE-2024-26647,Linux,"drm/amd/display: Fix late derefrence 'dsc' check in 'link_set_dsc_pps_packet()'\n\nIn link_set_dsc_pps_packet(), 'struct display_stream_compressor *dsc'\nwas dereferenced in a DC_LOGGER_INIT(dsc->ctx->logger); before the 'dsc'\nNULL pointer check.\n\nFixes the below:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/link/link_dpms.c:905 link_set_dsc_pps_packet() warn: variable dereferenced before check 'dsc' (see line 903)",Semantic - Logic error,Invalid pointer dereference,TRUE,TRUE,,
CVE-2024-26641,https://www.cve.org/CVERecord?id=CVE-2024-26641,Linux,"ip6_tunnel: make sure to pull inner header in __ip6_tnl_rcv()\n\nsyzbot found __ip6_tnl_rcv() could access unitiliazed data [1].\n\nCall pskb_inet_may_pull() to fix this, and initialize ipv6h\nvariable after this call as it can change skb->head.\n\n[1]\n BUG: KMSAN: uninit-value in __INET_ECN_decapsulate include/net/inet_ecn.h:253 [inline]\n BUG: KMSAN: uninit-value in INET_ECN_decapsulate include/net/inet_ecn.h:275 [inline]\n BUG: KMSAN: uninit-value in IP6_ECN_decapsulate+0x7df/0x1e50 include/net/inet_ecn.h:321\n  __INET_ECN_decapsulate include/net/inet_ecn.h:253 [inline]\n  INET_ECN_decapsulate include/net/inet_ecn.h:275 [inline]\n  IP6_ECN_decapsulate+0x7df/0x1e50 include/net/inet_ecn.h:321\n  ip6ip6_dscp_ecn_decapsulate+0x178/0x1b0 net/ipv6/ip6_tunnel.c:727\n  __ip6_tnl_rcv+0xd4e/0x1590 net/ipv6/ip6_tunnel.c:845\n  ip6_tnl_rcv+0xce/0x100 net/ipv6/ip6_tunnel.c:888\n gre_rcv+0x143f/0x1870\n  ip6_protocol_deliver_rcu+0xda6/0x2a60 net/ipv6/ip6_input.c:438\n  ip6_input_finish net/ipv6/ip6_input.c:483 [inline]\n  NF_HOOK include/linux/netfilter.h:314 [inline]\n  ip6_input+0x15d/0x430 net/ipv6/ip6_input.c:492\n  ip6_mc_input+0xa7e/0xc80 net/ipv6/ip6_input.c:586\n  dst_input include/net/dst.h:461 [inline]\n  ip6_rcv_finish+0x5db/0x870 net/ipv6/ip6_input.c:79\n  NF_HOOK include/linux/netfilter.h:314 [inline]\n  ipv6_rcv+0xda/0x390 net/ipv6/ip6_input.c:310\n  __netif_receive_skb_one_core net/core/dev.c:5532 [inline]\n  __netif_receive_skb+0x1a6/0x5a0 net/core/dev.c:5646\n  netif_receive_skb_internal net/core/dev.c:5732 [inline]\n  netif_receive_skb+0x58/0x660 net/core/dev.c:5791\n  tun_rx_batched+0x3ee/0x980 drivers/net/tun.c:1555\n  tun_get_user+0x53af/0x66d0 drivers/net/tun.c:2002\n  tun_chr_write_iter+0x3af/0x5d0 drivers/net/tun.c:2048\n  call_write_iter include/linux/fs.h:2084 [inline]\n  new_sync_write fs/read_write.c:497 [inline]\n  vfs_write+0x786/0x1200 fs/read_write.c:590\n  ksys_write+0x20f/0x4c0 fs/read_write.c:643\n  __do_sys_write fs/read_write.c:655 [inline]\n  __se_sys_write fs/read_write.c:652 [inline]\n  __x64_sys_write+0x93/0xd0 fs/read_write.c:652\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0x6d/0x140 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x63/0x6b\n\nUninit was created at:\n  slab_post_alloc_hook+0x129/0xa70 mm/slab.h:768\n  slab_alloc_node mm/slub.c:3478 [inline]\n  kmem_cache_alloc_node+0x5e9/0xb10 mm/slub.c:3523\n  kmalloc_reserve+0x13d/0x4a0 net/core/skbuff.c:560\n  __alloc_skb+0x318/0x740 net/core/skbuff.c:651\n  alloc_skb include/linux/skbuff.h:1286 [inline]\n  alloc_skb_with_frags+0xc8/0xbd0 net/core/skbuff.c:6334\n  sock_alloc_send_pskb+0xa80/0xbf0 net/core/sock.c:2787\n  tun_alloc_skb drivers/net/tun.c:1531 [inline]\n  tun_get_user+0x1e8a/0x66d0 drivers/net/tun.c:1846\n  tun_chr_write_iter+0x3af/0x5d0 drivers/net/tun.c:2048\n  call_write_iter include/linux/fs.h:2084 [inline]\n  new_sync_write fs/read_write.c:497 [inline]\n  vfs_write+0x786/0x1200 fs/read_write.c:590\n  ksys_write+0x20f/0x4c0 fs/read_write.c:643\n  __do_sys_write fs/read_write.c:655 [inline]\n  __se_sys_write fs/read_write.c:652 [inline]\n  __x64_sys_write+0x93/0xd0 fs/read_write.c:652\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0x6d/0x140 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x63/0x6b\n\nCPU: 0 PID: 5034 Comm: syz-executor331 Not tainted 6.7.0-syzkaller-00562-g9f8413c4a66f #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 11/17/2023",Semantic - Logic error,Uninitialized memory access,FALSE,FALSE,See CVE-2024-26882,
CVE-2024-26638,https://www.cve.org/CVERecord?id=CVE-2024-26638,Linux,"nbd: always initialize struct msghdr completely\n\nsyzbot complains that msg->msg_get_inq value can be uninitialized [1]\n\nstruct msghdr got many new fields recently, we should always make\nsure their values is zero by default.\n\n[1]\n BUG: KMSAN: uninit-value in tcp_recvmsg+0x686/0xac0 net/ipv4/tcp.c:2571\n  tcp_recvmsg+0x686/0xac0 net/ipv4/tcp.c:2571\n  inet_recvmsg+0x131/0x580 net/ipv4/af_inet.c:879\n  sock_recvmsg_nosec net/socket.c:1044 [inline]\n  sock_recvmsg+0x12b/0x1e0 net/socket.c:1066\n  __sock_xmit+0x236/0x5c0 drivers/block/nbd.c:538\n  nbd_read_reply drivers/block/nbd.c:732 [inline]\n  recv_work+0x262/0x3100 drivers/block/nbd.c:863\n  process_one_work kernel/workqueue.c:2627 [inline]\n  process_scheduled_works+0x104e/0x1e70 kernel/workqueue.c:2700\n  worker_thread+0xf45/0x1490 kernel/workqueue.c:2781\n  kthread+0x3ed/0x540 kernel/kthread.c:388\n  ret_from_fork+0x66/0x80 arch/x86/kernel/process.c:147\n  ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:242\n\nLocal variable msg created at:\n  __sock_xmit+0x4c/0x5c0 drivers/block/nbd.c:513\n  nbd_read_reply drivers/block/nbd.c:732 [inline]\n  recv_work+0x262/0x3100 drivers/block/nbd.c:863\n\nCPU: 1 PID: 7465 Comm: kworker/u5:1 Not tainted 6.7.0-rc7-syzkaller-00041-gf016f7547aee #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 11/17/2023\nWorkqueue: nbd5-recv recv_work",Language - Improper memory initialization,Uninitialized memory access,FALSE,TRUE,Uninitialized value which should be explicitly set to 0,
CVE-2024-26625,https://www.cve.org/CVERecord?id=CVE-2024-26625,Linux,"llc: call sock_orphan() at release time\n\nsyzbot reported an interesting trace [1] caused by a stale sk->sk_wq\npointer in a closed llc socket.\n\nIn commit ff7b11aa481f (""net: socket: set sock->sk to NULL after\ncalling proto_ops::release()"") Eric Biggers hinted that some protocols\nare missing a sock_orphan(), we need to perform a full audit.\n\nIn net-next, I plan to clear sock->sk from sock_orphan() and\namend Eric patch to add a warning.\n\n[1]\n BUG: KASAN: slab-use-after-free in list_empty include/linux/list.h:373 [inline]\n BUG: KASAN: slab-use-after-free in waitqueue_active include/linux/wait.h:127 [inline]\n BUG: KASAN: slab-use-after-free in sock_def_write_space_wfree net/core/sock.c:3384 [inline]\n BUG: KASAN: slab-use-after-free in sock_wfree+0x9a8/0x9d0 net/core/sock.c:2468\nRead of size 8 at addr ffff88802f4fc880 by task ksoftirqd/1/27\n\nCPU: 1 PID: 27 Comm: ksoftirqd/1 Not tainted 6.8.0-rc1-syzkaller-00049-g6098d87eaf31 #0\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.2-debian-1.16.2-1 04/01/2014\nCall Trace:\n <TASK>\n  __dump_stack lib/dump_stack.c:88 [inline]\n  dump_stack_lvl+0xd9/0x1b0 lib/dump_stack.c:106\n  print_address_description mm/kasan/report.c:377 [inline]\n  print_report+0xc4/0x620 mm/kasan/report.c:488\n  kasan_report+0xda/0x110 mm/kasan/report.c:601\n  list_empty include/linux/list.h:373 [inline]\n  waitqueue_active include/linux/wait.h:127 [inline]\n  sock_def_write_space_wfree net/core/sock.c:3384 [inline]\n  sock_wfree+0x9a8/0x9d0 net/core/sock.c:2468\n  skb_release_head_state+0xa3/0x2b0 net/core/skbuff.c:1080\n  skb_release_all net/core/skbuff.c:1092 [inline]\n  napi_consume_skb+0x119/0x2b0 net/core/skbuff.c:1404\n  e1000_unmap_and_free_tx_resource+0x144/0x200 drivers/net/ethernet/intel/e1000/e1000_main.c:1970\n  e1000_clean_tx_irq drivers/net/ethernet/intel/e1000/e1000_main.c:3860 [inline]\n  e1000_clean+0x4a1/0x26e0 drivers/net/ethernet/intel/e1000/e1000_main.c:3801\n  __napi_poll.constprop.0+0xb4/0x540 net/core/dev.c:6576\n  napi_poll net/core/dev.c:6645 [inline]\n  net_rx_action+0x956/0xe90 net/core/dev.c:6778\n  __do_softirq+0x21a/0x8de kernel/softirq.c:553\n  run_ksoftirqd kernel/softirq.c:921 [inline]\n  run_ksoftirqd+0x31/0x60 kernel/softirq.c:913\n  smpboot_thread_fn+0x660/0xa10 kernel/smpboot.c:164\n  kthread+0x2c6/0x3a0 kernel/kthread.c:388\n  ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:147\n  ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:242\n </TASK>\n\nAllocated by task 5167:\n  kasan_save_stack+0x33/0x50 mm/kasan/common.c:47\n  kasan_save_track+0x14/0x30 mm/kasan/common.c:68\n  unpoison_slab_object mm/kasan/common.c:314 [inline]\n  __kasan_slab_alloc+0x81/0x90 mm/kasan/common.c:340\n  kasan_slab_alloc include/linux/kasan.h:201 [inline]\n  slab_post_alloc_hook mm/slub.c:3813 [inline]\n  slab_alloc_node mm/slub.c:3860 [inline]\n  kmem_cache_alloc_lru+0x142/0x6f0 mm/slub.c:3879\n  alloc_inode_sb include/linux/fs.h:3019 [inline]\n  sock_alloc_inode+0x25/0x1c0 net/socket.c:308\n  alloc_inode+0x5d/0x220 fs/inode.c:260\n  new_inode_pseudo+0x16/0x80 fs/inode.c:1005\n  sock_alloc+0x40/0x270 net/socket.c:634\n  __sock_create+0xbc/0x800 net/socket.c:1535\n  sock_create net/socket.c:1622 [inline]\n  __sys_socket_create net/socket.c:1659 [inline]\n  __sys_socket+0x14c/0x260 net/socket.c:1706\n  __do_sys_socket net/socket.c:1720 [inline]\n  __se_sys_socket net/socket.c:1718 [inline]\n  __x64_sys_socket+0x72/0xb0 net/socket.c:1718\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xd3/0x250 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x63/0x6b\n\nFreed by task 0:\n  kasan_save_stack+0x33/0x50 mm/kasan/common.c:47\n  kasan_save_track+0x14/0x30 mm/kasan/common.c:68\n  kasan_save_free_info+0x3f/0x60 mm/kasan/generic.c:640\n  poison_slab_object mm/kasan/common.c:241 [inline]\n  __kasan_slab_free+0x121/0x1b0 mm/kasan/common.c:257\n  kasan_slab_free include/linux/kasan.h:184 [inline]\n  slab_free_hook mm/slub.c:2121 [inlin\n---truncated---",Language - Lifetime violation,Use after free,TRUE,TRUE,Removed because not a driver - UAF from missing sock_orphan,
CVE-2024-25740,https://www.cve.org/CVERecord?id=CVE-2024-25740,Linux,"A memory leak flaw was found in the UBI driver in drivers/mtd/ubi/attach.c in the Linux kernel through 6.7.4 for UBI_IOCATT, because kobj->name is not released.",Language - Lifetime violation,Resource leak,FALSE,TRUE,,
CVE-2024-25739,https://www.cve.org/CVERecord?id=CVE-2024-25739,Linux,"create_empty_lvol in drivers/mtd/ubi/vtbl.c in the Linux kernel through 6.7.4 can attempt to allocate zero bytes, and crash, because of a missing check for ubi->leb_size.",Semantic - Improper input validation,Explicit exception/panic,FALSE,FALSE,,
CVE-2024-23851,https://www.cve.org/CVERecord?id=CVE-2024-23851,Linux,"copy_params in drivers/md/dm-ioctl.c in the Linux kernel through 6.7.1 can attempt to allocate more than INT_MAX bytes, and crash, because of a missing param_kernel->data_size check. This is related to ctl_ioctl.",Semantic - Logic error,Explicit exception/panic,FALSE,FALSE,,
CVE-2024-23848,https://www.cve.org/CVERecord?id=CVE-2024-23848,Linux,"In the Linux kernel through 6.7.1, there is a use-after-free in cec_queue_msg_fh, related to drivers/media/cec/core/cec-adap.c and drivers/media/cec/core/cec-api.c.",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,,
CVE-2024-0340,https://www.cve.org/CVERecord?id=CVE-2024-0340,Linux,"A vulnerability was found in vhost_new_msg in drivers/vhost/vhost.c in the Linux kernel, which does not properly initialize memory in messages passed between virtual guests and the host operating system in the vhost/vhost.c:vhost_new_msg() function. This issue can allow local privileged users to read some kernel memory contents when reading from the /dev/vhost-net device file.",Language - Improper memory initialization,Uninitialized memory access,FALSE,FALSE,Will be Yes+P if we consider WritableToBytes,
CVE-2023-50431,https://www.cve.org/CVERecord?id=CVE-2023-50431,Linux,sec_attest_info in drivers/accel/habanalabs/common/habanalabs_ioctl.c in the Linux kernel through 6.6.5 allows an information leak to user space because info->pad0 is not initialized.,Language - Improper memory initialization,Uninitialized memory access,FALSE,FALSE,Patch zero'd memory.,
CVE-2023-47233,https://www.cve.org/CVERecord?id=CVE-2023-47233,Linux,"The brcm80211 component in the Linux kernel through 6.5.10 has a brcmf_cfg80211_detach use-after-free in the device unplugging (disconnect the USB by hotplug) code. For physically proximate attackers with local access, this ""could be exploited in a real world scenario."" This is related to brcmf_cfg80211_escan_timeout_worker in drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c.",Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't remove associated timer on clean up, which could cause UAF.",
CVE-2023-45871,https://www.cve.org/CVERecord?id=CVE-2023-45871,Linux,An issue was discovered in drivers/net/ethernet/intel/igb/igb_main.c in the IGB driver in the Linux kernel before 6.5.3. A buffer size may not be adequate for frames larger than the MTU.,Semantic - Logic error,OOB access,TRUE,TRUE,Missed edgecase that requires larger buffer.,
CVE-2023-45862,https://www.cve.org/CVERecord?id=CVE-2023-45862,Linux,An issue was discovered in drivers/usb/storage/ene_ub6250.c for the ENE UB6250 reader driver in the Linux kernel before 6.2.5. An object could potentially extend beyond the end of an allocation.,Semantic - Logic error,OOB access,TRUE,TRUE,Not enough memory allocated for buffer. Logic bug where offset is not taken into account for size calculation.,
CVE-2023-39198,https://www.cve.org/CVERecord?id=CVE-2023-39198,Linux,"A race condition was found in the QXL driver in the Linux kernel. The qxl_mode_dumb_create() function dereferences the qobj returned by the qxl_gem_object_create_with_handle(), but the handle is the only one holding a reference to it. This flaw allows an attacker to guess the returned handle value and trigger a use-after-free issue, potentially leading to a denial of service or privilege escalation.",Semantic - Spec error,Use after free,TRUE,TRUE,"Bad spec design, which passed around a refrence could lead to UAF. Patch reworked spec to pass the object directly.",
CVE-2023-38409,https://www.cve.org/CVERecord?id=CVE-2023-38409,Linux,"An issue was discovered in set_con2fb_map in drivers/video/fbdev/core/fbcon.c in the Linux kernel before 6.2.12. Because an assignment occurs only for the first vc, the fbcon_registered_fb and fbcon_display arrays can be desynchronized in fbcon_mode_deleted (the con2fb_map points at the old fb_info).",Semantic - Logic error,Use after free,TRUE,FALSE,"During the code restructuring, the assignment was moved into an if block, but should have been there for all the cases. Even if you write it in Rust, this won't prevent this attack",#N/A
CVE-2023-37453,https://www.cve.org/CVERecord?id=CVE-2023-37453,Linux,An issue was discovered in the USB subsystem in the Linux kernel through 6.4.2. There is an out-of-bounds and crash in read_descriptors in drivers/usb/core/sysfs.c.,Semantic - Spec error,OOB access,TRUE,TRUE,"Error in spec allowed for race condition. This race lead to OOB access, the patch had to change the spec to fix. https://bugzilla.redhat.com/show_bug.cgi?id=2221039",
CVE-2023-35829,https://www.cve.org/CVERecord?id=CVE-2023-35829,Linux,An issue was discovered in the Linux kernel before 6.3.2. A use-after-free was found in rkvdec_remove in drivers/staging/media/rkvdec/rkvdec.c.,Language - Lifetime violation,Use after free,TRUE,TRUE,Didn't cancel pending work on tear down.,
CVE-2023-35828,https://www.cve.org/CVERecord?id=CVE-2023-35828,Linux,An issue was discovered in the Linux kernel before 6.3.2. A use-after-free was found in renesas_usb3_remove in drivers/usb/gadget/udc/renesas_usb3.c.,Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't cancel pending work on tear down, leading to UAF. ",
CVE-2023-35827,https://www.cve.org/CVERecord?id=CVE-2023-35827,Linux,An issue was discovered in the Linux kernel through 6.3.8. A use-after-free was found in ravb_remove in drivers/net/ethernet/renesas/ravb_main.c.,Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't cancel pending work on tear down, leading to UAF.",
CVE-2023-35826,https://www.cve.org/CVERecord?id=CVE-2023-35826,Linux,An issue was discovered in the Linux kernel before 6.3.2. A use-after-free was found in cedrus_remove in drivers/staging/media/sunxi/cedrus/cedrus.c.,Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't cancel pending work on tear down, leading to UAF.",
CVE-2023-35824,https://www.cve.org/CVERecord?id=CVE-2023-35824,Linux,An issue was discovered in the Linux kernel before 6.3.2. A use-after-free was found in dm1105_remove in drivers/media/pci/dm1105/dm1105.c.,Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't cancel pending work on tear down, leading to UAF.",
CVE-2023-35823,https://www.cve.org/CVERecord?id=CVE-2023-35823,Linux,An issue was discovered in the Linux kernel before 6.3.2. A use-after-free was found in saa7134_finidev in drivers/media/pci/saa7134/saa7134-core.c.,Language - Lifetime violation,Use after free,TRUE,TRUE,Didn't remove timers on cleanup leading to potential UAF.,
CVE-2023-33952,https://www.cve.org/CVERecord?id=CVE-2023-33952,Linux,A double-free vulnerability was found in the vmwgfx driver in the Linux kernel. The flaw exists within the handling of vmw_buffer_object objects. The issue results from the lack of validating the existence of an object prior to performing further free operations on the object. This flaw allows a local privileged user to escalate privileges and execute code in the context of the kernel.,Language - Lifetime violation,Double free,FALSE,TRUE,*User able to trigger an early free. Which caused double free when clean up happens. CVE issued because there is no checks prior to free.,
CVE-2023-33951,https://www.cve.org/CVERecord?id=CVE-2023-33951,Linux,A race condition vulnerability was found in the vmwgfx driver in the Linux kernel. The flaw exists within the handling of GEM objects. The issue results from improper locking when performing operations on an object. This flaw allows a local privileged user to disclose information in the context of the kernel.,Language - Lifetime violation,Use after free,TRUE,TRUE,*User able to trigger an early free. CVE issued for UAF during rest of lifetime.,
CVE-2023-33288,https://www.cve.org/CVERecord?id=CVE-2023-33288,Linux,An issue was discovered in the Linux kernel before 6.2.9. A use-after-free was found in bq24190_remove in drivers/power/supply/bq24190_charger.c. It could allow a local attacker to crash the system due to a race condition.,Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't cancel pending work on tear down, leading to UAF.",
CVE-2023-33250,https://www.cve.org/CVERecord?id=CVE-2023-33250,Linux,The Linux kernel 6.3 has a use-after-free in iopt_unmap_iova_range in drivers/iommu/iommufd/io_pagetable.c.,Race condition - TOUTOC,Use after free,TRUE,TRUE,Race condition in protocol allowed UAF.,
CVE-2023-33203,https://www.cve.org/CVERecord?id=CVE-2023-33203,Linux,The Linux kernel before 6.2.9 has a race condition and resultant use-after-free in drivers/net/ethernet/qualcomm/emac/emac.c if a physically proximate attacker unplugs an emac based device.,Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't cancel pending work on tear down, leading to UAF.",
CVE-2023-32810,https://www.cve.org/CVERecord?id=CVE-2023-32810,Linux,"In bluetooth driver, there is a possible out of bounds read due to improper input validation. This could lead to local information leak with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07867212; Issue ID: ALPS07867212.",Semantic - Improper input validation,OOB access,TRUE,TRUE,,
CVE-2023-31085,https://www.cve.org/CVERecord?id=CVE-2023-31085,Linux,"An issue was discovered in drivers/mtd/ubi/cdev.c in the Linux kernel 6.2. There is a divide-by-zero error in do_div(sz,mtd->erasesize), used indirectly by ctrl_cdev_ioctl, when mtd->erasesize is 0.",Semantic - Improper input validation,Explicit exception/panic,FALSE,TRUE,Divison by 0 due to improper check.,
CVE-2023-31084,https://www.cve.org/CVERecord?id=CVE-2023-31084,Linux,"An issue was discovered in drivers/media/dvb-core/dvb_frontend.c in the Linux kernel 6.2. There is a blocking operation when a task is in !TASK_RUNNING. In dvb_frontend_get_event, wait_event_interruptible is called; the condition is dvb_frontend_test_event(fepriv,events). In dvb_frontend_test_event, down(&fepriv->sem) is called. However, wait_event_interruptible would put the process to sleep, and down(&fepriv->sem) may block the process.",Race condition - Improper usage of synchronization primitives,Failure to release CPU,FALSE,FALSE,"wait_event_interruptible(queue, dvb_frontend_test_event(fepriv, events));
dvb_frontend_test_event can potentially perform blocking operation, which violates spec of wait_event",
CVE-2023-31083,https://www.cve.org/CVERecord?id=CVE-2023-31083,Linux,"An issue was discovered in drivers/bluetooth/hci_ldisc.c in the Linux kernel 6.2. In hci_uart_tty_ioctl, there is a race condition between HCIUARTSETPROTO and HCIUARTGETPROTO. HCI_UART_PROTO_SET is set before hu->proto is set. A NULL pointer dereference may occur.",Race condition - TOUTOC,Use after free,TRUE,TRUE,,
CVE-2023-31082,https://www.cve.org/CVERecord?id=CVE-2023-31082,Linux,"An issue was discovered in drivers/tty/n_gsm.c in the Linux kernel 6.2. There is a sleeping function called from an invalid context in gsmld_write, which will block the kernel.",Protocol - Sleeping in atomic context,Failure to release CPU,FALSE,FALSE,*,
CVE-2023-31081,https://www.cve.org/CVERecord?id=CVE-2023-31081,Linux,"An issue was discovered in drivers/media/test-drivers/vidtv/vidtv_bridge.c in the Linux kernel 6.2. There is a NULL pointer dereference in vidtv_mux_stop_thread. In vidtv_stop_streaming, after dvb->mux=NULL occurs, it executes vidtv_mux_stop_thread(dvb->mux).",Race condition - TOUTOC,Invalid pointer dereference,TRUE,TRUE,Race in protocol which allows for a function to be called with a pointer that has been set to null.,
CVE-2023-30772,https://www.cve.org/CVERecord?id=CVE-2023-30772,Linux,The Linux kernel before 6.2.9 has a race condition and resultant use-after-free in drivers/power/supply/da9150-charger.c if a physically proximate attacker unplugs a device.,Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't cancel queue'd work on clean up, could lead to UAF.",
CVE-2023-28328,https://www.cve.org/CVERecord?id=CVE-2023-28328,Linux,A NULL pointer dereference flaw was found in the az6027 driver in drivers/media/usb/dev-usb/az6027.c in the Linux Kernel. The message from user space is not checked properly before transferring into the device. This flaw allows a local user to crash the system or potentially cause a denial of service.,Semantic - Improper input validation,Invalid pointer dereference,TRUE,TRUE,User input edge cases cause null pointer dereferences. ,
CVE-2023-26242,https://www.cve.org/CVERecord?id=CVE-2023-26242,Linux,afu_mmio_region_get_by_offset in drivers/fpga/dfl-afu-region.c in the Linux kernel through 6.1.12 has an integer overflow.,Language - Integer overflow,OOB access,TRUE,TRUE,Overflow possible leading to mismatch between size allocated and the intended size.,
CVE-2023-25012,https://www.cve.org/CVERecord?id=CVE-2023-25012,Linux,The Linux kernel through 6.1.9 has a Use-After-Free in bigben_remove in drivers/hid/hid-bigbenff.c via a crafted USB device because the LED controllers remain registered for too long.,Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't unregister device properly on clean up, leading to potential UAF.",
CVE-2023-23559,https://www.cve.org/CVERecord?id=CVE-2023-23559,Linux,"In rndis_query_oid in drivers/net/wireless/rndis_wlan.c in the Linux kernel through 6.1.5, there is an integer overflow in an addition.",Language - Integer overflow,OOB access,TRUE,TRUE,"Ints in buffer operations could overflow to negative values, leading to buffer overflow vulnerabilities.",
CVE-2023-23039,https://www.cve.org/CVERecord?id=CVE-2023-23039,Linux,"An issue was discovered in the Linux kernel through 6.2.0-rc2. drivers/tty/vcc.c has a race condition and resultant use-after-free if a physically proximate attacker removes a VCC device while calling open(), aka a race condition between vcc_open() and vcc_remove().",Race condition - TOUTOC,Use after free,TRUE,TRUE,"*The race will be solved by reference counting primitives in Rust. Race condition on physical removal of device may leave stale references, leading to UAF.",
CVE-2023-23006,https://www.cve.org/CVERecord?id=CVE-2023-23006,Linux,"In the Linux kernel before 5.15.13, drivers/net/ethernet/mellanox/mlx5/core/steering/dr_domain.c misinterprets the mlx5_get_uars_page return value (expects it to be NULL in the error case, whereas it is actually an error pointer).",Language -  Polymorphism,Invalid pointer dereference,TRUE,TRUE,"Not checking error pointer correctly. Assumes error pointer == null, which isn't true in this case.",
CVE-2023-23004,https://www.cve.org/CVERecord?id=CVE-2023-23004,Linux,"In the Linux kernel before 5.19, drivers/gpu/drm/arm/malidp_planes.c misinterprets the get_sg_table return value (expects it to be NULL in the error case, whereas it is actually an error pointer).",Language -  Polymorphism,Invalid pointer dereference,TRUE,TRUE,"Not checking error pointer correctly. Assumes error pointer == null, which isn't true in this case.",
CVE-2023-23002,https://www.cve.org/CVERecord?id=CVE-2023-23002,Linux,"In the Linux kernel before 5.16.3, drivers/bluetooth/hci_qca.c misinterprets the devm_gpiod_get_index_optional return value (expects it to be NULL in the error case, whereas it is actually an error pointer).",Language -  Polymorphism,Invalid pointer dereference,TRUE,TRUE,"Not checking error pointer correctly. Could be error pointer or null so should use IS_ERR_OR_NULL(), which it doesn't.",
CVE-2023-23001,https://www.cve.org/CVERecord?id=CVE-2023-23001,Linux,"In the Linux kernel before 5.16.3, drivers/scsi/ufs/ufs-mediatek.c misinterprets the regulator_get return value (expects it to be NULL in the error case, whereas it is actually an error pointer).",Language -  Polymorphism,Invalid pointer dereference,TRUE,TRUE,"Not checking error pointer correctly. Assumes error pointer == null, which isn't true in this case.",
CVE-2023-23000,https://www.cve.org/CVERecord?id=CVE-2023-23000,Linux,"In the Linux kernel before 5.17, drivers/phy/tegra/xusb.c mishandles the tegra_xusb_find_port_node return value. Callers expect NULL in the error case, but an error pointer is used.",Language -  Polymorphism,Invalid pointer dereference,TRUE,TRUE,Confusion about whether error pointers should be null.,
CVE-2023-22999,https://www.cve.org/CVERecord?id=CVE-2023-22999,Linux,"In the Linux kernel before 5.16.3, drivers/usb/dwc3/dwc3-qcom.c misinterprets the dwc3_qcom_create_urs_usb_platdev return value (expects it to be NULL in the error case, whereas it is actually an error pointer).",Language -  Polymorphism,Invalid pointer dereference,TRUE,TRUE,Checking if null for errors when it could also be an error pointer. Should use IS_ERR_OR_NULL() instead.,
CVE-2023-22998,https://www.cve.org/CVERecord?id=CVE-2023-22998,Linux,"In the Linux kernel before 6.0.3, drivers/gpu/drm/virtio/virtgpu_object.c misinterprets the drm_gem_shmem_get_sg_table return value (expects it to be NULL in the error case, whereas it is actually an error pointer).",Language -  Polymorphism,Invalid pointer dereference,TRUE,TRUE,"Not checking error pointer correctly. Assumes error pointer == null, which isn't true in this case.",
CVE-2023-22996,https://www.cve.org/CVERecord?id=CVE-2023-22996,Linux,"In the Linux kernel before 5.17.2, drivers/soc/qcom/qcom_aoss.c does not release an of_find_device_by_node reference after use, e.g., with put_device.",Language - Lifetime violation,Resource leak,FALSE,TRUE,Didn't decrease reference count on error path.,
CVE-2023-22995,https://www.cve.org/CVERecord?id=CVE-2023-22995,Linux,"In the Linux kernel before 5.17, an error path in dwc3_qcom_acpi_register_core in drivers/usb/dwc3/dwc3-qcom.c lacks certain platform_device_put and kfree calls.",Language - Lifetime violation,Resource leak,FALSE,TRUE,Didn't decrease reference count on error path.,
CVE-2023-7042,https://www.cve.org/CVERecord?id=CVE-2023-7042,Linux,A null pointer dereference vulnerability was found in ath10k_wmi_tlv_op_pull_mgmt_tx_compl_ev() in drivers/net/wireless/ath/ath10k/wmi-tlv.c in the Linux kernel. This issue could be exploited to trigger a denial of service.,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,For now,
CVE-2023-6238,https://www.cve.org/CVERecord?id=CVE-2023-6238,Linux,"A buffer overflow vulnerability was found in the NVM Express (NVMe) driver in the Linux kernel. Only privileged user could specify a small meta buffer and let the device perform larger Direct Memory Access (DMA) into the same buffer, overwriting unrelated kernel memory, causing random kernel crashes and memory corruption.",Semantic - Improper input validation,OOB access,TRUE,FALSE,The device does DMA outside of the buffer. No Rust can save it. User specified buffer size can be too small.,
CVE-2023-6039,https://www.cve.org/CVERecord?id=CVE-2023-6039,Linux,"A use-after-free flaw was found in lan78xx_disconnect in drivers/net/usb/lan78xx.c in the network sub-component, net/usb/lan78xx in the Linux Kernel. This flaw allows a local attacker to crash the system when the LAN78XX USB device detaches.",Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't cancel associated timers on tear down, leading to potential UAF.",
CVE-2023-5178,https://www.cve.org/CVERecord?id=CVE-2023-5178,Linux,"A use-after-free vulnerability was found in drivers/nvme/target/tcp.c` in `nvmet_tcp_free_crypto` due to a logical bug in the NVMe/TCP subsystem in the Linux kernel. This issue may allow a malicious user to cause a use-after-free and double-free problem, which may permit remote code execution or lead to local privilege escalation.",Semantic - Logic error,Use after free,TRUE,TRUE,,
CVE-2023-5158,https://www.cve.org/CVERecord?id=CVE-2023-5158,Linux,A flaw was found in vringh_kiov_advance in drivers/vhost/vringh.c in the host side of a virtio ring in the Linux Kernel. This issue may result in a denial of service from guest to host via zero length descriptor.,Semantic - Loop termination,Failure to release CPU,FALSE,FALSE,Can cause infinite loop DOS due to logic bug in iterator.,
CVE-2023-4387,https://www.cve.org/CVERecord?id=CVE-2023-4387,Linux,"A use-after-free flaw was found in vmxnet3_rq_alloc_rx_buf in drivers/net/vmxnet3/vmxnet3_drv.c in VMware's vmxnet3 ethernet NIC driver in the Linux Kernel. This issue could allow a local attacker to crash the system due to a double-free while cleaning up vmxnet3_rq_cleanup_all, which could also lead to a kernel information leak problem.",Language - Lifetime violation,Double free,FALSE,TRUE,"Free on fail, and tries to free again on clean up.",
CVE-2023-4273,https://www.cve.org/CVERecord?id=CVE-2023-4273,Linux,"A flaw was found in the exFAT driver of the Linux kernel. The vulnerability exists in the implementation of the file name reconstruction function, which is responsible for reading file name entries from a directory index and merging file name parts belonging to one file into a single long file name. Since the file name characters are copied into a stack variable, a local privileged attacker could use this flaw to overflow the kernel stack.",Semantic - Improper input validation,OOB access,TRUE,TRUE,"Missing bounds check, which allows user to overflow kernel stack.",
CVE-2023-4133,https://www.cve.org/CVERecord?id=CVE-2023-4133,Linux,"A use-after-free vulnerability was found in the cxgb4 driver in the Linux kernel. The bug occurs when the cxgb4 device is detaching due to a possible rearming of the flower_stats_timer from the work queue. This flaw allows a local user to crash the system, causing a denial of service condition.",Semantic - Spec error,Use after free,TRUE,TRUE,Spec error had circular dependency which allowed UAF bugs.,
CVE-2023-4010,https://www.cve.org/CVERecord?id=CVE-2023-4010,Linux,"A flaw was found in the USB Host Controller Driver framework in the Linux kernel. The usb_giveback_urb function has a logic loophole in its implementation. Due to the inappropriate judgment condition of the goto statement, the function cannot return under the input of a specific malformed descriptor file, so it falls into an endless loop, resulting in a denial of service.",Semantic - Loop termination,Failure to release CPU,FALSE,FALSE,Logic error in goto condition causes infinite loop.,
CVE-2023-3812,https://www.cve.org/CVERecord?id=CVE-2023-3812,Linux,An out-of-bounds memory access flaw was found in the Linux kernels TUN/TAP device driver functionality in how a user generates a malicious (too big) networking packet when napi frags is enabled. This flaw allows a local user to crash or potentially escalate their privileges on the system.,Semantic - Improper input validation,OOB access,TRUE,TRUE,Missing edge case in input validation.,
CVE-2023-3567,https://www.cve.org/CVERecord?id=CVE-2023-3567,Linux,A use-after-free flaw was found in vcs_read in drivers/tty/vt/vc_screen.c in vc_screen in the Linux Kernel. This issue may allow an attacker with local user access to cause a system crash or leak internal kernel information.,Semantic - Logic error,Use after free,TRUE,TRUE,Wrong logic order of execution order allowed for UAF.,
CVE-2023-3359,https://www.cve.org/CVERecord?id=CVE-2023-3359,Linux,An issue was discovered in the Linux kernel brcm_nvram_parse in drivers/nvmem/brcm_nvram.c. Lacks for the check of the return value of kzalloc() can cause the NULL Pointer Dereference.,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,Didn't check return of kzalloc(),
CVE-2023-3358,https://www.cve.org/CVERecord?id=CVE-2023-3358,Linux,A null pointer dereference was found in the Linux kernel's Integrated Sensor Hub (ISH) driver. This issue could allow a local user to crash the system.,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,ishtp_dma_tx_map could be null and wasn't checked before dereferencing.,
CVE-2023-3357,https://www.cve.org/CVERecord?id=CVE-2023-3357,Linux,A NULL pointer dereference flaw was found in the Linux kernel AMD Sensor Fusion Hub driver. This flaw allows a local user to crash the system.,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,Missing return value check of allocation which returns null on fail.,
CVE-2023-3355,https://www.cve.org/CVERecord?id=CVE-2023-3355,Linux,"A NULL pointer dereference flaw was found in the Linux kernel's drivers/gpu/drm/msm/msm_gem_submit.c code in the submit_lookup_cmds function, which fails because it lacks a check of the return value of kmalloc(). This issue allows a local user to crash the system.",Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,Didn't check return of kmalloc(),
CVE-2023-3317,https://www.cve.org/CVERecord?id=CVE-2023-3317,Linux,A use-after-free flaw was found in mt7921_check_offload_capability in drivers/net/wireless/mediatek/mt76/mt7921/init.c in wifi mt76/mt7921 sub-component in the Linux Kernel. This flaw could allow an attacker to crash the system after 'features' memory release. This vulnerability could even lead to a kernel information leak problem.,Semantic - Spec error,Use after free,TRUE,TRUE,Spec refrenced free'd memory in turnary operator.,
CVE-2023-3312,https://www.cve.org/CVERecord?id=CVE-2023-3312,Linux,"A vulnerability was found in drivers/cpufreq/qcom-cpufreq-hw.c in cpufreq subsystem in the Linux Kernel. This flaw, during device unbind will lead to double release problem leading to denial of service.",Semantic - Spec error,Double free,FALSE,TRUE,"*Double free due to bug in spec, where residual clean up code left from previous commit.",
CVE-2023-3220,https://www.cve.org/CVERecord?id=CVE-2023-3220,Linux,An issue was discovered in the Linux kernel through 6.1-rc8. dpu_crtc_atomic_check in drivers/gpu/drm/msm/disp/dpu1/dpu_crtc.c lacks check of the return value of kzalloc() and will cause the NULL Pointer Dereference.,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,Didn't check return of kzalloc(),
CVE-2023-3159,https://www.cve.org/CVERecord?id=CVE-2023-3159,Linux,A use after free issue was discovered in driver/firewire in outbound_phy_packet_callback in the Linux Kernel. In this flaw a local attacker with special privilege may cause a use after free problem when queue_event() fails.,Semantic - Spec error,Use after free,TRUE,TRUE,"Same object shared by refrence could lead to UAF, patch makes local copy to avoid UAF. Issue at spec level.",
CVE-2023-3141,https://www.cve.org/CVERecord?id=CVE-2023-3141,Linux,"A use-after-free flaw was found in r592_remove in drivers/memstick/host/r592.c in media access in the Linux Kernel. This flaw allows a local attacker to crash the system at device disconnect, possibly leading to a kernel information leak.",Language - Lifetime violation,Use after free,TRUE,TRUE,"Work isn't cancelled on clean up, leading to potential UAF.",
CVE-2023-3090,https://www.cve.org/CVERecord?id=CVE-2023-3090,Linux,A heap out-of-bounds write vulnerability in the Linux Kernel ipvlan network driver can be exploited to achieve local privilege escalation.\n\nThe out-of-bounds write is caused by missing skb->cb  initialization in the ipvlan network driver. The vulnerability is reachable ifCONFIG_IPVLAN is enabled.\n\n\nWe recommend upgrading past commit 90cbed5247439a966b645b34eb0a2e037836ea8e.,Protocol - Missing Protocol Steps,Invalid pointer dereference,TRUE,TRUE,SKB has a scratchpad buffer (skb->cb) that could be used by any layer. Some one uses it and it is not reset. OOB could happen because of that.,
CVE-2023-2269,https://www.cve.org/CVERecord?id=CVE-2023-2269,Linux,"A denial of service problem was found, due to a possible recursive locking scenario, resulting in a deadlock in table_clear in drivers/md/dm-ioctl.c in the Linux Kernel Device Mapper-Multipathing sub-component.",Race condition - Improper usage of synchronization primitives,Failure to release CPU,FALSE,FALSE,For now. This is a deadlock caused by logical bug,
CVE-2023-2194,https://www.cve.org/CVERecord?id=CVE-2023-2194,Linux,"An out-of-bounds write vulnerability was found in the Linux kernel's SLIMpro I2C device driver. The userspace ""data->block[0]"" variable was not capped to a number between 0-255 and was used as the size of a memcpy, possibly writing beyond the end of dma_buffer. This flaw could allow a local privileged user to crash the system or potentially achieve code execution.",Semantic - Improper input validation,OOB access,TRUE,TRUE,Didn't check input for length that's OOB.,
CVE-2023-2176,https://www.cve.org/CVERecord?id=CVE-2023-2176,Linux,"A vulnerability was found in compare_netdev_and_ip in drivers/infiniband/core/cma.c in RDMA in the Linux Kernel. The improper cleanup results in out-of-boundary read, where a local user can utilize this problem to crash the system or escalation of privilege.",Semantic - Spec error,OOB access,TRUE,TRUE,Spec allowed for OOB access due to it's incorrect error handling.,
CVE-2023-2162,https://www.cve.org/CVERecord?id=CVE-2023-2162,Linux,A use-after-free vulnerability was found in iscsi_sw_tcp_session_create in drivers/scsi/iscsi_tcp.c in SCSI sub-component in the Linux Kernel. In this flaw an attacker could leak kernel internal information.,Semantic - Spec error,Use after free,TRUE,TRUE,"The driver advertises a pointer to the kernel but may deallocate it on fail, which could allow UAF. Patch changes spec to set pointer only after success. Userspace is accessing memory while the kernel can free it.

Yes because the abstraction can make ref-counting congruent across the driver and kernel. ",
CVE-2023-2019,https://www.cve.org/CVERecord?id=CVE-2023-2019,Linux,"A flaw was found in the Linux kernel's netdevsim device driver, within the scheduling of events. This issue results from the improper management of a reference count. This may allow an attacker to create a denial of service condition on the system.",Language - Lifetime violation,Resource leak,FALSE,TRUE,,
CVE-2023-2008,https://www.cve.org/CVERecord?id=CVE-2023-2008,Linux,"A flaw was found in the Linux kernel's udmabuf device driver. The specific flaw exists within a fault handler. The issue results from the lack of proper validation of user-supplied data, which can result in a memory access past the end of an array. An attacker can leverage this vulnerability to escalate privileges and execute arbitrary code in the context of the kernel.",Semantic - Improper input validation,OOB access,TRUE,TRUE,Missing input validation could allow user to trigger OOB access.,
CVE-2023-1990,https://www.cve.org/CVERecord?id=CVE-2023-1990,Linux,A use-after-free flaw was found in ndlc_remove in drivers/nfc/st-nci/ndlc.c in the Linux Kernel. This flaw could allow an attacker to crash the system due to a race problem.,Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't cancel queue'd work on clean up, leading to potential UAF.",
CVE-2023-1989,https://www.cve.org/CVERecord?id=CVE-2023-1989,Linux,"A use-after-free flaw was found in btsdio_remove in drivers\bluetooth\btsdio.c in the Linux Kernel. In this flaw, a call to btsdio_remove with an unfinished job, may cause a race problem leading to a UAF on hdev devices.",Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't cancel queue'd work on clean up, leading to potential UAF.",
CVE-2023-1855,https://www.cve.org/CVERecord?id=CVE-2023-1855,Linux,A use-after-free flaw was found in xgene_hwmon_remove in drivers/hwmon/xgene-hwmon.c in the Hardware Monitoring Linux Kernel Driver (xgene-hwmon). This flaw could allow a local attacker to crash the system due to a race problem. This vulnerability could even lead to a kernel information leak problem.,Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't cancel queue'd work on clean up, leading to potential UAF.",
CVE-2023-1838,https://www.cve.org/CVERecord?id=CVE-2023-1838,Linux,"A use-after-free flaw was found in vhost_net_set_backend in drivers/vhost/net.c in virtio network subcomponent in the Linux kernel due to a double fget. This flaw could allow a local attacker to crash the system, and could even lead to a kernel information leak problem. ",Semantic - Logic error,Use after free,TRUE,TRUE,,
CVE-2023-1670,https://www.cve.org/CVERecord?id=CVE-2023-1670,Linux,A flaw use after free in the Linux kernel Xircom 16-bit PCMCIA (PC-card) Ethernet driver was found.A local user could use this flaw to crash the system or potentially escalate their privileges on the system.,Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't properly cancel work and remove refrences on clean up, leading to potential UAF.",
CVE-2023-1380,https://www.cve.org/CVERecord?id=CVE-2023-1380,Linux,"A slab-out-of-bound read problem was found in brcmf_get_assoc_ies in drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c in the Linux Kernel. This issue could occur when assoc_info->req_len data is bigger than the size of the buffer, defined as WL_EXTRA_BUF_MAX, leading to a denial of service.",Semantic - Improper input validation,OOB access,TRUE,TRUE,Missing bound check.,
CVE-2023-1118,https://www.cve.org/CVERecord?id=CVE-2023-1118,Linux,A flaw use after free in the Linux kernel integrated infrared receiver/transceiver driver was found in the way user detaching rc device. A local user could use this flaw to crash the system or potentially escalate their privileges on the system.,Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't remove timer associated with device on clean up, which allowed for UAF.",
CVE-2023-1076,https://www.cve.org/CVERecord?id=CVE-2023-1076,Linux,"A flaw was found in the Linux Kernel. The tun/tap sockets have their socket UID hardcoded to 0 due to a type confusion in their initialization function. While it will be often correct, as tuntap devices require CAP_NET_ADMIN, it may not always be the case, e.g., a non-root user only having that capability. This would make tun/tap sockets being incorrectly treated in filtering/routing decisions, possibly bypassing network filters.",Language - Container_of,Access control violation,FALSE,TRUE,,
CVE-2023-0030,https://www.cve.org/CVERecord?id=CVE-2023-0030,Linux,A use-after-free flaw was found in the Linux kernels nouveau driver in how a user triggers a memory overflow that causes the nvkm_vma_tail function to fail. This flaw allows a local user to crash or potentially escalate their privileges on the system.,Semantic - Missing return value check,Use after free,TRUE,TRUE,"Missing return value check, resource will free on fail and cause UAF.",
CVE-2022-41858,https://www.cve.org/CVERecord?id=CVE-2022-41858,Linux,In 2023 linux dataset.,Protocol - Missing Protocol Steps,Invalid pointer dereference,TRUE,TRUE,Possible to trigger DOS. Missing null check allows for DOS in edge case,
CVE-2022-4842,https://www.cve.org/CVERecord?id=CVE-2022-4842,Linux,In 2023 linux dataset.,Semantic - Logic error,Invalid pointer dereference,TRUE,TRUE,It's just triggering DOS. Cheri shouldn't fix it.,
CVE-2022-4744,https://www.cve.org/CVERecord?id=CVE-2022-4744,Linux,In 2023 linux dataset.,Semantic - Spec error,Double free,FALSE,TRUE,"Improper spec allowed double free, was rewritten in patch. Not just a logic error.",
CVE-2022-4382,https://www.cve.org/CVERecord?id=CVE-2022-4382,Linux,In 2023 linux dataset.,Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,Patch added locks to fix UAF.,
CVE-2022-4139,https://www.cve.org/CVERecord?id=CVE-2022-4139,Linux,In 2023 linux dataset.,Protocol - Missing Protocol Steps,High level spec violation,FALSE,FALSE,driver fails to enable some bits that cause tlb invalidatation not work. ,
CVE-2022-4095,https://www.cve.org/CVERecord?id=CVE-2022-4095,Linux,In 2023 linux dataset.,Semantic - Spec error,Use after free,TRUE,TRUE,"Error in spec, allowed for UAF",
CVE-2022-3707,https://www.cve.org/CVERecord?id=CVE-2022-3707,Linux,In 2023 linux dataset.,Language - Lifetime violation,Double free,FALSE,TRUE,On fail frees in function and in the return.,
CVE-2022-3628,https://www.cve.org/CVERecord?id=CVE-2022-3628,Linux,In 2023 linux dataset.,Semantic - Improper input validation,OOB access,TRUE,TRUE,,
CVE-2022-3424,https://www.cve.org/CVERecord?id=CVE-2022-3424,Linux,In 2023 linux dataset.,Semantic - Missing return value check,Use after free,TRUE,TRUE,"Didn't check return of gru_check_context_placement(), which frees on fail leading to UAF.",
CVE-2020-36766,https://www.cve.org/CVERecord?id=CVE-2020-36766,Linux,In 2023 linux dataset.,Language - Improper memory initialization,Uninitialized memory access,FALSE,#N/A,,
CVE-2022-47521,https://www.cve.org/CVERecord?id=CVE-2022-47521,Linux,An issue was discovered in the Linux kernel before 6.0.11. Missing validation of IEEE80211_P2P_ATTR_CHANNEL_LIST in drivers/net/wireless/microchip/wilc1000/cfg80211.c in the WILC1000 wireless driver can trigger a heap-based buffer overflow when parsing the operating channel attribute from Wi-Fi management frames.,Language - Integer overflow,OOB access,TRUE,TRUE,Length check missing. Rust vec will help but input sanitization still required ,
CVE-2022-47520,https://www.cve.org/CVERecord?id=CVE-2022-47520,Linux,An issue was discovered in the Linux kernel before 6.0.11. Missing offset validation in drivers/net/wireless/microchip/wilc1000/hif.c in the WILC1000 wireless driver can trigger an out-of-bounds read when parsing a Robust Security Network (RSN) information element from a Netlink packet.,Semantic - Improper input validation,OOB access,TRUE,TRUE,"Either runtime panic or compiletime assertion must happen.
If rsn_ie gets reimplemented in rust as a vec, it might still trigger panic",
CVE-2022-47519,https://www.cve.org/CVERecord?id=CVE-2022-47519,Linux,An issue was discovered in the Linux kernel before 6.0.11. Missing validation of IEEE80211_P2P_ATTR_OPER_CHANNEL in drivers/net/wireless/microchip/wilc1000/cfg80211.c in the WILC1000 wireless driver can trigger an out-of-bounds write when parsing the channel list attribute from Wi-Fi management frames.,Semantic - Improper input validation,OOB access,TRUE,TRUE,Length validation. Simialr to CVE-2022-47521,
CVE-2022-47518,https://www.cve.org/CVERecord?id=CVE-2022-47518,Linux,An issue was discovered in the Linux kernel before 6.0.11. Missing validation of the number of channels in drivers/net/wireless/microchip/wilc1000/cfg80211.c in the WILC1000 wireless driver can trigger a heap-based buffer overflow when copying the list of operating channels from Wi-Fi management frames.,Semantic - Improper input validation,OOB access,TRUE,TRUE,"memset arguments can cause OOB write, 
RDS will panic. ",
CVE-2022-45919,https://www.cve.org/CVERecord?id=CVE-2022-45919,Linux,"An issue was discovered in the Linux kernel through 6.0.10. In drivers/media/dvb-core/dvb_ca_en50221.c, a use-after-free can occur is there is a disconnect after an open, because of the lack of a wait_event.",Race condition - TOUTOC,Use after free,TRUE,TRUE,"The bug is UAF, which after rust rewrite, it must
be fixed with mutex. P is not required, because rust will not allow race condition. ",
CVE-2022-45888,https://www.cve.org/CVERecord?id=CVE-2022-45888,Linux,An issue was discovered in the Linux kernel through 6.0.9. drivers/char/xillybus/xillyusb.c has a race condition and use-after-free during physical removal of a USB device.,Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,"UAF, should be fixed by mutex",
CVE-2022-45886,https://www.cve.org/CVERecord?id=CVE-2022-45886,Linux,An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvb_net.c has a .disconnect versus dvb_device_open race condition that leads to a use-after-free.,Race condition - TOUTOC,Use after free,TRUE,TRUE,"
below are similar to above protocal violation where it is some race condition bug. It is completely implementation dependent, but as long as developers follows correctly given carefully reasoned abstractions, such as mutex, they should easily be able to rewrite those driver code without any race conditions. ",
CVE-2022-45885,https://www.cve.org/CVERecord?id=CVE-2022-45885,Linux,An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvb_frontend.c has a race condition that can cause a use-after-free when a device is disconnected.,Race condition - TOUTOC,Use after free,TRUE,TRUE,"UAF, race, fixed by rust mutex. equivalent rust Program won't compile ",
CVE-2022-45884,https://www.cve.org/CVERecord?id=CVE-2022-45884,Linux,"An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvbdev.c has a use-after-free, related to dvb_register_device dynamically allocating fops.",Race condition - TOUTOC,Use after free,TRUE,TRUE,"UAF, race, fixed by rust mutex. equivalent rust Program won't compile ",
CVE-2022-44034,https://www.cve.org/CVERecord?id=CVE-2022-44034,Linux,"An issue was discovered in the Linux kernel through 6.0.6. drivers/char/pcmcia/scr24x_cs.c has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling open(), aka a race condition between scr24x_open() and scr24x_remove().",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,"UAF, race, fixed by rust mutex and alwaysRefernece trait ",
CVE-2022-44033,https://www.cve.org/CVERecord?id=CVE-2022-44033,Linux,"An issue was discovered in the Linux kernel through 6.0.6. drivers/char/pcmcia/cm4040_cs.c has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling open(), aka a race condition between cm4040_open() and reader_detach().",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,"UAF, race, can be fixed by rust mutex.  ",
CVE-2022-44032,https://www.cve.org/CVERecord?id=CVE-2022-44032,Linux,"An issue was discovered in the Linux kernel through 6.0.6. drivers/char/pcmcia/cm4000_cs.c has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling open(), aka a race condition between cmm_open() and cm4000_detach().",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,"UAF, race, fixed by rust mutex. equivalent rust Program won't compile ",
CVE-2022-43750,https://www.cve.org/CVERecord?id=CVE-2022-43750,Linux,drivers/usb/mon/mon_bin.c in usbmon in the Linux kernel before 5.19.15 and 6.x before 6.0.1 allows a user-space client to corrupt the monitor's internal memory.,Semantic - Logic error,Explicit exception/panic,FALSE,FALSE,"Broken by design. If you allow Userspace to write to some memory (be it rust or C), then this is going to happen. Rust won't magically solve this.",
CVE-2022-41850,https://www.cve.org/CVERecord?id=CVE-2022-41850,Linux,roccat_report_event in drivers/hid/hid-roccat.c in the Linux kernel through 5.19.12 has a race condition and resultant use-after-free in certain situations where a report is received while copying a report->value is in progress.,Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,"kernel was able to kfree from a thread, when another thread was copying the data to userspace using copy_to_user
If the mutubality rules were followed, then this won't happen.
Can this be applied to all the HW race condition bugs?",
CVE-2022-41849,https://www.cve.org/CVERecord?id=CVE-2022-41849,Linux,"drivers/video/fbdev/smscufx.c in the Linux kernel through 5.19.12 has a race condition and resultant use-after-free if a physically proximate attacker removes a USB device while calling open(), aka a race condition between ufx_ops_open and ufx_usb_disconnect.",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,"UAF, race, fixed by rust mutex. equivalent rust Program won't compile ",
CVE-2022-41848,https://www.cve.org/CVERecord?id=CVE-2022-41848,Linux,"drivers/char/pcmcia/synclink_cs.c in the Linux kernel through 5.19.12 has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling ioctl, aka a race condition between mgslpc_ioctl and mgslpc_detach.",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,"UAF, race, fixed by rust mutex. equivalent rust Program won't compile ",
CVE-2022-41218,https://www.cve.org/CVERecord?id=CVE-2022-41218,Linux,"In drivers/media/dvb-core/dmxdev.c in the Linux kernel through 5.19.10, there is a use-after-free caused by refcount races, affecting dvb_demux_open and dvb_dmxdev_release.",Race condition - TOUTOC,Use after free,TRUE,TRUE,"UAF, race, fixed by rust mutex. equivalent rust Program won't compile ",
CVE-2022-40768,https://www.cve.org/CVERecord?id=CVE-2022-40768,Linux,drivers/scsi/stex.c in the Linux kernel through 5.19.9 allows local users to obtain sensitive information from kernel memory because stex_queuecommand_lck lacks a memset for the PASSTHRU_CMD case.,Language - Improper memory initialization,Uninitialized memory access,FALSE,TRUE,All value in safe rust be intilized.,
CVE-2022-40307,https://www.cve.org/CVERecord?id=CVE-2022-40307,Linux,An issue was discovered in the Linux kernel through 5.19.8. drivers/firmware/efi/capsule-loader.c has a race condition with a resultant use-after-free.,Race condition - TOUTOC,Use after free,TRUE,TRUE,UAF,
CVE-2022-38457,https://www.cve.org/CVERecord?id=CVE-2022-38457,Linux,,Language - Lifetime violation,Use after free,TRUE,TRUE,Only vague details are available and there is no upstream fix,
CVE-2022-38096,https://www.cve.org/CVERecord?id=CVE-2022-38096,Linux,"A NULL pointer dereference vulnerability was found in vmwgfx driver in drivers/gpu/vmxgfx/vmxgfx_execbuf.c in GPU component of Linux kernel with device file '/dev/dri/renderD128 (or Dxxx)'. This flaw allows a local attacker with a user account on the system to gain privilege, causing a denial of service(DoS).",Language - Improper memory initialization,Invalid pointer dereference,TRUE,#N/A,"Only vague details are available and there is no upstream fix. if the CVE exist, it seem to be a null_ptr deref.",
CVE-2022-36402,https://www.cve.org/CVERecord?id=CVE-2022-36402,Linux,"An integer overflow vulnerability was found in vmwgfx driver in drivers/gpu/vmxgfx/vmxgfx_execbuf.c in GPU component of Linux kernel with device file '/dev/dri/renderD128 (or Dxxx)'. This flaw allows a local attacker with a user account on the system to gain privilege, causing a denial of service(DoS).",Language - Integer overflow,OOB access,TRUE,#N/A,"No fix available upstream. But in general if the index is improperly validated, rust would give a runtime assertion/panic. Have to understand more on how panics are handled in the kernel.",
CVE-2022-36280,https://www.cve.org/CVERecord?id=CVE-2022-36280,Linux,"An out-of-bounds(OOB) memory access vulnerability was found in vmwgfx driver in drivers/gpu/vmxgfx/vmxgfx_kms.c in GPU component in the Linux kernel with device file '/dev/dri/renderD128 (or Dxxx)'. This flaw allows a local attacker with a user account on the system to gain privilege, causing a denial of service(DoS).",Semantic - Improper input validation,OOB access,TRUE,TRUE,Enum type check failed to validate lower bound. RFL enforces integer check during runtime,
CVE-2022-34495,https://www.cve.org/CVERecord?id=CVE-2022-34495,Linux,rpmsg_probe in drivers/rpmsg/virtio_rpmsg_bus.c in the Linux kernel before 5.18.4 has a double free.,Language - Lifetime violation,Double free,FALSE,TRUE,"Possible double free, rust ownership model prevent sharing mutable references.However the correct implementation ",
CVE-2022-34494,https://www.cve.org/CVERecord?id=CVE-2022-34494,Linux,rpmsg_virtio_add_ctrl_dev in drivers/rpmsg/virtio_rpmsg_bus.c in the Linux kernel before 5.18.4 has a double free.,Language - Lifetime violation,Double free,FALSE,TRUE,"Possible double free, rust ownership model prevent sharing mutable references ",
CVE-2022-33981,https://www.cve.org/CVERecord?id=CVE-2022-33981,Linux,"drivers/block/floppy.c in the Linux kernel before 5.17.6 is vulnerable to a denial of service, because of a concurrency use-after-free flaw after deallocating raw_cmd in the raw_cmd_ioctl function.",Race condition - TOUTOC,Use after free,TRUE,TRUE,"If the interface is designed correctly, this should be prevented, provided this is not triggered by manipulating the physical hardware.",
CVE-2022-29156,https://www.cve.org/CVERecord?id=CVE-2022-29156,Linux,drivers/infiniband/ulp/rtrs/rtrs-clt.c in the Linux kernel before 5.16.12 has a double free related to rtrs_clt_dev_release.,Language - Lifetime violation,Double free,FALSE,TRUE,The free path has to follow a specific protocol and accurate Ref counting to know when this can be freed.,
CVE-2022-28390,https://www.cve.org/CVERecord?id=CVE-2022-28390,Linux,ems_usb_start_xmit in drivers/net/can/usb/ems_usb.c in the Linux kernel through 5.17.1 has a double free.,Language - Lifetime violation,Double free,FALSE,TRUE,The free path has to follow a specific protocol and accurate Ref counting to know when this can be freed.,
CVE-2022-28389,https://www.cve.org/CVERecord?id=CVE-2022-28389,Linux,mcba_usb_start_xmit in drivers/net/can/usb/mcba_usb.c in the Linux kernel through 5.17.1 has a double free.,Language - Lifetime violation,Double free,FALSE,TRUE,The free path has to follow a specific protocol and accurate Ref counting to know when this can be freed.,
CVE-2022-28388,https://www.cve.org/CVERecord?id=CVE-2022-28388,Linux,usb_8dev_start_xmit in drivers/net/can/usb/usb_8dev.c in the Linux kernel through 5.17.1 has a double free.,Language - Lifetime violation,Double free,FALSE,TRUE,The free path has to follow a specific protocol and accurate Ref counting to know when this can be freed.,
CVE-2022-27950,https://www.cve.org/CVERecord?id=CVE-2022-27950,Linux,"In drivers/hid/hid-elo.c in the Linux kernel before 5.16.11, a memory leak exists for a certain hid_parse error condition.",Language - Lifetime violation,Resource leak,FALSE,TRUE,"RFL has Aref spport which cane be adopted, ",
CVE-2022-27223,https://www.cve.org/CVERecord?id=CVE-2022-27223,Linux,"In drivers/usb/gadget/udc/udc-xilinx.c in the Linux kernel before 5.16.12, the endpoint index is not validated and might be manipulated by the host for out-of-array access.",Semantic - Improper input validation,OOB access,TRUE,TRUE,Improper index validation,
CVE-2022-26966,https://www.cve.org/CVERecord?id=CVE-2022-26966,Linux,An issue was discovered in the Linux kernel before 5.16.12. drivers/net/usb/sr9700.c allows attackers to obtain sensitive information from heap memory via crafted frame lengths from a device.,Semantic - Improper input validation,OOB access,TRUE,TRUE,Improper length validation,
CVE-2022-26878,https://www.cve.org/CVERecord?id=CVE-2022-26878,Linux,drivers/bluetooth/virtio_bt.c in the Linux kernel before 5.16.3 has a memory leak (socket buffers have memory allocated but not freed).,Language - Lifetime violation,Resource leak,FALSE,TRUE,"Missing kfree in free path, won't be catched by compiler. 
But correct implementation of the drop over givem data structure can prevent incorrect cleanup ",
CVE-2022-26490,https://www.cve.org/CVERecord?id=CVE-2022-26490,Linux,st21nfca_connectivity_event_received in drivers/nfc/st21nfca/se.c in the Linux kernel through 5.16.12 has EVT_TRANSACTION buffer overflows because of untrusted length parameters.,Semantic - Improper input validation,OOB access,TRUE,TRUE,Improper length validation,
CVE-2022-25375,https://www.cve.org/CVERecord?id=CVE-2022-25375,Linux,An issue was discovered in drivers/usb/gadget/function/rndis.c in the Linux kernel before 5.16.10. The RNDIS USB gadget lacks validation of the size of the RNDIS_MSG_SET command. Attackers can obtain sensitive information from kernel memory.,Semantic - Improper input validation,OOB access,TRUE,TRUE,Improper length validation,
CVE-2022-25258,https://www.cve.org/CVERecord?id=CVE-2022-25258,Linux,An issue was discovered in drivers/usb/gadget/composite.c in the Linux kernel before 5.16.10. The USB Gadget subsystem lacks certain validation of interface OS descriptor requests (ones with a large array index and ones associated with NULL function pointer retrieval). Memory corruption might occur.,Semantic - Improper input validation,OOB access,TRUE,TRUE,Improper index validation,
CVE-2022-24959,https://www.cve.org/CVERecord?id=CVE-2022-24959,Linux,An issue was discovered in the Linux kernel before 5.16.5. There is a memory leak in yam_siocdevprivate in drivers/net/hamradio/yam.c.,Language - Lifetime violation,Resource leak,FALSE,TRUE,"This is memory leak caused by incorrect conditional checking, more related to high level design/logic error, Rust can't prevent this",
CVE-2022-24958,https://www.cve.org/CVERecord?id=CVE-2022-24958,Linux,drivers/usb/gadget/legacy/inode.c in the Linux kernel through 5.16.8 mishandles dev->buf release.,Language - Lifetime violation,Use after free,TRUE,TRUE,"The correct will require careful software pattern rewrite over gadgetfs_driver, it would required carefully reasoning about resource deallocation if a member method fails. It is doable, but non-trival",
CVE-2022-3636,https://www.cve.org/CVERecord?id=CVE-2022-3636,Linux,"A vulnerability, which was classified as critical, was found in Linux Kernel. This affects the function __mtk_ppe_check_skb of the file drivers/net/ethernet/mediatek/mtk_ppe.c of the component Ethernet Handler. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-211935.",Semantic - Logic error,Use after free,TRUE,TRUE,"Programmer still need to know which function to call, arguably correct RFL abstraction can prevent this by wrapping over correct bindgen function, but still require expertise. ",
CVE-2022-3635,https://www.cve.org/CVERecord?id=CVE-2022-3635,Linux,"A vulnerability, which was classified as critical, has been found in Linux Kernel. Affected by this issue is the function tst_timer of the file drivers/atm/idt77252.c of the component IPsec. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. VDB-211934 is the identifier assigned to this vulnerability.",Race condition - TOUTOC,Use after free,TRUE,TRUE,"del_timer_sync, non trival reasoning required",
CVE-2022-3624,https://www.cve.org/CVERecord?id=CVE-2022-3624,Linux,A vulnerability was found in Linux Kernel and classified as problematic. Affected by this issue is the function rlb_arp_xmit of the file drivers/net/bonding/bond_alb.c of the component IPsec. The manipulation leads to memory leak. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211928.,Language - Lifetime violation,Resource leak,FALSE,TRUE,Aref will help here,
CVE-2022-3594,https://www.cve.org/CVERecord?id=CVE-2022-3594,Linux,A vulnerability was found in Linux Kernel. It has been declared as problematic. Affected by this vulnerability is the function intr_callback of the file drivers/net/usb/r8152.c of the component BPF. The manipulation leads to logging of excessive data. The attack can be launched remotely. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-211363.,Semantic - Improper input validation,Failure to release CPU,FALSE,FALSE,"printk in a path is not ratelimited and can be remotely triggered.

What category",
CVE-2022-3577,https://www.cve.org/CVERecord?id=CVE-2022-3577,Linux,"An out-of-bounds memory write flaw was found in the Linux kernels Kid-friendly Wired Controller driver. This flaw allows a local user to crash or potentially escalate their privileges on the system. It is in bigben_probe of drivers/hid/hid-bigbenff.c. The reason is incorrect assumption - bigben devices all have inputs. However, malicious devices can break this assumption, leaking to out-of-bound write.",Language - Lifetime violation,Resource leak,FALSE,TRUE,"Fails to release the allocated resource, impl drop over corresponding data structure",
CVE-2022-3565,https://www.cve.org/CVERecord?id=CVE-2022-3565,Linux,"A vulnerability, which was classified as critical, has been found in Linux Kernel. Affected by this issue is the function del_timer of the file drivers/isdn/mISDN/l1oip_core.c of the component Bluetooth. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211088.",Race condition - TOUTOC,Use after free,TRUE,TRUE,"del timer sync, non-trival reasoning required",
CVE-2022-3545,https://www.cve.org/CVERecord?id=CVE-2022-3545,Linux,A vulnerability has been found in Linux Kernel and classified as critical. Affected by this vulnerability is the function area_cache_get of the file drivers/net/ethernet/netronome/nfp/nfpcore/nfp_cppcore.c of the component IPsec. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier VDB-211045 was assigned to this vulnerability.,Language - Lifetime violation,Use after free,TRUE,TRUE,"Rust will prevent UAF, but non-trival knowledge about the software still required to fix the bug",
CVE-2022-3541,https://www.cve.org/CVERecord?id=CVE-2022-3541,Linux,A vulnerability classified as critical has been found in Linux Kernel. This affects the function spl2sw_nvmem_get_mac_address of the file drivers/net/ethernet/sunplus/spl2sw_driver.c of the component BPF. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier VDB-211041 was assigned to this vulnerability.,Language - Lifetime violation,Use after free,TRUE,TRUE,Classic reuse,
CVE-2022-3526,https://www.cve.org/CVERecord?id=CVE-2022-3526,Linux,A vulnerability classified as problematic was found in Linux Kernel. This vulnerability affects the function macvlan_handle_frame of the file drivers/net/macvlan.c of the component skb. The manipulation leads to memory leak. The attack can be initiated remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211024.,Language - Lifetime violation,Resource leak,FALSE,TRUE,Fails to free the memory on release path. impl drop over corresponding data structure (skb),
CVE-2022-3115,https://www.cve.org/CVERecord?id=CVE-2022-3115,Linux,An issue was discovered in the Linux kernel through 5.16-rc6. malidp_crtc_reset in drivers/gpu/drm/arm/malidp_crtc.c lacks check of the return value of kzalloc() and will cause the null pointer dereference.,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,Fails to check return value of kzalloc,
CVE-2022-3114,https://www.cve.org/CVERecord?id=CVE-2022-3114,Linux,An issue was discovered in the Linux kernel through 5.16-rc6. imx_register_uart_clocks in drivers/clk/imx/clk.c lacks check of the return value of kcalloc() and will cause the null pointer dereference.,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,Fails to check return value of kzalloc,
CVE-2022-3113,https://www.cve.org/CVERecord?id=CVE-2022-3113,Linux,An issue was discovered in the Linux kernel through 5.16-rc6. mtk_vcodec_fw_vpu_init in drivers/media/platform/mtk-vcodec/mtk_vcodec_fw_vpu.c lacks check of the return value of devm_kzalloc() and will cause the null pointer dereference.,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,Fails to check return value of kzalloc,
CVE-2022-3112,https://www.cve.org/CVERecord?id=CVE-2022-3112,Linux,An issue was discovered in the Linux kernel through 5.16-rc6. amvdec_set_canvases in drivers/staging/media/meson/vdec/vdec_helpers.c lacks check of the return value of kzalloc() and will cause the null pointer dereference.,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,Fails to check return value of kzalloc,
CVE-2022-3111,https://www.cve.org/CVERecord?id=CVE-2022-3111,Linux,"An issue was discovered in the Linux kernel through 5.16-rc6. free_charger_irq() in drivers/power/supply/wm8350_power.c lacks free of WM8350_IRQ_CHG_FAST_RDY, which is registered in wm8350_init_charger().",Language - Lifetime violation,Resource leak,FALSE,TRUE,"Fails to free the IRQ/memory on release path.

Correct RFL implementation of the drop required. ",
CVE-2022-3110,https://www.cve.org/CVERecord?id=CVE-2022-3110,Linux,An issue was discovered in the Linux kernel through 5.16-rc6. _rtw_init_xmit_priv in drivers/staging/r8188eu/core/rtw_xmit.c lacks check of the return value of rtw_alloc_hwxmits() and will cause the null pointer dereference.,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,"Fails to free the memory on release path.
Driver is removed from tree: https://lore.kernel.org/linux-staging/92a9442a-cece-4179-fbdc-3c9188da073e@redhat.com/",
CVE-2022-3108,https://www.cve.org/CVERecord?id=CVE-2022-3108,Linux,An issue was discovered in the Linux kernel through 5.16-rc6. kfd_parse_subtype_iolink in drivers/gpu/drm/amd/amdkfd/kfd_crat.c lacks check of the return value of kmemdup().,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,"Fails to check return value of memory allocation, this can be fixed by simply implement memory allocation method with result type,s othe programer must check the result (unwrap).",
CVE-2022-3107,https://www.cve.org/CVERecord?id=CVE-2022-3107,Linux,An issue was discovered in the Linux kernel through 5.16-rc6. netvsc_get_ethtool_stats in drivers/net/hyperv/netvsc_drv.c lacks check of the return value of kvmalloc_array() and will cause the null pointer dereference.,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,Fails to check return value of kzalloc,
CVE-2022-3106,https://www.cve.org/CVERecord?id=CVE-2022-3106,Linux,An issue was discovered in the Linux kernel through 5.16-rc6. ef100_update_stats in drivers/net/ethernet/sfc/ef100_nic.c lacks check of the return value of kmalloc().,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,Fails to check return value of kzalloc,
CVE-2022-3105,https://www.cve.org/CVERecord?id=CVE-2022-3105,Linux,An issue was discovered in the Linux kernel through 5.16-rc6. uapi_finalize in drivers/infiniband/core/uverbs_uapi.c lacks check of kmalloc_array().,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,Fails to check return value of kzalloc,
CVE-2022-3104,https://www.cve.org/CVERecord?id=CVE-2022-3104,Linux,An issue was discovered in the Linux kernel through 5.16-rc6. lkdtm_ARRAY_BOUNDS in drivers/misc/lkdtm/bugs.c lacks check of the return value of kmalloc() and will cause the null pointer dereference.,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,Fails to check return value of kzalloc,
CVE-2022-3078,https://www.cve.org/CVERecord?id=CVE-2022-3078,Linux,An issue was discovered in the Linux kernel through 5.16-rc6. There is a lack of check after calling vzalloc() and lack of free after allocation in drivers/media/test-drivers/vidtv/vidtv_s302m.c.,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,Fails to check return value of kzalloc. ,
CVE-2022-2380,https://www.cve.org/CVERecord?id=CVE-2022-2380,Linux,The Linux kernel was found vulnerable out of bounds memory access in the drivers/video/fbdev/sm712fb.c:smtcfb_read() function. The vulnerability could result in local attackers being able to crash the kernel.,Semantic - Improper input validation,OOB access,TRUE,TRUE,Fails to validate the length and the endianness properly,
CVE-2022-2308,https://www.cve.org/CVERecord?id=CVE-2022-2308,Linux,"A flaw was found in vDPA with VDUSE backend. There are currently no checks in VDUSE kernel driver to ensure the size of the device config space is in line with the features advertised by the VDUSE userspace application. In case of a mismatch, Virtio drivers config read helpers do not initialize the memory indirectly passed to vduse_vdpa_get_config() returning uninitialized memory from the stack. This could cause undefined behavior or data leaks in Virtio drivers.",Language - Improper memory initialization,Uninitialized memory access,FALSE,TRUE,"safe rust requires the value initilization, however this story is different for foreign objects (from kernel) ",
CVE-2022-1734,https://www.cve.org/CVERecord?id=CVE-2022-1734,Linux,A flaw in Linux Kernel found in nfcmrvl_nci_unregister_dev() in drivers/nfc/nfcmrvl/main.c can lead to use after free both read or write when non synchronized between cleanup routine and firmware download routine.,Race condition - TOUTOC,Use after free,TRUE,TRUE,"Race condition can cause early clean up, which leads to UAF scenario",
CVE-2022-1651,https://www.cve.org/CVERecord?id=CVE-2022-1651,Linux,"A memory leak flaw was found in the Linux kernel in acrn_dev_ioctl in the drivers/virt/acrn/hsm.c function in how the ACRN Device Model emulates virtual NICs in VM. This flaw allows a local privileged attacker to leak unauthorized kernel information, causing a denial of service.",Language - Lifetime violation,Use after free,TRUE,TRUE,Fails to free the memory on error path. Implement drop trait for vm_param and cpu_reg,
CVE-2022-1280,https://www.cve.org/CVERecord?id=CVE-2022-1280,Linux,A use-after-free vulnerability was found in drm_lease_held in drivers/gpu/drm/drm_lease.c in the Linux kernel due to a race problem. This flaw allows a local user privilege attacker to cause a denial of service (DoS) or a kernel information leak.,Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,Non-trival knowledge and rewrite needed,
CVE-2022-1198,https://www.cve.org/CVERecord?id=CVE-2022-1198,Linux,A use-after-free vulnerabilitity was discovered in drivers/net/hamradio/6pack.c of linux that allows an attacker to crash linux kernel by simulating ax25 device using 6pack driver from user space.,Race condition - TOUTOC,Use after free,TRUE,TRUE,Protocol violation. freeing of dev happens and a concurrent thread can modify the timer from userland,
CVE-2022-1195,https://www.cve.org/CVERecord?id=CVE-2022-1195,Linux,A use-after-free vulnerability was found in the Linux kernel in drivers/net/hamradio. This flaw allows a local attacker with a user privilege to cause a denial of service (DOS) when the mkiss or sixpack device is detached and reclaim resources early.,Race condition - TOUTOC,Use after free,TRUE,TRUE,"Since it is UAF, rust compiler will likely not allow the program to compile, but correct reasoning and logic still required for programmer.",
CVE-2022-0494,https://www.cve.org/CVERecord?id=CVE-2022-0494,Linux,A kernel information leak flaw was identified in the scsi_ioctl function in drivers/scsi/scsi_ioctl.c in the Linux kernel. This flaw allows a local attacker with a special user privilege (CAP_SYS_ADMIN or CAP_SYS_RAWIO) to create issues with confidentiality.,Language - Improper memory initialization,Uninitialized memory access,FALSE,FALSE,Fail to initilize buffer memory to 0. Safe rust enforces value initliazation. ,
CVE-2022-0487,https://www.cve.org/CVERecord?id=CVE-2022-0487,Linux,"A use-after-free vulnerability was found in rtsx_usb_ms_drv_remove in drivers/memstick/host/rtsx_usb_ms.c in memstick in the Linux kernel. In this flaw, a local attacker with a user privilege may impact system Confidentiality. This flaw affects kernel versions prior to 5.14 rc1.",Race condition - TOUTOC,Use after free,TRUE,TRUE,"Two bugs in one cve, but both are UAF, which rust compiler will complain",
CVE-2021-3753,https://www.cve.org/CVERecord?id=CVE-2021-3753,Linux,In 2022 linux dataset.,Race condition - Improper usage of synchronization primitives,OOB access,TRUE,TRUE,,
CVE-2021-3744,https://www.cve.org/CVERecord?id=CVE-2021-3744,Linux,In 2022 linux dataset.,Semantic - Logic error,Resource leak,FALSE,TRUE,,
CVE-2021-44733,https://www.cve.org/CVERecord?id=CVE-2021-44733,Linux,A use-after-free exists in drivers/tee/tee_shm.c in the TEE subsystem in the Linux kernel through 5.15.11. This occurs because of a race condition in tee_shm_get_from_id during an attempt to free a shared memory object.,Language - Lifetime violation,Use after free,TRUE,TRUE,UAF happens because the resource is improperly refcounted,
CVE-2021-43976,https://www.cve.org/CVERecord?id=CVE-2021-43976,Linux,"In the Linux kernel through 5.15.2, mwifiex_usb_recv in drivers/net/wireless/marvell/mwifiex/usb.c allows an attacker (who can connect a crafted USB device) to cause a denial of service (skb_over_panic).",Protocol - Missing Protocol Steps,Explicit exception/panic,FALSE,FALSE,Improper resource handling in the free path,
CVE-2021-43975,https://www.cve.org/CVERecord?id=CVE-2021-43975,Linux,"In the Linux kernel through 5.15.2, hw_atl_utils_fw_rpc_wait in drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c allows an attacker (who can introduce a crafted device) to trigger an out-of-bounds write via a crafted length value.",Semantic - Improper input validation,OOB access,TRUE,TRUE,Improper length validation,
CVE-2021-43389,https://www.cve.org/CVERecord?id=CVE-2021-43389,Linux,An issue was discovered in the Linux kernel before 5.14.15. There is an array-index-out-of-bounds flaw in the detach_capi_ctr function in drivers/isdn/capi/kcapi.c.,Semantic - Improper input validation,OOB access,TRUE,TRUE,Improper index validation,
CVE-2021-42327,https://www.cve.org/CVERecord?id=CVE-2021-42327,Linux,dp_link_settings_write in drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c in the Linux kernel through 5.14.14 allows a heap-based buffer overflow by an attacker who can write a string to the AMD GPU display drivers debug filesystem. There are no checks on size within parse_write_buffer_into_params when it uses the size of copy_from_user to copy a userspace buffer into a 40-byte heap buffer.,Semantic - Improper input validation,OOB access,TRUE,TRUE,Improper length validation,
CVE-2021-42252,https://www.cve.org/CVERecord?id=CVE-2021-42252,Linux,"An issue was discovered in aspeed_lpc_ctrl_mmap in drivers/soc/aspeed/aspeed-lpc-ctrl.c in the Linux kernel before 5.14.6. Local attackers able to access the Aspeed LPC control interface could overwrite memory in the kernel and potentially execute privileges, aka CID-b49a0e69a7b1. This occurs because a certain comparison uses values that are not memory sizes.",Semantic - Improper input validation,OOB access,TRUE,TRUE,Improper length validation,
CVE-2021-42008,https://www.cve.org/CVERecord?id=CVE-2021-42008,Linux,The decode_data function in drivers/net/hamradio/6pack.c in the Linux kernel before 5.13.13 has a slab out-of-bounds write. Input from a process that has the CAP_NET_ADMIN capability can lead to root access.,Semantic - Improper input validation,OOB access,TRUE,TRUE,Improper length validation,
CVE-2021-38207,https://www.cve.org/CVERecord?id=CVE-2021-38207,Linux,drivers/net/ethernet/xilinx/ll_temac_main.c in the Linux kernel before 5.12.13 allows remote attackers to cause a denial of service (buffer overflow and lockup) by sending heavy network traffic for about ten minutes.,Semantic - Logic error,OOB access,TRUE,TRUE,"Logic error, because input validation was present, but there was a one off error, ie, checking for X instead of (X+1)",
CVE-2021-38205,https://www.cve.org/CVERecord?id=CVE-2021-38205,Linux,"drivers/net/ethernet/xilinx/xilinx_emaclite.c in the Linux kernel before 5.13.3 makes it easier for attackers to defeat an ASLR protection mechanism because it prints a kernel pointer (i.e., the real IOMEM pointer).",Semantic - Security and permissions,Access control violation,FALSE,FALSE,Didn't print kernel pointer with %p which could lead to security vulnerability. SInce %p sanitizes pointer based on restrictions,
CVE-2021-38204,https://www.cve.org/CVERecord?id=CVE-2021-38204,Linux,drivers/usb/host/max3421-hcd.c in the Linux kernel before 5.13.6 allows physically proximate attackers to cause a denial of service (use-after-free and panic) by removing a MAX-3421 USB device in certain situations.,Language - Lifetime violation,Use after free,TRUE,FALSE,Original spec of driver saved potentially stale pointers.,
CVE-2021-38160,https://www.cve.org/CVERecord?id=CVE-2021-38160,Linux,"** DISPUTED ** In drivers/char/virtio_console.c in the Linux kernel before 5.13.4, data corruption or loss can be triggered by an untrusted device that supplies a buf->len value exceeding the buffer size. NOTE: the vendor indicates that the cited data corruption is not a vulnerability in any existing use case; the length validation was added solely for robustness in the face of anomalous host OS behavior.",Semantic - Improper input validation,OOB access,TRUE,TRUE,Missing check to make sure length is not larger than buffer,
CVE-2021-37159,https://www.cve.org/CVERecord?id=CVE-2021-37159,Linux,"hso_free_net_device in drivers/net/usb/hso.c in the Linux kernel through 5.13.4 calls unregister_netdev without checking for the NETREG_REGISTERED state, leading to a use-after-free and a double free.",Protocol - Missing Protocol Steps,Double free,FALSE,FALSE,"Interesting bit from the netdev developer: https://www.spinics.net/lists/linux-usb/msg202309.html
* And a lot of driver still uses the internal state: https://livegrep.com/search/linux?q=state+%3D%3D+NETREG_REGISTERED%29+path%3Adrivers%2Fnet%2Fethernet%2F&fold_case=auto&regex=false&context=true",
CVE-2021-31916,https://www.cve.org/CVERecord?id=CVE-2021-31916,Linux,An out-of-bounds (OOB) memory write flaw was found in list_devices in drivers/md/dm-ioctl.c in the Multi-device driver module in the Linux kernel before 5.12. A bound check failure allows an attacker with special user (CAP_SYS_ADMIN) privilege to gain access to out-of-bounds memory leading to a system crash or a leak of internal kernel information. The highest threat from this vulnerability is to system availability.,Semantic - Improper input validation,OOB access,TRUE,TRUE,Improper input data validation from userland,
CVE-2021-30002,https://www.cve.org/CVERecord?id=CVE-2021-30002,Linux,"An issue was discovered in the Linux kernel before 5.11.3 when a webcam device exists. video_usercopy in drivers/media/v4l2-core/v4l2-ioctl.c has a memory leak for large arguments, aka CID-fb18802a338b.",Semantic - Logic error,Resource leak,FALSE,TRUE,"Classic memory leak, two allocations were done and assigned to the same variable. If this is not a void pointer and a typed struct, rust would automatically free the memory when it goes out of scope. Check with a prototype.",
CVE-2021-29266,https://www.cve.org/CVERecord?id=CVE-2021-29266,Linux,"An issue was discovered in the Linux kernel before 5.11.9. drivers/vhost/vdpa.c has a use-after-free because v->config_ctx has an invalid value upon re-opening a character device, aka CID-f6bbf0010ba0.",Language - Lifetime violation,Use after free,TRUE,TRUE,Refcount is decremented but the pointer is not set to null causing the next call to cause UAF and underflow the refcount,
CVE-2021-29265,https://www.cve.org/CVERecord?id=CVE-2021-29265,Linux,"An issue was discovered in the Linux kernel before 5.11.7. usbip_sockfd_store in drivers/usb/usbip/stub_dev.c allows attackers to cause a denial of service (GPF) because the stub-up sequence has race conditions during an update of the local and shared status, aka CID-9380afd6df70.",Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,From commit: Doesn't handle kthread_create() error and saves invalid ptr in localstate that drives rx and tx threads.,
CVE-2021-29264,https://www.cve.org/CVERecord?id=CVE-2021-29264,Linux,"An issue was discovered in the Linux kernel through 5.11.10. drivers/net/ethernet/freescale/gianfar.c in the Freescale Gianfar Ethernet driver allows attackers to cause a system crash because a negative fragment size is calculated in situations involving an rx queue overrun when jumbo packets are used and NAPI is enabled, aka CID-d8861bab48b6.",Semantic - Improper input validation,OOB access,TRUE,FALSE,The length of the skb and buffer is not handled properly in a corner case. This is a integer overflow/underflow,
CVE-2021-28972,https://www.cve.org/CVERecord?id=CVE-2021-28972,Linux,"In drivers/pci/hotplug/rpadlpar_sysfs.c in the Linux kernel through 5.11.8, the RPA PCI Hotplug driver has a user-tolerable buffer overflow when writing a new device name to the driver from userspace, allowing userspace to write data to the kernel stack frame directly. This occurs because add_slot_store and remove_slot_store mishandle drc_name '\0' termination, aka CID-cc7a0bb058b8.",Language - Null byte termination,OOB access,TRUE,TRUE,"Improper handling of buffer as a string. It has to be type checked, but such rust type conversions are unsafe. maybe we can type check and return an error?",
CVE-2021-28660,https://www.cve.org/CVERecord?id=CVE-2021-28660,Linux,"rtw_wx_set_scan in drivers/staging/rtl8188eu/os_dep/ioctl_linux.c in the Linux kernel through 5.11.6 allows writing beyond the end of the ->ssid[] array. NOTE: from the perspective of kernel.org releases, CVE IDs are not normally used for drivers/staging/* (unfinished work); however, system integrators may have situations in which a drivers/staging issue is relevant to their own customer base.",Semantic - Improper input validation,OOB access,TRUE,TRUE,Improper length check,
CVE-2021-28375,https://www.cve.org/CVERecord?id=CVE-2021-28375,Linux,"An issue was discovered in the Linux kernel through 5.11.6. fastrpc_internal_invoke in drivers/misc/fastrpc.c does not prevent user applications from sending kernel RPC messages, aka CID-20c40794eb85. This is a related issue to CVE-2019-2308.",Semantic - Security and permissions,Access control violation,FALSE,FALSE,Improper authorization check. User is allowed to send kernel RPCs,
CVE-2021-27364,https://www.cve.org/CVERecord?id=CVE-2021-27364,Linux,An issue was discovered in the Linux kernel through 5.11.3. drivers/scsi/scsi_transport_iscsi.c is adversely affected by the ability of an unprivileged user to craft Netlink messages.,Semantic - Security and permissions,Access control violation,FALSE,FALSE,Improper authorization check. User is allowed to modify arbitrary iSCSI sessions.,
CVE-2021-27363,https://www.cve.org/CVERecord?id=CVE-2021-27363,Linux,"An issue was discovered in the Linux kernel through 5.11.3. A kernel pointer leak can be used to determine the address of the iscsi_transport structure. When an iSCSI transport is registered with the iSCSI subsystem, the transport's handle is available to unprivileged users via the sysfs file system, at /sys/class/iscsi_transport/$TRANSPORT_NAME/handle. When read, the show_transport_handle function (in drivers/scsi/scsi_transport_iscsi.c) is called, which leaks the handle. This handle is actually the pointer to an iscsi_transport struct in the kernel module's global variables.",Semantic - Security and permissions,Access control violation,FALSE,FALSE,Improper authorization check. User is allowed to modify arbitrary iSCSI sessions.,
CVE-2021-26932,https://www.cve.org/CVERecord?id=CVE-2021-26932,Linux,"An issue was discovered in the Linux kernel 3.2 through 5.10.16, as used by Xen. Grant mapping operations often occur in batch hypercalls, where a number of operations are done in a single hypercall, the success or failure of each one is reported to the backend driver, and the backend driver then loops over the results, performing follow-up actions based on the success or failure of each operation. Unfortunately, when running in PV mode, the Linux backend drivers mishandle this: Some errors are ignored, effectively implying their success from the success of related batch elements. In other cases, errors resulting from one batch element lead to further batch elements not being inspected, and hence successful ones to not be possible to properly unmap upon error recovery. Only systems with Linux backends running in PV mode are vulnerable. Linux backends run in HVM / PVH modes are not vulnerable. This affects arch/*/xen/p2m.c and drivers/xen/gntdev.c.",Semantic - Security and permissions,High level spec violation,FALSE,FALSE,Mishandling of errors: Functional problem: The loop doesn't account for all failures and reports bogus results to the upper layers. ,
CVE-2021-26931,https://www.cve.org/CVERecord?id=CVE-2021-26931,Linux,"An issue was discovered in the Linux kernel 2.6.39 through 5.10.16, as used in Xen. Block, net, and SCSI backends consider certain errors a plain bug, deliberately causing a kernel crash. For errors potentially being at least under the influence of guests (such as out of memory conditions), it isn't correct to assume a plain bug. Memory allocations potentially causing such crashes occur only when Linux is running in PV mode, though. This affects drivers/block/xen-blkback/blkback.c and drivers/xen/xen-scsiback.c.",Semantic - Spec error,Explicit exception/panic,FALSE,FALSE,Logical error: Improper error handling,
CVE-2021-26930,https://www.cve.org/CVERecord?id=CVE-2021-26930,Linux,"An issue was discovered in the Linux kernel 3.11 through 5.10.16, as used by Xen. To service requests to the PV backend, the driver maps grant references provided by the frontend. In this process, errors may be encountered. In one case, an error encountered earlier might be discarded by later processing, resulting in the caller assuming successful mapping, and hence subsequent operations trying to access space that wasn't mapped. In another case, internal state would be insufficiently updated, preventing safe recovery from the error. This affects drivers/block/xen-blkback/blkback.c.",Semantic - Logic error,Uninitialized memory access,FALSE,FALSE,Logical error: Improper error handling,
CVE-2021-20292,https://www.cve.org/CVERecord?id=CVE-2021-20292,Linux,"There is a flaw reported in the Linux kernel in versions before 5.9 in drivers/gpu/drm/nouveau/nouveau_sgdma.c in nouveau_sgdma_create_ttm in Nouveau DRM subsystem. The issue results from the lack of validating the existence of an object prior to performing operations on the object. An attacker with a local account with a root privilege, can leverage this vulnerability to escalate privileges and execute code in the context of the kernel.",Semantic - Improper input validation,Double free,FALSE,TRUE,Issue appears to be logic error allows potential double free. Per the bugzilla thread: https://seclists.org/oss-sec/2020/q3/127,
CVE-2021-3348,https://www.cve.org/CVERecord?id=CVE-2021-3348,Linux,"nbd_add_socket in drivers/block/nbd.c in the Linux kernel through 5.10.12 has an ndb_queue_rq use-after-free that could be triggered by local attackers (with access to the nbd device) via an I/O request at a certain point during device setup, aka CID-b98e762e3d71.",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,"Race case with krealloc() could cause UAF, patch simply freezes queue instead of locking.",
CVE-2020-36385,https://www.cve.org/CVERecord?id=CVE-2020-36385,Linux,In 2021 linux dataset.,Race condition - Improper usage of synchronization primitives,Use after free,TRUE,#N/A,"Wrong locking logic, allowed UAF",
CVE-2020-36158,https://www.cve.org/CVERecord?id=CVE-2020-36158,Linux,In 2021 linux dataset.,Semantic - Improper input validation,OOB access,TRUE,#N/A,"Didn't check length during memcpy, buffer overflow",
CVE-2020-28374,https://www.cve.org/CVERecord?id=CVE-2020-28374,Linux,In 2021 linux dataset.,Semantic - Security and permissions,Access control violation,FALSE,#N/A,"Used global device list instead of session restricted LUN list, allowing potential unauthorized device access.",
CVE-2020-14304,https://www.cve.org/CVERecord?id=CVE-2020-14304,Linux,"A memory disclosure flaw was found in the Linux kernel's ethernet drivers, in the way it read data from the EEPROM of the device. This flaw allows a local user to read uninitialized values from the kernel memory. The highest threat from this vulnerability is to confidentiality.",Language - Improper memory initialization,Uninitialized memory access,FALSE,#N/A,Marked as TBD in RFL dataset.,
CVE-2020-12888,https://www.cve.org/CVERecord?id=CVE-2020-12888,Linux,The VFIO PCI driver in the Linux kernel through 5.6.13 mishandles attempts to access disabled memory space.,Semantic - Security and permissions,Access control violation,FALSE,#N/A,Marked as TBD in RFL dataset.,
CVE-2020-8648,https://www.cve.org/CVERecord?id=CVE-2020-8648,Linux,There is a use-after-free vulnerability in the Linux kernel through 5.5.2 in the n_tty_receive_buf_common function in drivers/tty/n_tty.c.,Race condition - Improper usage of synchronization primitives,Use after free,TRUE,#N/A,Marked as TBD in RFL dataset.,
CVE-2020-12652,https://www.cve.org/CVERecord?id=CVE-2020-12652,Linux,"The __mptctl_ioctl function in drivers/message/fusion/mptctl.c in the Linux kernel before 5.4.14 allows local users to hold an incorrect lock during the ioctl operation and trigger a race condition, i.e., a ""double fetch"" vulnerability, aka CID-28d76df18f0a. NOTE: the vendor states ""The security impact of this bug is not as bad as it could have been because these operations are all privileged and root already has enormous destructive power.""",Race condition - TOUTOC,Explicit exception/panic,FALSE,FALSE,Improper locking logic which depends on changing memory state can create race condition. Red hat classified this as a DOS.,
CVE-2020-8649,https://www.cve.org/CVERecord?id=CVE-2020-8649,Linux,There is a use-after-free vulnerability in the Linux kernel through 5.5.2 in the vgacon_invert_region function in drivers/video/console/vgacon.c.,Semantic - Logic error,OOB access,TRUE,FALSE,Bound checking logic was missing.,
CVE-2020-29661,https://www.cve.org/CVERecord?id=CVE-2020-29661,Linux,"A locking issue was discovered in the tty subsystem of the Linux kernel through 5.9.13. drivers/tty/tty_jobctrl.c allows a use-after-free attack against TIOCSPGRP, aka CID-54ffccbf053b.",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,Locking wrong object can lead to improper refrence counting and UAF vulnerabilities.,
CVE-2020-29660,https://www.cve.org/CVERecord?id=CVE-2020-29660,Linux,"A locking inconsistency issue was discovered in the tty subsystem of the Linux kernel through 5.9.13. drivers/tty/tty_io.c and drivers/tty/tty_jobctrl.c may allow a read-after-free attack against TIOCGSID, aka CID-c8bcd9c5be24.",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,Non-uniform locking mechanisms in code allow for UAF vulnerabilities.,
CVE-2020-28974,https://www.cve.org/CVERecord?id=CVE-2020-28974,Linux,"A slab-out-of-bounds read in fbcon in the Linux kernel before 5.9.7 could be used by local attackers to read privileged information or potentially crash the kernel, aka CID-3c4e0dff2095. This occurs because KD_FONT_OP_COPY in drivers/tty/vt/vt.c can be used for manipulations such as font height.",Semantic - Logic error,OOB access,TRUE,TRUE,Incorrect logic for managing lengths of two buffers can lead to OOB issues.,
CVE-2020-28941,https://www.cve.org/CVERecord?id=CVE-2020-28941,Linux,"An issue was discovered in drivers/accessibility/speakup/spk_ttyio.c in the Linux kernel through 5.9.9. Local attackers on systems with the speakup driver could cause a local denial of service attack, aka CID-d41227544427. This occurs because of an invalid free when the line discipline is used more than once.",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,Missing lock caused a race that could lead to UAF.,
CVE-2020-27675,https://www.cve.org/CVERecord?id=CVE-2020-27675,Linux,"An issue was discovered in the Linux kernel through 5.9.1, as used with Xen through 4.14.x. drivers/xen/events/events_base.c allows event-channel removal during the event-handling loop (a race condition). This can cause a use-after-free or NULL pointer dereference, as demonstrated by a dom0 crash via events for an in-reconfiguration paravirtualized device, aka CID-073d0552ead5.",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,Improper locking while freeing an object allowed UAF since event loop still active.,
CVE-2020-25284,https://www.cve.org/CVERecord?id=CVE-2020-25284,Linux,"The rbd block device driver in drivers/block/rbd.c in the Linux kernel through 5.8.9 used incomplete permission checking for access to rbd devices, which could be leveraged by local attackers to map or unmap rbd block devices, aka CID-f44d04e696fe.",Semantic - Security and permissions,Access control violation,FALSE,FALSE,Was missing permissions check.,
CVE-2020-16166,https://www.cve.org/CVERecord?id=CVE-2020-16166,Linux,"The Linux kernel through 5.7.11 allows remote attackers to make observations that help to obtain sensitive information about the internal state of the network RNG, aka CID-f227e3ec3b5c. This is related to drivers/char/random.c and kernel/time/timer.c.",Semantic - Logic error,Access control violation,FALSE,FALSE,"*To ensure logical ""correctness"" of random.h the patch added more re-seeding to the system's state. This is an effort to prevent the RNG's internal state being guessed.",
CVE-2020-15780,https://www.cve.org/CVERecord?id=CVE-2020-15780,Linux,"An issue was discovered in drivers/acpi/acpi_configfs.c in the Linux kernel before 5.7.7. Injection of malicious ACPI tables via configfs could be used by attackers to bypass lockdown and secure boot restrictions, aka CID-75b0cea7bf30.",Semantic - Security and permissions,Access control violation,FALSE,FALSE,Missing lockdown verification before loading ACPI tables allowed privilege bypass.,
CVE-2020-15437,https://www.cve.org/CVERecord?id=CVE-2020-15437,Linux,The Linux kernel before version 5.8 is vulnerable to a NULL pointer dereference in drivers/tty/serial/8250/8250_core.c:serial8250_isa_init_ports() that allows local users to cause a denial of service by using the p->serial_in pointer which uninitialized.,Race condition - TOUTOC,Explicit exception/panic,FALSE,TRUE,"Error in initialization protocol leads to uninitialized pointers on certain architectures, causing kernel panic.",
CVE-2020-15393,https://www.cve.org/CVERecord?id=CVE-2020-15393,Linux,"In the Linux kernel 4.4 through 5.7.6, usbtest_disconnect in drivers/usb/misc/usbtest.c has a memory leak, aka CID-28ebeb8db770.",Language - Lifetime violation,Resource leak,FALSE,TRUE,Memory leak,
CVE-2020-14416,https://www.cve.org/CVERecord?id=CVE-2020-14416,Linux,"In the Linux kernel before 5.4.16, a race condition in tty->disc_data handling in the slip and slcan line discipline could lead to a use-after-free, aka CID-0ace17d56824. This affects drivers/net/slip/slip.c and drivers/net/can/slcan.c.",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,Lack of proper synchronization allowed UAF,
CVE-2020-13974,https://www.cve.org/CVERecord?id=CVE-2020-13974,Linux,"An issue was discovered in the Linux kernel 4.4 through 5.7.1. drivers/tty/vt/keyboard.c has an integer overflow if k_ascii is called several times in a row, aka CID-b86dab054059. NOTE: Members in the community argue that the integer overflow does not lead to a security issue in this case.",Language - Integer overflow,High level spec violation,FALSE,TRUE,"*Int overflow leads to undefined behavior in k_ascii, but doesn't seem to cause any immediate symptoms. Red hat classified this as possible DOS.",
CVE-2020-13143,https://www.cve.org/CVERecord?id=CVE-2020-13143,Linux,"gadget_dev_desc_UDC_store in drivers/usb/gadget/configfs.c in the Linux kernel 3.16 through 5.6.13 relies on kstrdup without considering the possibility of an internal '\0' value, which allows attackers to trigger an out-of-bounds read, aka CID-15753588bcd4.",Semantic - Improper input validation,OOB access,TRUE,TRUE,Malformed input could trigger buffer overflow due to the copy of a buffer being smaller than original.,
CVE-2020-12771,https://www.cve.org/CVERecord?id=CVE-2020-12771,Linux,An issue was discovered in the Linux kernel through 5.6.11. btree_gc_coalesce in drivers/md/bcache/btree.c has a deadlock if a coalescing operation fails.,Race condition - Improper usage of synchronization primitives,Failure to release CPU,FALSE,TRUE,*Possible deadlock due to missing unlock on failure path.,
CVE-2020-12769,https://www.cve.org/CVERecord?id=CVE-2020-12769,Linux,"An issue was discovered in the Linux kernel before 5.4.17. drivers/spi/spi-dw.c allows attackers to cause a panic via concurrent calls to dw_spi_irq and dw_spi_transfer_one, aka CID-19b61392c5a8.",Race condition - Improper usage of synchronization primitives,Invalid pointer dereference,TRUE,TRUE,"Race condition allowed for panic due to null ptr deref, ie race between data not being initialized, fix is to add lock.",
CVE-2020-12654,https://www.cve.org/CVERecord?id=CVE-2020-12654,Linux,"An issue was found in Linux kernel before 5.5.4. mwifiex_ret_wmm_get_status() in drivers/net/wireless/marvell/mwifiex/wmm.c allows a remote AP to trigger a heap-based buffer overflow because of an incorrect memcpy, aka CID-3a9b153c5591.",Semantic - Improper input validation,OOB access,TRUE,TRUE,Didn't verify size before memcpy,
CVE-2020-12653,https://www.cve.org/CVERecord?id=CVE-2020-12653,Linux,"An issue was found in Linux kernel before 5.5.4. The mwifiex_cmd_append_vsie_tlv() function in drivers/net/wireless/marvell/mwifiex/scan.c allows local users to gain privileges or cause a denial of service because of an incorrect memcpy and buffer overflow, aka CID-b70261a288ea.",Semantic - Improper input validation,OOB access,TRUE,TRUE,Didn't verify size before memcpy,
CVE-2020-12465,https://www.cve.org/CVERecord?id=CVE-2020-12465,Linux,"An array overflow was discovered in mt76_add_fragment in drivers/net/wireless/mediatek/mt76/dma.c in the Linux kernel before 5.5.10, aka CID-b102f0c522cf. An oversized packet with too many rx fragments can corrupt memory of adjacent pages.",Semantic - Improper input validation,OOB access,TRUE,TRUE,Missing check allowed writing more data than the buffer could hold.,
CVE-2020-12464,https://www.cve.org/CVERecord?id=CVE-2020-12464,Linux,"usb_sg_cancel in drivers/usb/core/message.c in the Linux kernel before 5.6.8 has a use-after-free because a transfer occurs without a reference, aka CID-056ad39ee925.",Language - Lifetime violation,Use after free,TRUE,TRUE,Didn't update refrence count in cancelling operations. Cornucopia could mitigate UAF.,
CVE-2020-11668,https://www.cve.org/CVERecord?id=CVE-2020-11668,Linux,"In the Linux kernel before 5.6.1, drivers/media/usb/gspca/xirlink_cit.c (aka the Xirlink camera USB driver) mishandles invalid descriptors, aka CID-a246b4d54770.",Semantic - Improper input validation,Invalid pointer dereference,TRUE,TRUE,Null pointer dereference due to not checking for corner case which introduces null values.,
CVE-2020-11609,https://www.cve.org/CVERecord?id=CVE-2020-11609,Linux,"An issue was discovered in the stv06xx subsystem in the Linux kernel before 5.6.1. drivers/media/usb/gspca/stv06xx/stv06xx.c and drivers/media/usb/gspca/stv06xx/stv06xx_pb0100.c mishandle invalid descriptors, as demonstrated by a NULL pointer dereference, aka CID-485b06aadb93.",Semantic - Improper input validation,Invalid pointer dereference,TRUE,TRUE,Null pointer derefrence due to not checking for corner case which introduces null values.,
CVE-2020-11608,https://www.cve.org/CVERecord?id=CVE-2020-11608,Linux,"An issue was discovered in the Linux kernel before 5.6.1. drivers/media/usb/gspca/ov519.c allows NULL pointer dereferences in ov511_mode_init_regs and ov518_mode_init_regs when there are zero endpoints, aka CID-998912346c0d.",Semantic - Improper input validation,Invalid pointer dereference,TRUE,TRUE,Null pointer dereference due to not checking for corner case which introduces null values.,
CVE-2020-11494,https://www.cve.org/CVERecord?id=CVE-2020-11494,Linux,"An issue was discovered in slc_bump in drivers/net/can/slcan.c in the Linux kernel 3.16 through 5.6.2. It allows attackers to read uninitialized can_frame data, potentially containing sensitive information from kernel stack memory, if the configuration lacks CONFIG_INIT_STACK_ALL, aka CID-b9258a2cece4.",Language - Improper memory initialization,Uninitialized memory access,FALSE,TRUE,"Memory isn't zeroed, leading to pontential memory disclosure.",
CVE-2020-10942,https://www.cve.org/CVERecord?id=CVE-2020-10942,Linux,"In the Linux kernel before 5.5.8, get_raw_socket in drivers/vhost/net.c lacks validation of an sk_family field, which might allow attackers to trigger kernel stack corruption via crafted system calls.",Semantic - Spec error,OOB access,TRUE,FALSE,"Incorrect use of getname(), which may write beyond the bounds of the allocated buffer.",
CVE-2020-9383,https://www.cve.org/CVERecord?id=CVE-2020-9383,Linux,"An issue was discovered in the Linux kernel 3.16 through 5.5.6. set_fdc in drivers/block/floppy.c leads to a wait_til_ready out-of-bounds read because the FDC index is not checked for errors before assigning it, aka CID-2e90ca68b0d2.",Semantic - Improper input validation,OOB access,TRUE,TRUE,Insufficient validation of input leads to OOB issues. ,
CVE-2020-8647,https://www.cve.org/CVERecord?id=CVE-2020-8647,Linux,There is a use-after-free vulnerability in the Linux kernel through 5.5.2 in the vc_do_resize function in drivers/tty/vt/vt.c.,Semantic - Logic error,Use after free,TRUE,TRUE,"Logic error during cleanup, dependent data structure free'd first. Meaning it could possibly be accessed during rest of clean up. The patch reordered the free to occur last. Cornucopia could help stop UAF.",
CVE-2020-7053,https://www.cve.org/CVERecord?id=CVE-2020-7053,Linux,"In the Linux kernel 4.14 longterm through 4.14.165 and 4.19 longterm through 4.19.96 (and 5.x before 5.2), there is a use-after-free (write) in the i915_ppgtt_close function in drivers/gpu/drm/i915/i915_gem_gtt.c, aka CID-7dc40713618c. This is related to i915_gem_context_destroy_ioctl in drivers/gpu/drm/i915/i915_gem_context.c.",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,Improper locking leads to UAF,
CVE-2025-0662,https://www.cve.org/CVERecord?id=CVE-2025-0662,FreeBSD,"In some cases, the ktrace facility will log the contents of kernel structures to userspace.  In one such case, ktrace dumps a variable-sized sockaddr to userspace.  There, the full sockaddr is copied, even when it is shorter than the full size.  This can result in up to 14 uninitialized bytes of kernel memory being copied out to userspace.  It is possible for an unprivileged userspace program to leak 14 bytes of a kernel heap allocation to userspace.",Language -  Polymorphism,OOB access,TRUE,#N/A,"object size confusion, polymorphism",
CVE-2025-0373,https://www.cve.org/CVERecord?id=CVE-2025-0373,FreeBSD,"On 64-bit systems, the implementation of VOP_VPTOFH() in the cd9660, tarfs and ext2fs filesystems overflows the destination FID buffer by 4 bytes, a stack buffer overflow.  A NFS server that exports a cd9660, tarfs, or ext2fs file system can be made to panic by mounting and accessing the export with an NFS client.  Further exploitation (e.g., bypassing file permission checking or remote kernel code execution) is potentially possible, though this has not been demonstrated.  In particular, release kernels are compiled with stack protection enabled, and some instances of the overflow are caught by this mechanism, causing a panic.",Language -  Polymorphism,OOB access,TRUE,#N/A,"object size confusion,  Kernel user interaction",
CVE-2024-8178,https://www.cve.org/CVERecord?id=CVE-2024-8178,FreeBSD,"The ctl_write_buffer and ctl_read_buffer functions allocated memory to be returned to userspace, without initializing it.  Malicious software running in a guest VM that exposes virtio_scsi can exploit the vulnerabilities to achieve code execution on the host in the bhyve userspace process, which typically runs as root.  Note that bhyve runs in a Capsicum sandbox, so malicious code is constrained by the capabilities available to the bhyve process.  A malicious iSCSI initiator could achieve remote code execution on the iSCSI target host.",Language - Improper memory initialization,Uninitialized memory access,FALSE,#N/A,Insufficient return value sanitization,
CVE-2024-6760,https://www.cve.org/CVERecord?id=CVE-2024-6760,FreeBSD,"A logic bug in the code which disables kernel tracing for setuid programs meant that tracing was not disabled when it should have, allowing unprivileged users to trace and inspect the behavior of setuid programs.  The bug may be used by an unprivileged user to read the contents of files to which they would not otherwise have access, such as the local password database.",Semantic - Logic error,Access control violation,FALSE,#N/A,security violation (user privileage),
CVE-2024-6759,https://www.cve.org/CVERecord?id=CVE-2024-6759,FreeBSD,"When mounting a remote filesystem using NFS, the kernel did not sanitize remotely provided filenames for the path separator character, ""/"".  This allows readdir(3) and related functions to return filesystem entries with names containing additional path components.  The lack of validation described above gives rise to a confused deputy problem.  For example, a program copying files from an NFS mount could be tricked into copying from outside the intended source directory, and/or to a location outside the intended destination directory.",Semantic - Improper input validation,Access control violation,FALSE,#N/A,Insufficient user input validation,
CVE-2024-6640,https://www.cve.org/CVERecord?id=CVE-2024-6640,FreeBSD,"In ICMPv6 Neighbor Discovery (ND), the ID is always 0.  When pf is configured to allow ND and block incoming Echo Requests, a crafted Echo Request packet after a Neighbor Solicitation (NS) can trigger an Echo Reply.  The packet has to come from the same host as the NS and have a zero as identifier to match the state created by the Neighbor Discovery and allow replies to be generated.  ICMPv6 packets with identifier value of zero bypass firewall rules written on the assumption that the incoming packets are going to create a state in the state table.",Semantic - Spec error,Access control violation,FALSE,#N/A,"due to spec error (missing id field for ICMPv6), pueusdo id is used and is 0. ",
CVE-2024-45288,https://www.cve.org/CVERecord?id=CVE-2024-45288,FreeBSD,A missing null-termination character in the last element of an nvlist array string can lead to writing outside the allocated buffer.,Language - Null byte termination,OOB access,TRUE,#N/A,String null byte check,
CVE-2024-45287,https://www.cve.org/CVERecord?id=CVE-2024-45287,FreeBSD,"A malicious value of size in a structure of packed libnv can cause an integer overflow, leading to the allocation of a smaller buffer than required for the parsed data.",Language - Integer overflow,OOB access,TRUE,#N/A,Integer overflow,
CVE-2024-45063,https://www.cve.org/CVERecord?id=CVE-2024-45063,FreeBSD,"The function ctl_write_buffer incorrectly set a flag which resulted in a kernel Use-After-Free when a command finished processing.  Malicious software running in a guest VM that exposes virtio_scsi can exploit the vulnerabilities to achieve code execution on the host in the bhyve userspace process, which typically runs as root.  Note that bhyve runs in a Capsicum sandbox, so malicious code is constrained by the capabilities available to the bhyve process.  A malicious iSCSI initiator could achieve remote code execution on the iSCSI target host.",Semantic - Logic error,Use after free,TRUE,#N/A,kernel-user interaction violation (backwards),
CVE-2024-43110,https://www.cve.org/CVERecord?id=CVE-2024-43110,FreeBSD,"The ctl_request_sense function could expose up to three bytes of the kernel heap to userspace.  Malicious software running in a guest VM that exposes virtio_scsi can exploit the vulnerabilities to achieve code execution on the host in the bhyve userspace process, which typically runs as root.  Note that bhyve runs in a Capsicum sandbox, so malicious code is constrained by the capabilities available to the bhyve process.  A malicious iSCSI initiator could achieve remote code execution on the iSCSI target host.",Semantic - Improper input validation,OOB access,TRUE,#N/A,object size confusion,
CVE-2024-43102,https://www.cve.org/CVERecord?id=CVE-2024-43102,FreeBSD,"Concurrent removals of certain anonymous shared memory mappings by using the UMTX_SHM_DESTROY sub-request of UMTX_OP_SHM can lead to decreasing the reference count of the object representing the mapping too many times, causing it to be freed too early.  A malicious code exercizing the UMTX_SHM_DESTROY sub-request in parallel can panic the kernel or enable further Use-After-Free attacks, potentially including code execution or Capsicum sandbox escape.",Race condition - TOUTOC,Use after free,TRUE,#N/A,race condition,
CVE-2024-42416,https://www.cve.org/CVERecord?id=CVE-2024-42416,FreeBSD,"The ctl_report_supported_opcodes function did not sufficiently validate a field provided by userspace, allowing an arbitrary write to a limited amount of kernel help memory.  Malicious software running in a guest VM that exposes virtio_scsi can exploit the vulnerabilities to achieve code execution on the host in the bhyve userspace process, which typically runs as root.  Note that bhyve runs in a Capsicum sandbox, so malicious code is constrained by the capabilities available to the bhyve process.  A malicious iSCSI initiator could achieve remote code execution on the iSCSI target host.",Semantic - Improper input validation,OOB access,TRUE,#N/A,oob access that can lead to limited arbtriray write primitive ,
CVE-2024-39281,https://www.cve.org/CVERecord?id=CVE-2024-39281,FreeBSD,The command ctl_persistent_reserve_out allows the caller to specify an arbitrary size which will be passed to the kernel's memory allocator.,Semantic - Improper input validation,High level spec violation,FALSE,#N/A,Insufficient user input validation,
CVE-2024-25941,https://www.cve.org/CVERecord?id=CVE-2024-25941,FreeBSD,"The jail(2) system call has not limited a visiblity of allocated TTYs (the kern.ttys sysctl).  This gives rise to an information leak about processes outside the current jail.  Attacker can get information about TTYs allocated on the host or in other jails.  Effectively, the information printed by ""pstat -t"" may be leaked.",Semantic - Security and permissions,Access control violation,FALSE,#N/A,Insufficient privileage protection,
CVE-2023-6660,https://www.cve.org/CVERecord?id=CVE-2023-6660,FreeBSD,"When a program running on an affected system appends data to a file via an NFS client mount, the bug can cause the NFS client to fail to copy in the data to be written but proceed as though the copy operation had succeeded.  This means that the data to be written is instead replaced with whatever data had been in the packet buffer previously.  Thus, an unprivileged user with access to an affected system may abuse the bug to trigger disclosure of sensitive information.  In particular, the leak is limited to data previously stored in mbufs, which are used for network transmission and reception, and for certain types of inter-process communication.  The bug can also be triggered unintentionally by system applications, in which case the data written by the application to an NFS mount may be corrupted.  Corrupted data is written over the network to the NFS server, and thus also susceptible to being snooped by other hosts on the network.  Note that the bug exists only in the NFS client; the version and implementation of the server has no effect on whether a given system is affected by the problem.",Semantic - Missing return value check,Uninitialized memory access,FALSE,#N/A,Missing return value check,
CVE-2023-6534,https://www.cve.org/CVERecord?id=CVE-2023-6534,FreeBSD,"14-RELEASE-p2, FreeBSD 13.2-RELEASE before 13.2-RELEASE-p7 and FreeBSD 12.4-RELEASE before 12.4-RELEASE-p9, the pf(4) packet filter incorrectly validates TCP sequence numbers. This could allow a malicious actor to execute a denial-of-service attack against hosts behind the firewall.",Semantic - Logic error,Access control violation,FALSE,#N/A,security violation (packet),
CVE-2023-5370,https://www.cve.org/CVERecord?id=CVE-2023-5370,FreeBSD,On CPU 0 the check for the SMCCC workaround is called before SMCCC support has been initialized. This resulted in no speculative execution workarounds being installed on CPU 0.,Semantic - Logic error,Access control violation,FALSE,#N/A,Protocol - Missing Protocol Steps,
CVE-2023-5369,https://www.cve.org/CVERecord?id=CVE-2023-5369,FreeBSD,"Before correction, thecopy_file_rangesystem call checked only for the CAP_READ and CAP_WRITE capabilities on the input and output file descriptors, respectively.  Using an offset is logically equivalent to seeking, and the system call must additionally require the CAP_SEEK capability.  This incorrect privilege check enabled sandboxed processes with only read or write but no seek capability on a file descriptor to read data from or write data to an arbitrary location within the file corresponding to that file descriptor.",Semantic - Security and permissions,Access control violation,FALSE,#N/A,Missing return value check,
CVE-2023-5368,https://www.cve.org/CVERecord?id=CVE-2023-5368,FreeBSD,"On an msdosfs filesystem, the 'truncate' or 'ftruncate' system calls under certain circumstances populate the additional space in the file with unallocated data from the underlying disk device, rather than zero bytes.  This may permit a user with write access to files on a msdosfs filesystem to read unintended data (e.g. from a previously deleted file).",Semantic - Spec error,Uninitialized memory access,FALSE,#N/A,Missing specs to hanlde special cases,
CVE-2023-4809,https://www.cve.org/CVERecord?id=CVE-2023-4809,FreeBSD,"In pf packet processing with a 'scrub fragment reassemble' rule, a packet containing multiple IPv6 fragment headers would be reassembled, and then immediately processed.  That is, a packet with multiple fragment extension headers would not be recognized as the correct ultimate payload. Instead a packet with multiple IPv6 fragment headers would unexpectedly be interpreted as a fragmented packet, rather than as whatever the real payload is.     As a result, IPv6 fragments may bypass pf firewall rules written on the assumption all fragments have been reassembled and, as a result, be forwarded or processed by the host.",Semantic - Logic error,Access control violation,FALSE,#N/A,security violation (packet),
CVE-2023-3107,https://www.cve.org/CVERecord?id=CVE-2023-3107,FreeBSD,"A set of carefully crafted ipv6 packets can trigger an integer overflow in the calculation of a fragment reassembled packet's payload length field. This allows an attacker to trigger a kernel panic, resulting in a denial of service.",Language - Integer overflow,High level spec violation,FALSE,#N/A,Integer overflow,
CVE-2022-47522,https://www.cve.org/CVERecord?id=CVE-2022-47522,FreeBSD,,Semantic - Spec error,Access control violation,FALSE,#N/A,Missing specs to hanlde special cases,
CVE-2022-23091,https://www.cve.org/CVERecord?id=CVE-2022-23091,FreeBSD,"A particular case of memory sharing is mishandled in the virtual memory system.  This is very similar to SA-21:08.vm, but with a different root cause.  An unprivileged local user process can maintain a mapping of a page after it is freed, allowing that process to read private data belonging to other processes or the kernel.",Semantic - Spec error,Access control violation,FALSE,#N/A,security violation (mmap),
CVE-2022-23090,https://www.cve.org/CVERecord?id=CVE-2022-23090,FreeBSD,"The aio_aqueue function, used by the lio_listio system call, fails to release a reference to a credential in an error case.  An attacker may cause the reference count to overflow, leading to a use after free (UAF).",Semantic - Logic error,OOB access,TRUE,#N/A,"reference count
integer overflow",
CVE-2022-23089,https://www.cve.org/CVERecord?id=CVE-2022-23089,FreeBSD,"When dumping core and saving process information, proc_getargv() might return an sbuf which have a sbuf_len() of 0 or -1, which is not properly handled.  An out-of-bound read can happen when user constructs a specially crafted ps_string, which in turn can cause the kernel to crash.",Language - Integer overflow,OOB access,TRUE,#N/A,integer size check,
CVE-2022-23088,https://www.cve.org/CVERecord?id=CVE-2022-23088,FreeBSD,"The 802.11 beacon handling routine failed to validate the length of an IEEE 802.11s Mesh ID before copying it to a heap-allocated buffer.  While a FreeBSD Wi-Fi client is in scanning mode (i.e., not associated with a SSID) a malicious beacon frame may overwrite kernel memory, leading to remote code execution.",Semantic - Improper input validation,OOB access,TRUE,#N/A,Missing input validation check,
CVE-2022-23086,https://www.cve.org/CVERecord?id=CVE-2022-23086,FreeBSD,"Handlers for *_CFG_PAGE read / write ioctls in the mpr, mps, and mpt drivers allocated a buffer of a caller-specified size, but copied to it a fixed size header.  Other heap content would be overwritten if the specified size was too small.  Users with access to the mpr, mps or mpt device node may overwrite heap data, potentially resulting in privilege escalation.  Note that the device node is only accessible to root and members of the operator group.",Language -  Polymorphism,OOB access,TRUE,#N/A,object size confusion,
CVE-2022-23085,https://www.cve.org/CVERecord?id=CVE-2022-23085,FreeBSD,"A user-provided integer option was passed to nmreq_copyin() without checking if it would overflow.  This insufficient bounds checking could lead to kernel memory corruption.  On systems configured to include netmap in their devfs_ruleset, a privileged process running in a jail can affect the host environment.",Language - Integer overflow,OOB access,TRUE,#N/A,Integer overflow,
CVE-2022-23084,https://www.cve.org/CVERecord?id=CVE-2022-23084,FreeBSD,"The total size of the user-provided nmreq to nmreq_copyin() was first computed and then trusted during the copyin.  This time-of-check to time-of-use bug could lead to kernel memory corruption.  On systems configured to include netmap in their devfs_ruleset, a privileged process running in a jail can affect the host environment.",Race condition - TOUTOC,OOB access,TRUE,#N/A,Race condition ,
CVE-2021-29632,https://www.cve.org/CVERecord?id=CVE-2021-29632,FreeBSD,"-9352de39c3dc, 12.2-STABLE before r370674, 13.0-RELEASE before p6, and 12.2-RELEASE before p12, certain conditions involving use of the highlight buffer while text is scrolling on the console, console data may overwrite data structures associated with the system console or other kernel memory.",Semantic - Improper input validation,OOB access,TRUE,#N/A,Insufficient index input validation ,
CVE-2021-29628,https://www.cve.org/CVERecord?id=CVE-2021-29628,FreeBSD,"-876ffe28796c, 12.2-STABLE before r369857, 13.0-RELEASE before p1, and 12.2-RELEASE before p7, a system call triggering a fault could cause SMAP protections to be disabled for the duration of the system call. This weakness could be combined with other kernel bugs to craft an exploit.",Semantic - Logic error,Access control violation,FALSE,#N/A,Missing protocal step,
CVE-2021-29627,https://www.cve.org/CVERecord?id=CVE-2021-29627,FreeBSD,listening socket accept filters implementing the accf_create callback incorrectly freed a process supplied argument string. Additional operations on the socket can lead to a double free or use after free.,Semantic - Logic error,Use after free,TRUE,#N/A,free too early,
CVE-2021-29626,https://www.cve.org/CVERecord?id=CVE-2021-29626,FreeBSD,"copy-on-write logic failed to invalidate shared memory page mappings between multiple processes allowing an unprivileged process to maintain a mapping after it is freed, allowing the process to read private data belonging to other processes or the kernel.",Semantic - Logic error,Access control violation,FALSE,#N/A,security violation (mmap),
CVE-2020-7469,https://www.cve.org/CVERecord?id=CVE-2020-7469,FreeBSD,"the handler for a routing option caches a pointer into the packet buffer holding the ICMPv6 message. However, when processing subsequent options the packet buffer may be freed, rendering the cached pointer invalid. The network stack may later dereference the pointer, potentially triggering a use-after-free.",Language - Lifetime violation,Use after free,TRUE,#N/A,Variable lifetime violation,
CVE-2020-7467,https://www.cve.org/CVERecord?id=CVE-2020-7467,FreeBSD,"a number of AMD virtualization instructions operate on host physical addresses, are not subject to nested page table translation, and guest use of these instructions was not trapped.",Semantic - Security and permissions,Access control violation,FALSE,#N/A,security violation (vm inst),
CVE-2020-7464,https://www.cve.org/CVERecord?id=CVE-2020-7464,FreeBSD,"a programming error in the ure(4) device driver caused some Realtek USB Ethernet interfaces to incorrectly report packets with more than 2048 bytes in a single USB transfer as having a length of only 2048 bytes. An adversary can exploit this to cause the driver to misinterpret part of the payload of a large packet as a separate packet, and thereby inject packets across security boundaries such as VLANs.",Semantic - Logic error,Access control violation,FALSE,#N/A,security violation (packet),
CVE-2020-7463,https://www.cve.org/CVERecord?id=CVE-2020-7463,FreeBSD,improper handling in the kernel causes a use-after-free bug by sending large user messages from multiple threads on the same SCTP socket. The use-after-free situation may result in unintended kernel behaviour including a kernel panic.,Race condition - TOUTOC,Use after free,TRUE,#N/A,race condition,
CVE-2020-7462,https://www.cve.org/CVERecord?id=CVE-2020-7462,FreeBSD,improper mbuf handling in the kernel causes a use-after-free bug by sending IPv6 Hop-by-Hop options over the loopback interface. The use-after-free situation may result in unintended kernel behaviour including a kernel panic.,Semantic - Logic error,Use after free,TRUE,#N/A,,
CVE-2020-7460,https://www.cve.org/CVERecord?id=CVE-2020-7460,FreeBSD,the sendmsg system call in the compat32 subsystem on 64-bit platforms has a time-of-check to time-of-use vulnerability allowing a mailcious userspace program to modify control message headers after they were validation.,Race condition - TOUTOC,Use after free,TRUE,#N/A,TOCTOU ( kernel copy),
CVE-2020-7459,https://www.cve.org/CVERecord?id=CVE-2020-7459,FreeBSD,missing length validation code common to mulitple USB network drivers allows a malicious USB device to write beyond the end of an allocated network packet buffer.,Semantic - Improper input validation,OOB access,TRUE,#N/A,security violation (packet) insufficient validation,
CVE-2020-7457,https://www.cve.org/CVERecord?id=CVE-2020-7457,FreeBSD,"missing synchronization in the IPV6_2292PKTOPTIONS socket option set handler contained a race condition allowing a malicious application to modify memory after being freed, possibly resulting in code execution.",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,#N/A,,
CVE-2020-7456,https://www.cve.org/CVERecord?id=CVE-2020-7456,FreeBSD,an invalid memory location may be used for HID items if the push/pop level is not restored within the processing of that HID item allowing an attacker with physical access to a USB port to be able to use a specially crafted USB device to gain kernel or user-space code execution.,Semantic - Logic error,OOB access,TRUE,#N/A,,
CVE-2020-7455,https://www.cve.org/CVERecord?id=CVE-2020-7455,FreeBSD,the FTP packet handler in libalias incorrectly calculates some packet length allowing disclosure of small amounts of kernel (for kernel NAT) or natd process space (for userspace natd).,Semantic - Improper input validation,OOB access,TRUE,#N/A,,
CVE-2020-7454,https://www.cve.org/CVERecord?id=CVE-2020-7454,FreeBSD,libalias does not properly validate packet length resulting in modules causing an out of bounds read/write condition if no checking was built into the module.,Semantic - Improper input validation,OOB access,TRUE,#N/A,,
CVE-2020-7453,https://www.cve.org/CVERecord?id=CVE-2020-7453,FreeBSD,"a missing null termination check in the jail_set configuration option ""osrelease"" may return more bytes with a subsequent jail_get system call allowing a malicious jail superuser with permission to create nested jails to read kernel memory.",Language - Null byte termination,OOB access,TRUE,#N/A,,
CVE-2020-7452,https://www.cve.org/CVERecord?id=CVE-2020-7452,FreeBSD,incorrect use of a user-controlled pointer in the epair virtual network module allowed vnet jailed privileged users to panic the host system and potentially execute arbitrary code in the kernel.,Semantic - Improper input validation,Control flow violation,FALSE,#N/A,,
CVE-2020-7451,https://www.cve.org/CVERecord?id=CVE-2020-7451,FreeBSD,a TCP SYN-ACK or challenge TCP-ACK segment over IPv6 that is transmitted or retransmitted does not properly initialize the Traffic Class field disclosing one byte of kernel memory over the network.,Language - Improper memory initialization,Uninitialized memory access,FALSE,#N/A,,
CVE-2020-25584,https://www.cve.org/CVERecord?id=CVE-2020-25584,FreeBSD,"a superuser inside a FreeBSD jail configured with the non-default allow.mount permission could cause a race condition between the lookup of "".."" and remounting a filesystem, allowing access to filesystem hierarchy outside of the jail.",Semantic - Security and permissions,Access control violation,FALSE,#N/A,,
CVE-2020-25582,https://www.cve.org/CVERecord?id=CVE-2020-25582,FreeBSD,"when a process, such as jexec(8) or killall(1), calls jail_attach(2) to enter a jail, the jailed root can attach to it using ptrace(2) before the current working directory is changed.",Semantic - Security and permissions,Access control violation,FALSE,#N/A,,
CVE-2020-25581,https://www.cve.org/CVERecord?id=CVE-2020-25581,FreeBSD,"due to a race condition in the jail_remove(2) implementation, it may fail to kill some of the processes.",Race condition - TOUTOC,High level spec violation,FALSE,#N/A,,
CVE-2020-25579,https://www.cve.org/CVERecord?id=CVE-2020-25579,FreeBSD,"msdosfs(5) was failing to zero-fill a pair of padding fields in the dirent structure, resulting in a leak of three uninitialized bytes.",Language - Improper memory initialization,Uninitialized memory access,FALSE,#N/A,,
CVE-2020-25578,https://www.cve.org/CVERecord?id=CVE-2020-25578,FreeBSD,"several file systems were not properly initializing the d_off field of the dirent structures returned by VOP_READDIR. In particular, tmpfs(5), smbfs(5), autofs(5) and mqueuefs(5) were failing to do so. As a result, eight uninitialized kernel stack bytes may be leaked to userspace by these file systems.",Language - Improper memory initialization,Uninitialized memory access,FALSE,#N/A,,
CVE-2019-5614,https://www.cve.org/CVERecord?id=CVE-2019-5614,FreeBSD,incomplete packet data validation may result in accessing out-of-bounds memory leading to a kernel panic or other unpredictable results.,Semantic - Improper input validation,OOB access,TRUE,#N/A,,
CVE-2019-5613,https://www.cve.org/CVERecord?id=CVE-2019-5613,FreeBSD,"a missing check in the ipsec packet processor allows reinjection of an old packet to be accepted by the ipsec endpoint. Depending on the higher-level protocol in use over ipsec, this could allow an action to be repeated.",Semantic - Logic error,High level spec violation,FALSE,#N/A,,
CVE-2019-5612,https://www.cve.org/CVERecord?id=CVE-2019-5612,FreeBSD,the kernel driver for /dev/midistat implements a read handler that is not thread-safe. A multi-threaded program can exploit races in the handler to copy out kernel memory outside the boundaries of midistat's data buffer.,Race condition - TOUTOC,OOB access,TRUE,#N/A,,
CVE-2019-5611,https://www.cve.org/CVERecord?id=CVE-2019-5611,FreeBSD,"a missing check in the function to arrange data in a chain of mbufs could cause data returned not to be contiguous. Extra checks in the IPv6 stack could catch the error condition and trigger a kernel panic, leading to a remote denial of service.",Semantic - Improper input validation,Explicit exception/panic,FALSE,#N/A,,
CVE-2019-5608,https://www.cve.org/CVERecord?id=CVE-2019-5608,FreeBSD,the ICMPv6 input path incorrectly handles cases where an MLDv2 listener query packet is internally fragmented across multiple mbufs. A remote attacker may be able to cause an out-of-bounds read or write that may cause the kernel to attempt to access an unmapped page and subsequently panic.,Semantic - Logic error,OOB access,TRUE,#N/A,Labeled as logic error instead of Protocol - Missing Protocol Steps because their protocol was wrong,
CVE-2019-5607,https://www.cve.org/CVERecord?id=CVE-2019-5607,FreeBSD,"rights transmitted over a domain socket did not properly release a reference on transmission error allowing a malicious user to cause the reference counter to wrap, forcing a free event. This could allow a malicious local user to gain root privileges or escape from a jail.",Language - Lifetime violation,Use after free,TRUE,#N/A,Fail to decrement refrence counter in protocol,
CVE-2019-5606,https://www.cve.org/CVERecord?id=CVE-2019-5606,FreeBSD,code which handles close of a descriptor created by posix_openpt fails to undo a signal configuration. This causes an incorrect signal to be raised leading to a write after free of kernel memory allowing a malicious user to gain root privileges or escape a jail.,Language - Lifetime violation,Use after free,TRUE,#N/A,Incorrect clean up in protocol,
CVE-2019-5605,https://www.cve.org/CVERecord?id=CVE-2019-5605,FreeBSD,"due to insufficient initialization of memory copied to userland in the freebsd32_ioctl interface, small amounts of kernel memory may be disclosed to userland processes. This may allow an attacker to leverage this information to obtain elevated privileges either directly or indirectly.",Language - Improper memory initialization,Uninitialized memory access,FALSE,#N/A,,
CVE-2019-5603,https://www.cve.org/CVERecord?id=CVE-2019-5603,FreeBSD,"system calls operating on file descriptors as part of mqueuefs did not properly release the reference allowing a malicious user to overflow the counter allowing access to files, directories, and sockets opened by processes owned by other users.",Language - Lifetime violation,Use after free,TRUE,#N/A,,
CVE-2019-5602,https://www.cve.org/CVERecord?id=CVE-2019-5602,FreeBSD,a bug in the cdrom driver allows users with read access to the cdrom device to arbitrarily overwrite kernel memory when media is present thereby allowing a malicious user in the operator group to gain root privileges.,Semantic - Logic error,Access control violation,FALSE,#N/A,,
CVE-2019-5601,https://www.cve.org/CVERecord?id=CVE-2019-5601,FreeBSD,a bug in the FFS implementation causes up to three bytes of kernel stack memory to be written to disk as uninitialized directory entry padding.,Language - Improper memory initialization,Uninitialized memory access,FALSE,#N/A,,
CVE-2019-5599,https://www.cve.org/CVERecord?id=CVE-2019-5599,FreeBSD,"a bug in the non-default RACK TCP stack can allow an attacker to cause several linked lists to grow unbounded and cause an expensive list traversal on every packet being processed, leading to resource exhaustion and a denial of service.",Semantic - Spec error,High level spec violation,FALSE,#N/A,,
CVE-2019-5598,https://www.cve.org/CVERecord?id=CVE-2019-5598,FreeBSD,a bug in pf does not check if the outer ICMP or ICMP6 packet has the same destination IP as the source IP of the inner protocol packet allowing a maliciously crafted ICMP/ICMP6 packet could bypass the packet filter rules and be passed to a host that would otherwise be unavailable.,Semantic - Security and permissions,Access control violation,FALSE,#N/A,"Labeled as Protocol - Missing Protocol Steps instead of logic bug because their algorithm isn't wrongly implementeed, their protocol just missed an edge case.",
CVE-2019-5597,https://www.cve.org/CVERecord?id=CVE-2019-5597,FreeBSD,a bug in the pf IPv6 fragment reassembly logic incorrectly uses the last extension header offset from the last received packet instead of the first packet allowing maliciously crafted IPv6 packets to cause a crash or potentially bypass the packet filter.,Semantic - Logic error,Access control violation,FALSE,#N/A,"Wrong item from queue used, so data len may be incorrect. Leading to buffer overflow errors. Also allows for policy bypass.",
CVE-2019-5596,https://www.cve.org/CVERecord?id=CVE-2019-5596,FreeBSD,a bug in the reference count implementation for UNIX domain sockets can cause a file structure to be incorrectly released potentially allowing a malicious local user to gain root privileges or escape from a jail.,Language - Lifetime violation,Use after free,TRUE,#N/A,Their protocol was missing the fd decrement,
CVE-2019-5595,https://www.cve.org/CVERecord?id=CVE-2019-5595,FreeBSD,"kernel callee-save registers are not properly sanitized before return from system calls, potentially allowing some kernel data used in the system call to be exposed.",Language - Improper memory initialization,Uninitialized memory access,FALSE,#N/A,Not directly memory related. But improper clearing of registers that could contain memory data.,
CVE-2019-15880,https://www.cve.org/CVERecord?id=CVE-2019-15880,FreeBSD,insufficient checking in the cryptodev module allocated the size of a kernel buffer based on a user-supplied length allowing an unprivileged process to trigger a kernel panic.,Semantic - Improper input validation,OOB access,TRUE,#N/A,Integer size/type check ,
CVE-2019-15879,https://www.cve.org/CVERecord?id=CVE-2019-15879,FreeBSD,"a race condition in the cryptodev module permitted a data structure in the kernel to be used after it was freed, allowing an unprivileged process can overwrite arbitrary kernel memory.",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,#N/A,"Patch added ref count, should've been in original protocol",
CVE-2019-15878,https://www.cve.org/CVERecord?id=CVE-2019-15878,FreeBSD,an unprivileged local user can trigger a use-after-free situation due to improper checking in SCTP when an application tries to update an SCTP-AUTH shared key.,Semantic - Logic error,Use after free,TRUE,#N/A,Wrong conditional logic can cause use after free,
CVE-2019-15877,https://www.cve.org/CVERecord?id=CVE-2019-15877,FreeBSD,driver specific ioctl command handlers in the ixl network driver failed to check whether the caller has sufficient privileges allowing unprivileged users to trigger updates to the device's non-volatile memory.,Semantic - Security and permissions,Access control violation,FALSE,#N/A,Protocol missed some privledge validation steps,
CVE-2019-15876,https://www.cve.org/CVERecord?id=CVE-2019-15876,FreeBSD,driver specific ioctl command handlers in the oce network driver failed to check whether the caller has sufficient privileges allowing unprivileged users to send passthrough commands to the device firmware.,Semantic - Security and permissions,Access control violation,FALSE,#N/A,Protocol missed some privledge validation steps,
CVE-2019-15875,https://www.cve.org/CVERecord?id=CVE-2019-15875,FreeBSD,"due to incorrect initialization of a stack data structure, core dump files may contain up to 20 bytes of kernel data previously stored on the stack.",Language - Improper memory initialization,Uninitialized memory access,FALSE,#N/A,Uninitialized memory access because only a subset of struct fields were initialized.,
CVE-2019-15874,https://www.cve.org/CVERecord?id=CVE-2019-15874,FreeBSD,incomplete packet data validation may result in memory access after it has been freed leading to a kernel panic or other unpredictable results.,Semantic - Improper input validation,Use after free,TRUE,#N/A,,
CVE-2018-6925,https://www.cve.org/CVERecord?id=CVE-2018-6925,FreeBSD,"due to improper maintenance of IPv6 protocol control block flags through various failure paths, an unprivileged authenticated local user may be able to cause a NULL pointer dereference causing the kernel to crash.",Protocol - Missing Protocol Steps,High level spec violation,FALSE,#N/A,"sock fail to restore some flags for protocol control struct, which lead to high level logical bug",
CVE-2018-6924,https://www.cve.org/CVERecord?id=CVE-2018-6924,FreeBSD,insufficient validation in the ELF header parser could allow a malicious ELF binary to cause a kernel crash or disclose kernel memory.,Semantic - Improper input validation,Access control violation,FALSE,#N/A,,
CVE-2018-6923,https://www.cve.org/CVERecord?id=CVE-2018-6923,FreeBSD,,Semantic - Security and permissions,High level spec violation,FALSE,#N/A,,
CVE-2018-6922,https://www.cve.org/CVERecord?id=CVE-2018-6922,FreeBSD,"One of the data structures that holds TCP segments in all versions of FreeBSD prior to 11.2-RELEASE-p1, 11.1-RELEASE-p12, and 10.4-RELEASE-p10 uses an inefficient algorithm to reassemble the data. This causes the CPU time spent on segment processing to grow linearly with the number of segments in the reassembly queue. An attacker who has the ability to send TCP traffic to a victim system can degrade the victim system's network performance and/or consume excessive CPU by exploiting the inefficiency of TCP reassembly handling, with relatively small bandwidth cost.",Semantic - Spec error,High level spec violation,FALSE,#N/A,"Slow algorithm allows for attacker to degrade victim's network/cpu performance. Patch sets arbitrary limit which can be changed, overall bad spec",
CVE-2018-6921,https://www.cve.org/CVERecord?id=CVE-2018-6921,FreeBSD,"due to insufficient initialization of memory copied to userland in the network subsystem, small amounts of kernel memory may be disclosed to userland processes. Unprivileged authenticated local users may be able to access small amounts of privileged kernel data.",Language - Improper memory initialization,Uninitialized memory access,FALSE,#N/A,,
CVE-2018-6920,https://www.cve.org/CVERecord?id=CVE-2018-6920,FreeBSD,"due to insufficient initialization of memory copied to userland in the Linux subsystem and Atheros wireless driver, small amounts of kernel memory may be disclosed to userland processes. Unprivileged authenticated local users may be able to access small amounts of privileged kernel data.",Language - Improper memory initialization,Uninitialized memory access,FALSE,#N/A,,
CVE-2018-6919,https://www.cve.org/CVERecord?id=CVE-2018-6919,FreeBSD,"due to insufficient initialization of memory copied to userland, small amounts of kernel memory may be disclosed to userland processes. Unprivileged users may be able to access small amounts privileged kernel data.",Language - Improper memory initialization,Uninitialized memory access,FALSE,#N/A,,
CVE-2018-6918,https://www.cve.org/CVERecord?id=CVE-2018-6918,FreeBSD,"the length field of the ipsec option header does not count the size of the option header itself, causing an infinite loop when the length is zero. This issue can allow a remote attacker who is able to send an arbitrary packet to cause the machine to crash.",Semantic - Loop termination,Failure to release CPU,FALSE,#N/A,Incorrect loop iteration logic can lead to infinite loop,
CVE-2018-6917,https://www.cve.org/CVERecord?id=CVE-2018-6917,FreeBSD,"insufficient validation of user-provided font parameters can result in an integer overflow, leading to the use of arbitrary kernel memory as glyph data. Unprivileged users may be able to access privileged kernel data.",Language - Integer overflow,OOB access,TRUE,#N/A,Integer overflow in font loading causes kernel memory to be interpreted as font glyphs resulting in kernel memory disclosure,
CVE-2018-6916,https://www.cve.org/CVERecord?id=CVE-2018-6916,FreeBSD,"the kernel does not properly validate IPsec packets coming from a trusted host. Additionally, a use-after-free vulnerability exists in the IPsec AH handling code. This issue could cause a system crash or other unpredictable results.",Semantic - Improper input validation,Use after free,TRUE,#N/A,"Poor spec design, an object which holds pointer to the next object can be freed before retrieving the next object, patch was to save the pointer before processing current object",
CVE-2018-17159,https://www.cve.org/CVERecord?id=CVE-2018-17159,FreeBSD,the NFS server lacks a bounds check in the READDIRPLUS NFS request. Unprivileged remote users with access to the NFS server can cause a resource exhaustion by forcing the server to allocate an arbitrarily large memory allocation.,Semantic - Improper input validation,OOB access,TRUE,#N/A,"Lack of bounds check allows a user to allocate arbitrarily amounts of memory, which can lead to resource exhaustion ",
CVE-2018-17158,https://www.cve.org/CVERecord?id=CVE-2018-17158,FreeBSD,an integer overflow error can occur when handling the client address length field in an NFSv4 request. Unprivileged remote users with access to the NFS server can crash the system by sending a specially crafted NFSv4 request.,Semantic - Logic error,Explicit exception/panic,FALSE,#N/A,"Offset of type int could be made to overflow, old code explicitly checked for negative values and issued panic. Meaning this could allow for DOS attacks. Patch adds error handling for overflow instead of panic.",
CVE-2018-17157,https://www.cve.org/CVERecord?id=CVE-2018-17157,FreeBSD,an integer overflow error when handling opcodes can cause memory corruption by sending a specially crafted NFSv4 request. Unprivileged remote users with access to the NFS server may be able to execute arbitrary code.,Semantic - Improper input validation,OOB access,TRUE,#N/A,Insufficient check when handling opcodes can cause memory corruption due to malicious user request. Unprivileged users may be able to execute arbitrary code.,
CVE-2018-17156,https://www.cve.org/CVERecord?id=CVE-2018-17156,FreeBSD,"due to incorrectly accounting for padding on 64-bit platforms, a buffer underwrite could occur when constructing an ICMP reply packet when using a non-standard value for the net.inet.icmp.quotelen sysctl.",Semantic - Logic error,OOB access,TRUE,#N/A,Wrong calculation of object size causes buffer underwrite,
CVE-2018-17155,https://www.cve.org/CVERecord?id=CVE-2018-17155,FreeBSD,"due to insufficient initialization of memory copied to userland in the getcontext and swapcontext system calls, small amounts of kernel memory may be disclosed to userland processes. Unprivileged authenticated local users may be able to access small amounts privileged kernel data.",Language - Improper memory initialization,Uninitialized memory access,FALSE,#N/A,,
CVE-2018-17154,https://www.cve.org/CVERecord?id=CVE-2018-17154,FreeBSD,"due to insufficient memory checking in the freebsd4_getfsstat system call, a NULL pointer dereference can occur. Unprivileged authenticated local users may be able to cause a denial of service.",Semantic - Missing return value check,Explicit exception/panic,FALSE,#N/A,,
CVE-2017-1088,https://www.cve.org/CVERecord?id=CVE-2017-1088,FreeBSD,"the kernel does not properly clear the memory of the kld_file_stat structure before filling the data. Since the structure filled by the kernel is allocated on the kernel stack and copied to userspace, a leak of information from the kernel stack is possible. As a result, some bytes from the kernel stack can be observed in userspace.",Language - Improper memory initialization,Uninitialized memory access,FALSE,#N/A,,
CVE-2017-1087,https://www.cve.org/CVERecord?id=CVE-2017-1087,FreeBSD,"named paths are globally scoped, meaning a process located in one jail can read and modify the content of POSIX shared memory objects created by a process in another jail or the host system. As a result, a malicious user that has access to a jailed system is able to abuse shared memory by injecting malicious content in the shared memory region. This memory region might be executed by applications trusting the shared memory, like Squid. This issue could lead to a Denial of Service or local privilege escalation.",Semantic - Security and permissions,Access control violation,FALSE,#N/A,,
CVE-2017-1086,https://www.cve.org/CVERecord?id=CVE-2017-1086,FreeBSD,"not all information in the struct ptrace_lwpinfo is relevant for the state of any thread, and the kernel does not fill the irrelevant bytes or short strings. Since the structure filled by the kernel is allocated on the kernel stack and copied to userspace, a leak of information of the kernel stack of the thread is possible from the debugger. As a result, some bytes from the kernel stack of the thread using ptrace (PT_LWPINFO) call can be observed in userspace.",Language - Improper memory initialization,Uninitialized memory access,FALSE,#N/A,,
CVE-2017-1085,https://www.cve.org/CVERecord?id=CVE-2017-1085,FreeBSD,an application which calls setrlimit() to increase RLIMIT_STACK may turn a read-only memory region below the stack into a read-write region. A specially crafted executable could be exploited to execute arbitrary code in the user context.,Semantic - Logic error,Access control violation,FALSE,#N/A,"kernel assume stack is set to LIMIT, but it is not, so now whenever user try to increase the rlimit, the new stack memory can be written",
CVE-2017-1084,https://www.cve.org/CVERecord?id=CVE-2017-1084,FreeBSD,multiple issues with the implementation of the stack guard-page reduce the protections afforded by the guard-page. This results in the possibility a poorly written process could be cause a stack overflow.,Semantic - Spec error,High level spec violation,FALSE,#N/A,,
CVE-2017-1083,https://www.cve.org/CVERecord?id=CVE-2017-1083,FreeBSD,a stack guard-page is available but is disabled by default. This results in the possibility a poorly written process could be cause a stack overflow.,Semantic - Security and permissions,Access control violation,FALSE,#N/A,,
CVE-2017-1082,https://www.cve.org/CVERecord?id=CVE-2017-1082,FreeBSD,the qsort algorithm has a deterministic recursion pattern. Feeding a pathological input to the algorithm can lead to excessive stack usage and potential overflow. Applications that use qsort to handle large data set may crash if the input follows the pathological pattern.,Semantic - Logic error,High level spec violation,FALSE,#N/A,,
CVE-2017-1081,https://www.cve.org/CVERecord?id=CVE-2017-1081,FreeBSD,"ipfilter using ""keep state"" or ""keep frags"" options can cause a kernel panic when fed specially crafted packet fragments due to incorrect memory handling.",Semantic - Logic error,Use after free,TRUE,#N/A,"wrong variable freed, variable which is used",
CVE-2012-4576,https://www.cve.org/CVERecord?id=CVE-2012-4576,FreeBSD,FreeBSD: Input Validation Flaw allows local users to gain elevated privileges,Semantic - Improper input validation,Access control violation,FALSE,#N/A,"*generally cheri, can't fix input validation errors.",
CVE-2011-2480,https://www.cve.org/CVERecord?id=CVE-2011-2480,FreeBSD,"Information Disclosure vulnerability in the 802.11 stack, as used in FreeBSD before 8.2 and NetBSD when using certain non-x86 architectures. A signedness error in the IEEE80211_IOC_CHANINFO ioctl allows a local unprivileged user to cause the kernel to copy large amounts of kernel memory back to the user, disclosing potentially sensitive information.",Language - Integer overflow,OOB access,TRUE,#N/A,"*A signedness error allows large kernel disclosure, cheri wouldn't allow to touch memory outside bounds.",
CVE-2025-21636,https://www.cve.org/CVERecord?id=CVE-2025-21636,Linux,"sctp: sysctl: plpmtud_probe_interval: avoid using current->nsproxy  As mentioned in a previous commit of this series, using the 'net' structure via 'current' is not recommended for different reasons:  - Inconsistency: getting info from the reader's/writer's netns vs only   from the opener's netns.  - current->nsproxy can be NULL in some cases, resulting in an 'Oops'   (null-ptr-deref), e.g. when the current task is exiting, as spotted by   syzbot [1] using acct(2).  The 'net' structure can be obtained from the table->data using container_of().  Note that table->data could also be used directly, as this is the only member needed from the 'net' structure, but that would increase the size of this fix, to use '*data' everywhere 'net->sctp.probe_interval' is used.",Semantic - Logic error,Invalid pointer dereference,TRUE,#N/A,Need containerof to retrieve struct net to avoid null pointer deref,
CVE-2025-23135,https://www.cve.org/CVERecord?id=CVE-2025-23135,Linux,"RISC-V: KVM: Teardown riscv specific bits after kvm_exit  During a module removal, kvm_exit invokes arch specific disable call which disables AIA. However, we invoke aia_exit before kvm_exit resulting in the following warning. KVM kernel module can't be inserted afterwards due to inconsistent state of IRQ.  [25469.031389] percpu IRQ 31 still enabled on CPU0! [25469.031732] WARNING: CPU: 3 PID: 943 at kernel/irq/manage.c:2476 __free_percpu_irq+0xa2/0x150 [25469.031804] Modules linked in: kvm(-) [25469.031848] CPU: 3 UID: 0 PID: 943 Comm: rmmod Not tainted 6.14.0-rc5-06947-g91c763118f47-dirty #2 [25469.031905] Hardware name: riscv-virtio,qemu (DT) [25469.031928] epc : __free_percpu_irq+0xa2/0x150 [25469.031976]  ra : __free_percpu_irq+0xa2/0x150 [25469.032197] epc : ffffffff8007db1e ra : ffffffff8007db1e sp : ff2000000088bd50 [25469.032241]  gp : ffffffff8131cef8 tp : ff60000080b96400 t0 : ff2000000088baf8 [25469.032285]  t1 : fffffffffffffffc t2 : 5249207570637265 s0 : ff2000000088bd90 [25469.032329]  s1 : ff60000098b21080 a0 : 037d527a15eb4f00 a1 : 037d527a15eb4f00 [25469.032372]  a2 : 0000000000000023 a3 : 0000000000000001 a4 : ffffffff8122dbf8 [25469.032410]  a5 : 0000000000000fff a6 : 0000000000000000 a7 : ffffffff8122dc10 [25469.032448]  s2 : ff60000080c22eb0 s3 : 0000000200000022 s4 : 000000000000001f [25469.032488]  s5 : ff60000080c22e00 s6 : ffffffff80c351c0 s7 : 0000000000000000 [25469.032582]  s8 : 0000000000000003 s9 : 000055556b7fb490 s10: 00007ffff0e12fa0 [25469.032621]  s11: 00007ffff0e13e9a t3 : ffffffff81354ac7 t4 : ffffffff81354ac7 [25469.032664]  t5 : ffffffff81354ac8 t6 : ffffffff81354ac7 [25469.032698] status: 0000000200000100 badaddr: ffffffff8007db1e cause: 0000000000000003 [25469.032738] [<ffffffff8007db1e>] __free_percpu_irq+0xa2/0x150 [25469.032797] [<ffffffff8007dbfc>] free_percpu_irq+0x30/0x5e [25469.032856] [<ffffffff013a57dc>] kvm_riscv_aia_exit+0x40/0x42 [kvm] [25469.033947] [<ffffffff013b4e82>] cleanup_module+0x10/0x32 [kvm] [25469.035300] [<ffffffff8009b150>] __riscv_sys_delete_module+0x18e/0x1fc [25469.035374] [<ffffffff8000c1ca>] syscall_handler+0x3a/0x46 [25469.035456] [<ffffffff809ec9a4>] do_trap_ecall_u+0x72/0x134 [25469.035536] [<ffffffff809f5e18>] handle_exception+0x148/0x156  Invoke aia_exit and other arch specific cleanup functions after kvm_exit so that disable gets a chance to be called first before exit.",Semantic - Logic error,High level spec violation,FALSE,#N/A,try to tear down interrupt twice. ,
CVE-2025-22126,https://www.cve.org/CVERecord?id=CVE-2025-22126,Linux,"md: fix mddev uaf while iterating all_mddevs list  While iterating all_mddevs list from md_notify_reboot() and md_exit(), list_for_each_entry_safe is used, and this can race with deletint the next mddev, causing UAF:  t1: spin_lock //list_for_each_entry_safe(mddev, n, ...)  mddev_get(mddev1)  // assume mddev2 is the next entry  spin_unlock             t2:             //remove mddev2             ...             mddev_free             spin_lock             list_del             spin_unlock             kfree(mddev2)  mddev_put(mddev1)  spin_lock  //continue dereference mddev2->all_mddevs  The old helper for_each_mddev() actually grab the reference of mddev2 while holding the lock, to prevent from being freed. This problem can be fixed the same way, however, the code will be complex.  Hence switch to use list_for_each_entry, in this case mddev_put() can free the mddev1 and it's not safe as well. Refer to md_seq_show(), also factor out a helper mddev_put_locked() to fix this problem.",Race condition - TOUTOC,Use after free,TRUE,#N/A,,
CVE-2025-21923,https://www.cve.org/CVERecord?id=CVE-2025-21923,Linux,"HID: hid-steam: Fix use-after-free when detaching device  When a hid-steam device is removed it must clean up the client_hdev used for intercepting hidraw access. This can lead to scheduling deferred work to reattach the input device. Though the cleanup cancels the deferred work, this was done before the client_hdev itself is cleaned up, so it gets rescheduled. This patch fixes the ordering to make sure the deferred work is properly canceled.",Language - Lifetime violation,Use after free,TRUE,#N/A,scheduled work pointed to deallocated data structure,
CVE-2025-21794,https://www.cve.org/CVERecord?id=CVE-2025-21794,Linux,"HID: hid-thrustmaster: fix stack-out-of-bounds read in usb_check_int_endpoints()  Syzbot[1] has detected a stack-out-of-bounds read of the ep_addr array from hid-thrustmaster driver. This array is passed to usb_check_int_endpoints function from usb.c core driver, which executes a for loop that iterates over the elements of the passed array. Not finding a null element at the end of the array, it tries to read the next, non-existent element, crashing the kernel.  To fix this, a 0 element was added at the end of the array to break the for loop.  [1] https://syzkaller.appspot.com/bug?extid=9c9179ac46169c56c1ad",Language - Null byte termination,OOB access,TRUE,#N/A,caused by the fix to CVE-2024-57993 :/ https://github.com/torvalds/linux/commit/50420d7c79c37a3efe4010ff9b1bb14bc61ebccf,
CVE-2025-21764,https://www.cve.org/CVERecord?id=CVE-2025-21764,Linux,ndisc: use RCU protection in ndisc_alloc_skb()  ndisc_alloc_skb() can be called without RTNL or RCU being held.  Add RCU protection to avoid possible UAF.,Language - Lifetime violation,Use after free,TRUE,#N/A,,
CVE-2025-22026,https://www.cve.org/CVERecord?id=CVE-2025-22026,Linux,"nfsd: don't ignore the return code of svc_proc_register()  Currently, nfsd_proc_stat_init() ignores the return value of svc_proc_register(). If the procfile creation fails, then the kernel will WARN when it tries to remove the entry later.  Fix nfsd_proc_stat_init() to return the same type of pointer as svc_proc_register(), and fix up nfsd_net_init() to check that and fail the nfsd_net construction if it occurs.  svc_proc_register() can fail if the dentry can't be allocated, or if an identical dentry already exists. The second case is pretty unlikely in the nfsd_net construction codepath, so if this happens, return -ENOMEM.",Semantic - Missing return value check,High level spec violation,FALSE,#N/A,,
CVE-2025-21807,https://www.cve.org/CVERecord?id=CVE-2025-21807,Linux,"block: fix queue freeze vs limits lock order in sysfs store methods  queue_attr_store() always freezes a device queue before calling the attribute store operation. For attributes that control queue limits, the store operation will also lock the queue limits with a call to queue_limits_start_update(). However, some drivers (e.g. SCSI sd) may need to issue commands to a device to obtain limit values from the hardware with the queue limits locked. This creates a potential ABBA deadlock situation if a user attempts to modify a limit (thus freezing the device queue) while the device driver starts a revalidation of the device queue limits.  Avoid such deadlock by not freezing the queue before calling the ->store_limit() method in struct queue_sysfs_entry and instead use the queue_limits_commit_update_frozen helper to freeze the queue after taking the limits lock.  This also removes taking the sysfs lock for the store_limit method as it doesn't protect anything here, but creates even more nesting. Hopefully it will go away from the actual sysfs methods entirely soon.  (commit log adapted from a similar patch from  Damien Le Moal)",Race condition - Improper usage of synchronization primitives,Failure to release CPU,FALSE,#N/A,,
CVE-2025-21886,https://www.cve.org/CVERecord?id=CVE-2025-21886,Linux,"RDMA/mlx5: Fix implicit ODP hang on parent deregistration  Fix the destroy_unused_implicit_child_mr() to prevent hanging during parent deregistration as of below [1].  Upon entering destroy_unused_implicit_child_mr(), the reference count for the implicit MR parent is incremented using: refcount_inc_not_zero().  A corresponding decrement must be performed if free_implicit_child_mr_work() is not called.  The code has been updated to properly manage the reference count that was incremented.  [1] INFO: task python3:2157 blocked for more than 120 seconds. Not tainted 6.12.0-rc7+ #1633 ""echo 0 > /proc/sys/kernel/hung_task_timeout_secs"" disables this message. task:python3         state:D stack:0     pid:2157 tgid:2157  ppid:1685   flags:0x00000000 Call Trace: <TASK> __schedule+0x420/0xd30 schedule+0x47/0x130 __mlx5_ib_dereg_mr+0x379/0x5d0 [mlx5_ib] ? __pfx_autoremove_wake_function+0x10/0x10 ib_dereg_mr_user+0x5f/0x120 [ib_core] ? lock_release+0xc6/0x280 destroy_hw_idr_uobject+0x1d/0x60 [ib_uverbs] uverbs_destroy_uobject+0x58/0x1d0 [ib_uverbs] uobj_destroy+0x3f/0x70 [ib_uverbs] ib_uverbs_cmd_verbs+0x3e4/0xbb0 [ib_uverbs] ? __pfx_uverbs_destroy_def_handler+0x10/0x10 [ib_uverbs] ? lock_acquire+0xc1/0x2f0 ? ib_uverbs_ioctl+0xcb/0x170 [ib_uverbs] ? ib_uverbs_ioctl+0x116/0x170 [ib_uverbs] ? lock_release+0xc6/0x280 ib_uverbs_ioctl+0xe7/0x170 [ib_uverbs] ? ib_uverbs_ioctl+0xcb/0x170 [ib_uverbs]  __x64_sys_ioctl+0x1b0/0xa70 ? kmem_cache_free+0x221/0x400 do_syscall_64+0x6b/0x140 entry_SYSCALL_64_after_hwframe+0x76/0x7e RIP: 0033:0x7f20f21f017b RSP: 002b:00007ffcfc4a77c8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010 RAX: ffffffffffffffda RBX: 00007ffcfc4a78d8 RCX: 00007f20f21f017b RDX: 00007ffcfc4a78c0 RSI: 00000000c0181b01 RDI: 0000000000000003 RBP: 00007ffcfc4a78a0 R08: 000056147d125190 R09: 00007f20f1f14c60 R10: 0000000000000001 R11: 0000000000000246 R12: 00007ffcfc4a7890 R13: 000000000000001c R14: 000056147d100fc0 R15: 00007f20e365c9d0 </TASK>",Language - Lifetime violation,Resource leak,FALSE,#N/A,,
CVE-2025-22020,https://www.cve.org/CVERecord?id=CVE-2025-22020,Linux,"memstick: rtsx_usb_ms: Fix slab-use-after-free in rtsx_usb_ms_drv_remove  This fixes the following crash:  ================================================================== BUG: KASAN: slab-use-after-free in rtsx_usb_ms_poll_card+0x159/0x200 [rtsx_usb_ms] Read of size 8 at addr ffff888136335380 by task kworker/6:0/140241  CPU: 6 UID: 0 PID: 140241 Comm: kworker/6:0 Kdump: loaded Tainted: G            E      6.14.0-rc6+ #1 Tainted: [E]=UNSIGNED_MODULE Hardware name: LENOVO 30FNA1V7CW/1057, BIOS S0EKT54A 07/01/2024 Workqueue: events rtsx_usb_ms_poll_card [rtsx_usb_ms] Call Trace:  <TASK>  dump_stack_lvl+0x51/0x70  print_address_description.constprop.0+0x27/0x320  ? rtsx_usb_ms_poll_card+0x159/0x200 [rtsx_usb_ms]  print_report+0x3e/0x70  kasan_report+0xab/0xe0  ? rtsx_usb_ms_poll_card+0x159/0x200 [rtsx_usb_ms]  rtsx_usb_ms_poll_card+0x159/0x200 [rtsx_usb_ms]  ? __pfx_rtsx_usb_ms_poll_card+0x10/0x10 [rtsx_usb_ms]  ? __pfx___schedule+0x10/0x10  ? kick_pool+0x3b/0x270  process_one_work+0x357/0x660  worker_thread+0x390/0x4c0  ? __pfx_worker_thread+0x10/0x10  kthread+0x190/0x1d0  ? __pfx_kthread+0x10/0x10  ret_from_fork+0x2d/0x50  ? __pfx_kthread+0x10/0x10  ret_from_fork_asm+0x1a/0x30  </TASK>  Allocated by task 161446:  kasan_save_stack+0x20/0x40  kasan_save_track+0x10/0x30  __kasan_kmalloc+0x7b/0x90  __kmalloc_noprof+0x1a7/0x470  memstick_alloc_host+0x1f/0xe0 [memstick]  rtsx_usb_ms_drv_probe+0x47/0x320 [rtsx_usb_ms]  platform_probe+0x60/0xe0  call_driver_probe+0x35/0x120  really_probe+0x123/0x410  __driver_probe_device+0xc7/0x1e0  driver_probe_device+0x49/0xf0  __device_attach_driver+0xc6/0x160  bus_for_each_drv+0xe4/0x160  __device_attach+0x13a/0x2b0  bus_probe_device+0xbd/0xd0  device_add+0x4a5/0x760  platform_device_add+0x189/0x370  mfd_add_device+0x587/0x5e0  mfd_add_devices+0xb1/0x130  rtsx_usb_probe+0x28e/0x2e0 [rtsx_usb]  usb_probe_interface+0x15c/0x460  call_driver_probe+0x35/0x120  really_probe+0x123/0x410  __driver_probe_device+0xc7/0x1e0  driver_probe_device+0x49/0xf0  __device_attach_driver+0xc6/0x160  bus_for_each_drv+0xe4/0x160  __device_attach+0x13a/0x2b0  rebind_marked_interfaces.isra.0+0xcc/0x110  usb_reset_device+0x352/0x410  usbdev_do_ioctl+0xe5c/0x1860  usbdev_ioctl+0xa/0x20  __x64_sys_ioctl+0xc5/0xf0  do_syscall_64+0x59/0x170  entry_SYSCALL_64_after_hwframe+0x76/0x7e  Freed by task 161506:  kasan_save_stack+0x20/0x40  kasan_save_track+0x10/0x30  kasan_save_free_info+0x36/0x60  __kasan_slab_free+0x34/0x50  kfree+0x1fd/0x3b0  device_release+0x56/0xf0  kobject_cleanup+0x73/0x1c0  rtsx_usb_ms_drv_remove+0x13d/0x220 [rtsx_usb_ms]  platform_remove+0x2f/0x50  device_release_driver_internal+0x24b/0x2e0  bus_remove_device+0x124/0x1d0  device_del+0x239/0x530  platform_device_del.part.0+0x19/0xe0  platform_device_unregister+0x1c/0x40  mfd_remove_devices_fn+0x167/0x170  device_for_each_child_reverse+0xc9/0x130  mfd_remove_devices+0x6e/0xa0  rtsx_usb_disconnect+0x2e/0xd0 [rtsx_usb]  usb_unbind_interface+0xf3/0x3f0  device_release_driver_internal+0x24b/0x2e0  proc_disconnect_claim+0x13d/0x220  usbdev_do_ioctl+0xb5e/0x1860  usbdev_ioctl+0xa/0x20  __x64_sys_ioctl+0xc5/0xf0  do_syscall_64+0x59/0x170  entry_SYSCALL_64_after_hwframe+0x76/0x7e  Last potentially related work creation:  kasan_save_stack+0x20/0x40  kasan_record_aux_stack+0x85/0x90  insert_work+0x29/0x100  __queue_work+0x34a/0x540  call_timer_fn+0x2a/0x160  expire_timers+0x5f/0x1f0  __run_timer_base.part.0+0x1b6/0x1e0  run_timer_softirq+0x8b/0xe0  handle_softirqs+0xf9/0x360  __irq_exit_rcu+0x114/0x130  sysvec_apic_timer_interrupt+0x72/0x90  asm_sysvec_apic_timer_interrupt+0x16/0x20  Second to last potentially related work creation:  kasan_save_stack+0x20/0x40  kasan_record_aux_stack+0x85/0x90  insert_work+0x29/0x100  __queue_work+0x34a/0x540  call_timer_fn+0x2a/0x160  expire_timers+0x5f/0x1f0  __run_timer_base.part.0+0x1b6/0x1e0  run_timer_softirq+0x8b/0xe0  handle_softirqs+0xf9/0x ---truncated---",Language - Lifetime violation,Use after free,TRUE,#N/A,,
CVE-2025-21909,https://www.cve.org/CVERecord?id=CVE-2025-21909,Linux,wifi: nl80211: reject cooked mode if it is set along with other flags  It is possible to set both MONITOR_FLAG_COOK_FRAMES and MONITOR_FLAG_ACTIVE flags simultaneously on the same monitor interface from the userspace. This causes a sub-interface to be created with no IEEE80211_SDATA_IN_DRIVER bit set because the monitor interface is in the cooked state and it takes precedence over all other states. When the interface is then being deleted the kernel calls WARN_ONCE() from check_sdata_in_driver() because of missing that bit.  Fix this by rejecting MONITOR_FLAG_COOK_FRAMES if it is set along with other flags.  Found by Linux Verification Center (linuxtesting.org) with Syzkaller.,Semantic - Improper input validation,High level spec violation,FALSE,#N/A,,
CVE-2025-21675,https://www.cve.org/CVERecord?id=CVE-2025-21675,Linux,"net/mlx5: Clear port select structure when fail to create  Clear the port select structure on error so no stale values left after definers are destroyed. That's because the mlx5_lag_destroy_definers() always try to destroy all lag definers in the tt_map, so in the flow below lag definers get double-destroyed and cause kernel crash:    mlx5_lag_port_sel_create()     mlx5_lag_create_definers()       mlx5_lag_create_definer()     <- Failed on tt 1         mlx5_lag_destroy_definers() <- definers[tt=0] gets destroyed   mlx5_lag_port_sel_create()     mlx5_lag_create_definers()       mlx5_lag_create_definer()     <- Failed on tt 0         mlx5_lag_destroy_definers() <- definers[tt=0] gets double-destroyed   Unable to handle kernel NULL pointer dereference at virtual address 0000000000000008  Mem abort info:    ESR = 0x0000000096000005    EC = 0x25: DABT (current EL), IL = 32 bits    SET = 0, FnV = 0    EA = 0, S1PTW = 0    FSC = 0x05: level 1 translation fault  Data abort info:    ISV = 0, ISS = 0x00000005, ISS2 = 0x00000000    CM = 0, WnR = 0, TnD = 0, TagAccess = 0    GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0  user pgtable: 64k pages, 48-bit VAs, pgdp=0000000112ce2e00  [0000000000000008] pgd=0000000000000000, p4d=0000000000000000, pud=0000000000000000  Internal error: Oops: 0000000096000005 [#1] PREEMPT SMP  Modules linked in: iptable_raw bonding ip_gre ip6_gre gre ip6_tunnel tunnel6 geneve ip6_udp_tunnel udp_tunnel ipip tunnel4 ip_tunnel rdma_ucm(OE) rdma_cm(OE) iw_cm(OE) ib_ipoib(OE) ib_cm(OE) ib_umad(OE) mlx5_ib(OE) ib_uverbs(OE) mlx5_fwctl(OE) fwctl(OE) mlx5_core(OE) mlxdevm(OE) ib_core(OE) mlxfw(OE) memtrack(OE) mlx_compat(OE) openvswitch nsh nf_conncount psample xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink xfrm_user xfrm_algo xt_addrtype iptable_filter iptable_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 br_netfilter bridge stp llc netconsole overlay efi_pstore sch_fq_codel zram ip_tables crct10dif_ce qemu_fw_cfg fuse ipv6 crc_ccitt [last unloaded: mlx_compat(OE)]   CPU: 3 UID: 0 PID: 217 Comm: kworker/u53:2 Tainted: G           OE      6.11.0+ #2   Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE   Hardware name: QEMU KVM Virtual Machine, BIOS 0.0.0 02/06/2015   Workqueue: mlx5_lag mlx5_do_bond_work [mlx5_core]   pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)   pc : mlx5_del_flow_rules+0x24/0x2c0 [mlx5_core]   lr : mlx5_lag_destroy_definer+0x54/0x100 [mlx5_core]   sp : ffff800085fafb00   x29: ffff800085fafb00 x28: ffff0000da0c8000 x27: 0000000000000000   x26: ffff0000da0c8000 x25: ffff0000da0c8000 x24: ffff0000da0c8000   x23: ffff0000c31f81a0 x22: 0400000000000000 x21: ffff0000da0c8000   x20: 0000000000000000 x19: 0000000000000001 x18: 0000000000000000   x17: 0000000000000000 x16: 0000000000000000 x15: 0000ffff8b0c9350   x14: 0000000000000000 x13: ffff800081390d18 x12: ffff800081dc3cc0   x11: 0000000000000001 x10: 0000000000000b10 x9 : ffff80007ab7304c   x8 : ffff0000d00711f0 x7 : 0000000000000004 x6 : 0000000000000190   x5 : ffff00027edb3010 x4 : 0000000000000000 x3 : 0000000000000000   x2 : ffff0000d39b8000 x1 : ffff0000d39b8000 x0 : 0400000000000000   Call trace:    mlx5_del_flow_rules+0x24/0x2c0 [mlx5_core]    mlx5_lag_destroy_definer+0x54/0x100 [mlx5_core]    mlx5_lag_destroy_definers+0xa0/0x108 [mlx5_core]    mlx5_lag_port_sel_create+0x2d4/0x6f8 [mlx5_core]    mlx5_activate_lag+0x60c/0x6f8 [mlx5_core]    mlx5_do_bond_work+0x284/0x5c8 [mlx5_core]    process_one_work+0x170/0x3e0    worker_thread+0x2d8/0x3e0    kthread+0x11c/0x128    ret_from_fork+0x10/0x20   Code: a9025bf5 aa0003f6 a90363f7 f90023f9 (f9400400)   ---[ end trace 0000000000000000 ]---",Protocol - Missing Protocol Steps,Double free,FALSE,#N/A,improper teardown causes information disclosure,
CVE-2025-22099,https://www.cve.org/CVERecord?id=CVE-2025-22099,Linux,"drm: xlnx: zynqmp_dpsub: Add NULL check in zynqmp_audio_init  devm_kasprintf() calls can return null pointers on failure. But some return values were not checked in zynqmp_audio_init().  Add NULL check in zynqmp_audio_init(), avoid referencing null pointers in the subsequent code.",Semantic - Improper input validation,Invalid pointer dereference,TRUE,#N/A,null ptr deref,
CVE-2025-22110,https://www.cve.org/CVERecord?id=CVE-2025-22110,Linux,"netfilter: nfnetlink_queue: Initialize ctx to avoid memory allocation error  It is possible that ctx in nfqnl_build_packet_message() could be used before it is properly initialize, which is only initialized by nfqnl_get_sk_secctx().  This patch corrects this problem by initializing the lsmctx to a safe value when it is declared.  This is similar to the commit 35fcac7a7c25 (""audit: Initialize lsmctx to avoid memory allocation error"").",Language - Improper memory initialization,Uninitialized memory access,FALSE,#N/A,information disclosure,
CVE-2025-21967,https://www.cve.org/CVERecord?id=CVE-2025-21967,Linux,ksmbd: fix use-after-free in ksmbd_free_work_struct  ->interim_entry of ksmbd_work could be deleted after oplock is freed. We don't need to manage it with linked list. The interim request could be immediately sent whenever a oplock break wait is needed.,Race condition - TOUTOC,Use after free,TRUE,#N/A,,
CVE-2025-23142,https://www.cve.org/CVERecord?id=CVE-2025-23142,Linux,"sctp: detect and prevent references to a freed transport in sendmsg  sctp_sendmsg() re-uses associations and transports when possible by doing a lookup based on the socket endpoint and the message destination address, and then sctp_sendmsg_to_asoc() sets the selected transport in all the message chunks to be sent.  There's a possible race condition if another thread triggers the removal of that selected transport, for instance, by explicitly unbinding an address with setsockopt(SCTP_SOCKOPT_BINDX_REM), after the chunks have been set up and before the message is sent. This can happen if the send buffer is full, during the period when the sender thread temporarily releases the socket lock in sctp_wait_for_sndbuf().  This causes the access to the transport data in sctp_outq_select_transport(), when the association outqueue is flushed, to result in a use-after-free read.  This change avoids this scenario by having sctp_transport_free() signal the freeing of the transport, tagging it as ""dead"". In order to do this, the patch restores the ""dead"" bit in struct sctp_transport, which was removed in commit 47faa1e4c50e (""sctp: remove the dead field of sctp_transport"").  Then, in the scenario where the sender thread has released the socket lock in sctp_wait_for_sndbuf(), the bit is checked again after re-acquiring the socket lock to detect the deletion. This is done while holding a reference to the transport to prevent it from being freed in the process.  If the transport was deleted while the socket lock was relinquished, sctp_sendmsg_to_asoc() will return -EAGAIN to let userspace retry the send.  The bug was found by a private syzbot instance (see the error report [1] and the C reproducer that triggers it [2]).",Race condition - TOUTOC,Use after free,TRUE,#N/A,,
CVE-2025-23148,https://www.cve.org/CVERecord?id=CVE-2025-23148,Linux,"soc: samsung: exynos-chipid: Add NULL pointer check in exynos_chipid_probe()  soc_dev_attr->revision could be NULL, thus, a pointer check is added to prevent potential NULL pointer dereference. This is similar to the fix in commit 3027e7b15b02 (""ice: Fix some null pointer dereference issues in ice_ptp.c"").  This issue is found by our static analysis tool.",Semantic - Improper input validation,Invalid pointer dereference,TRUE,#N/A,null ptr deref,
CVE-2025-21662,https://www.cve.org/CVERecord?id=CVE-2025-21662,Linux,"net/mlx5: Fix variable not being completed when function returns  When cmd_alloc_index(), fails cmd_work_handler() needs to complete ent->slotted before returning early. Otherwise the task which issued the command may hang:     mlx5_core 0000:01:00.0: cmd_work_handler:877:(pid 3880418): failed to allocate command entry    INFO: task kworker/13:2:4055883 blocked for more than 120 seconds.          Not tainted 4.19.90-25.44.v2101.ky10.aarch64 #1    ""echo 0 > /proc/sys/kernel/hung_task_timeout_secs"" disables this message.    kworker/13:2    D    0 4055883      2 0x00000228    Workqueue: events mlx5e_tx_dim_work [mlx5_core]    Call trace:       __switch_to+0xe8/0x150       __schedule+0x2a8/0x9b8       schedule+0x2c/0x88       schedule_timeout+0x204/0x478       wait_for_common+0x154/0x250       wait_for_completion+0x28/0x38       cmd_exec+0x7a0/0xa00 [mlx5_core]       mlx5_cmd_exec+0x54/0x80 [mlx5_core]       mlx5_core_modify_cq+0x6c/0x80 [mlx5_core]       mlx5_core_modify_cq_moderation+0xa0/0xb8 [mlx5_core]       mlx5e_tx_dim_work+0x54/0x68 [mlx5_core]       process_one_work+0x1b0/0x448       worker_thread+0x54/0x468       kthread+0x134/0x138       ret_from_fork+0x10/0x18",Language - Lifetime violation,Failure to release CPU,FALSE,#N/A,,
CVE-2025-21968,https://www.cve.org/CVERecord?id=CVE-2025-21968,Linux,drm/amd/display: Fix slab-use-after-free on hdcp_work  [Why] A slab-use-after-free is reported when HDCP is destroyed but the property_validate_dwork queue is still running.  [How] Cancel the delayed work when destroying workqueue.  (cherry picked from commit 725a04ba5a95e89c89633d4322430cfbca7ce128),Protocol - Missing Protocol Steps,Use after free,TRUE,#N/A,fail to call cancel delayed work,
CVE-2025-21671,https://www.cve.org/CVERecord?id=CVE-2025-21671,Linux,"zram: fix potential UAF of zram table  If zram_meta_alloc failed early, it frees allocated zram->table without setting it NULL.  Which will potentially cause zram_meta_free to access the table if user reset an failed and uninitialized device.",Language - Lifetime violation,Use after free,TRUE,#N/A,,
CVE-2025-22085,https://www.cve.org/CVERecord?id=CVE-2025-22085,Linux,"RDMA/core: Fix use-after-free when rename device name  Syzbot reported a slab-use-after-free with the following call trace:  ================================================================== BUG: KASAN: slab-use-after-free in nla_put+0xd3/0x150 lib/nlattr.c:1099 Read of size 5 at addr ffff888140ea1c60 by task syz.0.988/10025  CPU: 0 UID: 0 PID: 10025 Comm: syz.0.988 Not tainted 6.14.0-rc4-syzkaller-00859-gf77f12010f67 #0 Hardware name: Google Compute Engine, BIOS Google 02/12/2025 Call Trace:  <TASK>  __dump_stack lib/dump_stack.c:94 [inline]  dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120  print_address_description mm/kasan/report.c:408 [inline]  print_report+0x16e/0x5b0 mm/kasan/report.c:521  kasan_report+0x143/0x180 mm/kasan/report.c:634  kasan_check_range+0x282/0x290 mm/kasan/generic.c:189  __asan_memcpy+0x29/0x70 mm/kasan/shadow.c:105  nla_put+0xd3/0x150 lib/nlattr.c:1099  nla_put_string include/net/netlink.h:1621 [inline]  fill_nldev_handle+0x16e/0x200 drivers/infiniband/core/nldev.c:265  rdma_nl_notify_event+0x561/0xef0 drivers/infiniband/core/nldev.c:2857  ib_device_notify_register+0x22/0x230 drivers/infiniband/core/device.c:1344  ib_register_device+0x1292/0x1460 drivers/infiniband/core/device.c:1460  rxe_register_device+0x233/0x350 drivers/infiniband/sw/rxe/rxe_verbs.c:1540  rxe_net_add+0x74/0xf0 drivers/infiniband/sw/rxe/rxe_net.c:550  rxe_newlink+0xde/0x1a0 drivers/infiniband/sw/rxe/rxe.c:212  nldev_newlink+0x5ea/0x680 drivers/infiniband/core/nldev.c:1795  rdma_nl_rcv_skb drivers/infiniband/core/netlink.c:239 [inline]  rdma_nl_rcv+0x6dd/0x9e0 drivers/infiniband/core/netlink.c:259  netlink_unicast_kernel net/netlink/af_netlink.c:1313 [inline]  netlink_unicast+0x7f6/0x990 net/netlink/af_netlink.c:1339  netlink_sendmsg+0x8de/0xcb0 net/netlink/af_netlink.c:1883  sock_sendmsg_nosec net/socket.c:709 [inline]  __sock_sendmsg+0x221/0x270 net/socket.c:724  ____sys_sendmsg+0x53a/0x860 net/socket.c:2564  ___sys_sendmsg net/socket.c:2618 [inline]  __sys_sendmsg+0x269/0x350 net/socket.c:2650  do_syscall_x64 arch/x86/entry/common.c:52 [inline]  do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83  entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7f42d1b8d169 Code: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 ... RSP: 002b:00007f42d2960038 EFLAGS: 00000246 ORIG_RAX: 000000000000002e RAX: ffffffffffffffda RBX: 00007f42d1da6320 RCX: 00007f42d1b8d169 RDX: 0000000000000000 RSI: 00004000000002c0 RDI: 000000000000000c RBP: 00007f42d1c0e2a0 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000 R13: 0000000000000000 R14: 00007f42d1da6320 R15: 00007ffe399344a8  </TASK>  Allocated by task 10025:  kasan_save_stack mm/kasan/common.c:47 [inline]  kasan_save_track+0x3f/0x80 mm/kasan/common.c:68  poison_kmalloc_redzone mm/kasan/common.c:377 [inline]  __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:394  kasan_kmalloc include/linux/kasan.h:260 [inline]  __do_kmalloc_node mm/slub.c:4294 [inline]  __kmalloc_node_track_caller_noprof+0x28b/0x4c0 mm/slub.c:4313  __kmemdup_nul mm/util.c:61 [inline]  kstrdup+0x42/0x100 mm/util.c:81  kobject_set_name_vargs+0x61/0x120 lib/kobject.c:274  dev_set_name+0xd5/0x120 drivers/base/core.c:3468  assign_name drivers/infiniband/core/device.c:1202 [inline]  ib_register_device+0x178/0x1460 drivers/infiniband/core/device.c:1384  rxe_register_device+0x233/0x350 drivers/infiniband/sw/rxe/rxe_verbs.c:1540  rxe_net_add+0x74/0xf0 drivers/infiniband/sw/rxe/rxe_net.c:550  rxe_newlink+0xde/0x1a0 drivers/infiniband/sw/rxe/rxe.c:212  nldev_newlink+0x5ea/0x680 drivers/infiniband/core/nldev.c:1795  rdma_nl_rcv_skb drivers/infiniband/core/netlink.c:239 [inline]  rdma_nl_rcv+0x6dd/0x9e0 drivers/infiniband/core/netlink.c:259  netlink_unicast_kernel net/netlink/af_netlink.c:1313 [inline]  netlink_unicast+0x7f6/0x990 net/netlink/af_netlink.c:1339  netlink_sendmsg+0x8de/0xcb0 net ---truncated---",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,#N/A,,
CVE-2025-21639,https://www.cve.org/CVERecord?id=CVE-2025-21639,Linux,"sctp: sysctl: rto_min/max: avoid using current->nsproxy  As mentioned in a previous commit of this series, using the 'net' structure via 'current' is not recommended for different reasons:  - Inconsistency: getting info from the reader's/writer's netns vs only   from the opener's netns.  - current->nsproxy can be NULL in some cases, resulting in an 'Oops'   (null-ptr-deref), e.g. when the current task is exiting, as spotted by   syzbot [1] using acct(2).  The 'net' structure can be obtained from the table->data using container_of().  Note that table->data could also be used directly, as this is the only member needed from the 'net' structure, but that would increase the size of this fix, to use '*data' everywhere 'net->sctp.rto_min/max' is used.",Semantic - Logic error,Invalid pointer dereference,TRUE,#N/A,"null deref, breaking new kernel idiom",
CVE-2025-37789,https://www.cve.org/CVERecord?id=CVE-2025-37789,Linux,net: openvswitch: fix nested key length validation in the set() action  It's not safe to access nla_len(ovs_key) if the data is smaller than the netlink header.  Check that the attribute is OK first.,Semantic - Improper input validation,OOB access,TRUE,#N/A,,
CVE-2025-21789,https://www.cve.org/CVERecord?id=CVE-2025-21789,Linux,"LoongArch: csum: Fix OoB access in IP checksum code for negative lengths  Commit 69e3a6aa6be2 (""LoongArch: Add checksum optimization for 64-bit system"") would cause an undefined shift and an out-of-bounds read.  Commit 8bd795fedb84 (""arm64: csum: Fix OoB access in IP checksum code for negative lengths"") fixes the same issue on ARM64.",Semantic - Logic error,OOB access,TRUE,#N/A,,
CVE-2025-21690,https://www.cve.org/CVERecord?id=CVE-2025-21690,Linux,"scsi: storvsc: Ratelimit warning logs to prevent VM denial of service  If there's a persistent error in the hypervisor, the SCSI warning for failed I/O can flood the kernel log and max out CPU utilization, preventing troubleshooting from the VM side. Ratelimit the warning so it doesn't DoS the VM.",Semantic - Logic error,High level spec violation,FALSE,#N/A,,
CVE-2025-22050,https://www.cve.org/CVERecord?id=CVE-2025-22050,Linux,"usbnet:fix NPE during rx_complete  Missing usbnet_going_away Check in Critical Path. The usb_submit_urb function lacks a usbnet_going_away validation, whereas __usbnet_queue_skb includes this check.  This inconsistency creates a race condition where: A URB request may succeed, but the corresponding SKB data fails to be queued.  Subsequent processes: (e.g., rx_complete  defer_bh  __skb_unlink(skb, list)) attempt to access skb->next, triggering a NULL pointer dereference (Kernel Panic).",Semantic - Improper input validation,Invalid pointer dereference,TRUE,#N/A,,
CVE-2025-22052,https://www.cve.org/CVERecord?id=CVE-2025-22052,Linux,staging: gpib: Fix Oops after disconnect in ni_usb  If the usb dongle is disconnected subsequent calls to the driver cause a NULL dereference Oops as the bus_interface is set to NULL on disconnect.  This problem was introduced by setting usb_dev from the bus_interface for dev_xxx messages.  Previously bus_interface was checked for NULL only in the the functions directly calling usb_fill_bulk_urb or usb_control_msg.  Check for valid bus_interface on all interface entry points and return -ENODEV if it is NULL.,Semantic - Improper input validation,Invalid pointer dereference,TRUE,#N/A,,
CVE-2025-21870,https://www.cve.org/CVERecord?id=CVE-2025-21870,Linux,"ASoC: SOF: ipc4-topology: Harden loops for looking up ALH copiers  Other, non DAI copier widgets could have the same  stream name (sname) as the ALH copier and in that case the copier->data is NULL, no alh_data is attached, which could lead to NULL pointer dereference. We could check for this NULL pointer in sof_ipc4_prepare_copier_module() and avoid the crash, but a similar loop in sof_ipc4_widget_setup_comp_dai() will miscalculate the ALH device count, causing broken audio.  The correct fix is to harden the matching logic by making sure that the 1. widget is a DAI widget - so dai = w->private is valid 2. the dai (and thus the copier) is ALH copier",Semantic - Logic error,Invalid pointer dereference,TRUE,#N/A,,
CVE-2025-21928,https://www.cve.org/CVERecord?id=CVE-2025-21928,Linux,"HID: intel-ish-hid: Fix use-after-free issue in ishtp_hid_remove()  The system can experience a random crash a few minutes after the driver is removed. This issue occurs due to improper handling of memory freeing in the ishtp_hid_remove() function.  The function currently frees the `driver_data` directly within the loop that destroys the HID devices, which can lead to accessing freed memory. Specifically, `hid_destroy_device()` uses `driver_data` when it calls `hid_ishtp_set_feature()` to power off the sensor, so freeing `driver_data` beforehand can result in accessing invalid memory.  This patch resolves the issue by storing the `driver_data` in a temporary variable before calling `hid_destroy_device()`, and then freeing the `driver_data` after the device is destroyed.",Language - Lifetime violation,Use after free,TRUE,#N/A,,
CVE-2025-22001,https://www.cve.org/CVERecord?id=CVE-2025-22001,Linux,accel/qaic: Fix integer overflow in qaic_validate_req()  These are u64 variables that come from the user via qaic_attach_slice_bo_ioctl().  Use check_add_overflow() to ensure that the math doesn't have an integer wrapping bug.,Language - Integer overflow,OOB access,TRUE,#N/A,,
CVE-2025-39688,https://www.cve.org/CVERecord?id=CVE-2025-39688,Linux,"nfsd: allow SC_STATUS_FREEABLE when searching via nfs4_lookup_stateid()  The pynfs DELEG8 test fails when run against nfsd. It acquires a delegation and then lets the lease time out. It then tries to use the deleg stateid and expects to see NFS4ERR_DELEG_REVOKED, but it gets bad NFS4ERR_BAD_STATEID instead.  When a delegation is revoked, it's initially marked with SC_STATUS_REVOKED, or SC_STATUS_ADMIN_REVOKED and later, it's marked with the SC_STATUS_FREEABLE flag, which denotes that it is waiting for s FREE_STATEID call.  nfs4_lookup_stateid() accepts a statusmask that includes the status flags that a found stateid is allowed to have. Currently, that mask never includes SC_STATUS_FREEABLE, which means that revoked delegations are (almost) never found.  Add SC_STATUS_FREEABLE to the always-allowed status flags, and remove it from nfsd4_delegreturn() since it's now always implied.",Semantic - Spec error,Resource leak,FALSE,#N/A,"Internal spec error: SC_STATUS_FREEABLE missing from valid state flags, blocking delegation cleanup and causing resource leak.",
CVE-2025-22053,https://www.cve.org/CVERecord?id=CVE-2025-22053,Linux,"net: ibmveth: make veth_pool_store stop hanging  v2: - Created a single error handling unlock and exit in veth_pool_store - Greatly expanded commit message with previous explanatory-only text  Summary: Use rtnl_mutex to synchronize veth_pool_store with itself, ibmveth_close and ibmveth_open, preventing multiple calls in a row to napi_disable.  Background: Two (or more) threads could call veth_pool_store through writing to /sys/devices/vio/30000002/pool*/*. You can do this easily with a little shell script. This causes a hang.  I configured LOCKDEP, compiled ibmveth.c with DEBUG, and built a new kernel. I ran this test again and saw:      Setting pool0/active to 0     Setting pool1/active to 1     [   73.911067][ T4365] ibmveth 30000002 eth0: close starting     Setting pool1/active to 1     Setting pool1/active to 0     [   73.911367][ T4366] ibmveth 30000002 eth0: close starting     [   73.916056][ T4365] ibmveth 30000002 eth0: close complete     [   73.916064][ T4365] ibmveth 30000002 eth0: open starting     [  110.808564][  T712] systemd-journald[712]: Sent WATCHDOG=1 notification.     [  230.808495][  T712] systemd-journald[712]: Sent WATCHDOG=1 notification.     [  243.683786][  T123] INFO: task stress.sh:4365 blocked for more than 122 seconds.     [  243.683827][  T123]       Not tainted 6.14.0-01103-g2df0c02dab82-dirty #8     [  243.683833][  T123] ""echo 0 > /proc/sys/kernel/hung_task_timeout_secs"" disables this message.     [  243.683838][  T123] task:stress.sh       state:D stack:28096 pid:4365  tgid:4365  ppid:4364   task_flags:0x400040 flags:0x00042000     [  243.683852][  T123] Call Trace:     [  243.683857][  T123] [c00000000c38f690] [0000000000000001] 0x1 (unreliable)     [  243.683868][  T123] [c00000000c38f840] [c00000000001f908] __switch_to+0x318/0x4e0     [  243.683878][  T123] [c00000000c38f8a0] [c000000001549a70] __schedule+0x500/0x12a0     [  243.683888][  T123] [c00000000c38f9a0] [c00000000154a878] schedule+0x68/0x210     [  243.683896][  T123] [c00000000c38f9d0] [c00000000154ac80] schedule_preempt_disabled+0x30/0x50     [  243.683904][  T123] [c00000000c38fa00] [c00000000154dbb0] __mutex_lock+0x730/0x10f0     [  243.683913][  T123] [c00000000c38fb10] [c000000001154d40] napi_enable+0x30/0x60     [  243.683921][  T123] [c00000000c38fb40] [c000000000f4ae94] ibmveth_open+0x68/0x5dc     [  243.683928][  T123] [c00000000c38fbe0] [c000000000f4aa20] veth_pool_store+0x220/0x270     [  243.683936][  T123] [c00000000c38fc70] [c000000000826278] sysfs_kf_write+0x68/0xb0     [  243.683944][  T123] [c00000000c38fcb0] [c0000000008240b8] kernfs_fop_write_iter+0x198/0x2d0     [  243.683951][  T123] [c00000000c38fd00] [c00000000071b9ac] vfs_write+0x34c/0x650     [  243.683958][  T123] [c00000000c38fdc0] [c00000000071bea8] ksys_write+0x88/0x150     [  243.683966][  T123] [c00000000c38fe10] [c0000000000317f4] system_call_exception+0x124/0x340     [  243.683973][  T123] [c00000000c38fe50] [c00000000000d05c] system_call_vectored_common+0x15c/0x2ec     ...     [  243.684087][  T123] Showing all locks held in the system:     [  243.684095][  T123] 1 lock held by khungtaskd/123:     [  243.684099][  T123]  #0: c00000000278e370 (rcu_read_lock){....}-{1:2}, at: debug_show_all_locks+0x50/0x248     [  243.684114][  T123] 4 locks held by stress.sh/4365:     [  243.684119][  T123]  #0: c00000003a4cd3f8 (sb_writers#3){.+.+}-{0:0}, at: ksys_write+0x88/0x150     [  243.684132][  T123]  #1: c000000041aea888 (&of->mutex#2){+.+.}-{3:3}, at: kernfs_fop_write_iter+0x154/0x2d0     [  243.684143][  T123]  #2: c0000000366fb9a8 (kn->active#64){.+.+}-{0:0}, at: kernfs_fop_write_iter+0x160/0x2d0     [  243.684155][  T123]  #3: c000000035ff4cb8 (&dev->lock){+.+.}-{3:3}, at: napi_enable+0x30/0x60     [  243.684166][  T123] 5 locks held by stress.sh/4366:     [  243.684170][  T123]  #0: c00000003a4cd3f8 (sb_writers#3){.+.+}-{0:0}, at: ksys_write+0x88/0x150     [  243. ---truncated---",Race condition - Improper usage of synchronization primitives,Failure to release CPU,FALSE,#N/A,"Hang caused by race, patch introduced locks.",
CVE-2025-21681,https://www.cve.org/CVERecord?id=CVE-2025-21681,Linux,"openvswitch: fix lockup on tx to unregistering netdev with carrier  Commit in a fixes tag attempted to fix the issue in the following sequence of calls:      do_output     -> ovs_vport_send        -> dev_queue_xmit           -> __dev_queue_xmit              -> netdev_core_pick_tx                 -> skb_tx_hash  When device is unregistering, the 'dev->real_num_tx_queues' goes to zero and the 'while (unlikely(hash >= qcount))' loop inside the 'skb_tx_hash' becomes infinite, locking up the core forever.  But unfortunately, checking just the carrier status is not enough to fix the issue, because some devices may still be in unregistering state while reporting carrier status OK.  One example of such device is a net/dummy.  It sets carrier ON on start, but it doesn't implement .ndo_stop to set the carrier off. And it makes sense, because dummy doesn't really have a carrier. Therefore, while this device is unregistering, it's still easy to hit the infinite loop in the skb_tx_hash() from the OVS datapath.  There might be other drivers that do the same, but dummy by itself is important for the OVS ecosystem, because it is frequently used as a packet sink for tcpdump while debugging OVS deployments.  And when the issue is hit, the only way to recover is to reboot.  Fix that by also checking if the device is running.  The running state is handled by the net core during unregistering, so it covers unregistering case better, and we don't really need to send packets to devices that are not running anyway.  While only checking the running state might be enough, the carrier check is preserved.  The running and the carrier states seem disjoined throughout the code and different drivers.  And other core functions like __dev_direct_xmit() check both before attempting to transmit a packet.  So, it seems safer to check both flags in OVS as well.",Semantic - Loop termination,Failure to release CPU,FALSE,#N/A,"Incorrect assumption about device state, can lead to infinite loop. Fix by checking device state explicitly.",
CVE-2025-23154,https://www.cve.org/CVERecord?id=CVE-2025-23154,Linux,"io_uring/net: fix io_req_post_cqe abuse by send bundle  [  114.987980][ T5313] WARNING: CPU: 6 PID: 5313 at io_uring/io_uring.c:872 io_req_post_cqe+0x12e/0x4f0 [  114.991597][ T5313] RIP: 0010:io_req_post_cqe+0x12e/0x4f0 [  115.001880][ T5313] Call Trace: [  115.002222][ T5313]  <TASK> [  115.007813][ T5313]  io_send+0x4fe/0x10f0 [  115.009317][ T5313]  io_issue_sqe+0x1a6/0x1740 [  115.012094][ T5313]  io_wq_submit_work+0x38b/0xed0 [  115.013223][ T5313]  io_worker_handle_work+0x62a/0x1600 [  115.013876][ T5313]  io_wq_worker+0x34f/0xdf0  As the comment states, io_req_post_cqe() should only be used by multishot requests, i.e. REQ_F_APOLL_MULTISHOT, which bundled sends are not. Add a flag signifying whether a request wants to post multiple CQEs. Eventually REQ_F_APOLL_MULTISHOT should imply the new flag, but that's left out for simplicity.",Semantic - Logic error,High level spec violation,FALSE,#N/A,warning again ,
CVE-2025-23145,https://www.cve.org/CVERecord?id=CVE-2025-23145,Linux,"mptcp: fix NULL pointer in can_accept_new_subflow  When testing valkey benchmark tool with MPTCP, the kernel panics in 'mptcp_can_accept_new_subflow' because subflow_req->msk is NULL.  Call trace:    mptcp_can_accept_new_subflow (./net/mptcp/subflow.c:63 (discriminator 4)) (P)   subflow_syn_recv_sock (./net/mptcp/subflow.c:854)   tcp_check_req (./net/ipv4/tcp_minisocks.c:863)   tcp_v4_rcv (./net/ipv4/tcp_ipv4.c:2268)   ip_protocol_deliver_rcu (./net/ipv4/ip_input.c:207)   ip_local_deliver_finish (./net/ipv4/ip_input.c:234)   ip_local_deliver (./net/ipv4/ip_input.c:254)   ip_rcv_finish (./net/ipv4/ip_input.c:449)   ...  According to the debug log, the same req received two SYN-ACK in a very short time, very likely because the client retransmits the syn ack due to multiple reasons.  Even if the packets are transmitted with a relevant time interval, they can be processed by the server on different CPUs concurrently). The 'subflow_req->msk' ownership is transferred to the subflow the first, and there will be a risk of a null pointer dereference here.  This patch fixes this issue by moving the 'subflow_req->msk' under the `own_req == true` conditional.  Note that the !msk check in subflow_hmac_valid() can be dropped, because the same check already exists under the own_req mpj branch where the code has been moved to.",Race condition - TOUTOC,Invalid pointer dereference,TRUE,#N/A,Code that requires ownership to execute was reachable outside ownership check. Leading to possible null ptr deref due to racing that shouldn't be able to happen,
CVE-2025-21971,https://www.cve.org/CVERecord?id=CVE-2025-21971,Linux,"net_sched: Prevent creation of classes with TC_H_ROOT  The function qdisc_tree_reduce_backlog() uses TC_H_ROOT as a termination condition when traversing up the qdisc tree to update parent backlog counters. However, if a class is created with classid TC_H_ROOT, the traversal terminates prematurely at this class instead of reaching the actual root qdisc, causing parent statistics to be incorrectly maintained. In case of DRR, this could lead to a crash as reported by Mingi Cho.  Prevent the creation of any Qdisc class with classid TC_H_ROOT (0xFFFFFFFF) across all qdisc types, as suggested by Jamal.",Semantic - Spec error,High level spec violation,FALSE,#N/A,Patch changes spec to not allow certain classes to be created,
CVE-2025-21978,https://www.cve.org/CVERecord?id=CVE-2025-21978,Linux,"drm/hyperv: Fix address space leak when Hyper-V DRM device is removed  When a Hyper-V DRM device is probed, the driver allocates MMIO space for the vram, and maps it cacheable. If the device removed, or in the error path for device probing, the MMIO space is released but no unmap is done. Consequently the kernel address space for the mapping is leaked.  Fix this by adding iounmap() calls in the device removal path, and in the error path during device probing.",Language - Lifetime violation,Resource leak,FALSE,#N/A,,
CVE-2025-21873,https://www.cve.org/CVERecord?id=CVE-2025-21873,Linux,"scsi: ufs: core: bsg: Fix crash when arpmb command fails  If the device doesn't support arpmb we'll crash due to copying user data in bsg_transport_sg_io_fn().  In the case where ufs_bsg_exec_advanced_rpmb_req() returns an error, do not set the job's reply_len.  Memory crash backtrace: 3,1290,531166405,-;ufshcd 0000:00:12.5: ARPMB OP failed: error code -22  4,1308,531166555,-;Call Trace:  4,1309,531166559,-; <TASK>  4,1310,531166565,-; ? show_regs+0x6d/0x80  4,1311,531166575,-; ? die+0x37/0xa0  4,1312,531166583,-; ? do_trap+0xd4/0xf0  4,1313,531166593,-; ? do_error_trap+0x71/0xb0  4,1314,531166601,-; ? usercopy_abort+0x6c/0x80  4,1315,531166610,-; ? exc_invalid_op+0x52/0x80  4,1316,531166622,-; ? usercopy_abort+0x6c/0x80  4,1317,531166630,-; ? asm_exc_invalid_op+0x1b/0x20  4,1318,531166643,-; ? usercopy_abort+0x6c/0x80  4,1319,531166652,-; __check_heap_object+0xe3/0x120  4,1320,531166661,-; check_heap_object+0x185/0x1d0  4,1321,531166670,-; __check_object_size.part.0+0x72/0x150  4,1322,531166679,-; __check_object_size+0x23/0x30  4,1323,531166688,-; bsg_transport_sg_io_fn+0x314/0x3b0",Semantic - Logic error,OOB access,TRUE,#N/A,,
CVE-2025-37782,https://www.cve.org/CVERecord?id=CVE-2025-37782,Linux,"hfs/hfsplus: fix slab-out-of-bounds in hfs_bnode_read_key  Syzbot reported an issue in hfs subsystem:  BUG: KASAN: slab-out-of-bounds in memcpy_from_page include/linux/highmem.h:423 [inline] BUG: KASAN: slab-out-of-bounds in hfs_bnode_read fs/hfs/bnode.c:35 [inline] BUG: KASAN: slab-out-of-bounds in hfs_bnode_read_key+0x314/0x450 fs/hfs/bnode.c:70 Write of size 94 at addr ffff8880123cd100 by task syz-executor237/5102  Call Trace:  <TASK>  __dump_stack lib/dump_stack.c:94 [inline]  dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120  print_address_description mm/kasan/report.c:377 [inline]  print_report+0x169/0x550 mm/kasan/report.c:488  kasan_report+0x143/0x180 mm/kasan/report.c:601  kasan_check_range+0x282/0x290 mm/kasan/generic.c:189  __asan_memcpy+0x40/0x70 mm/kasan/shadow.c:106  memcpy_from_page include/linux/highmem.h:423 [inline]  hfs_bnode_read fs/hfs/bnode.c:35 [inline]  hfs_bnode_read_key+0x314/0x450 fs/hfs/bnode.c:70  hfs_brec_insert+0x7f3/0xbd0 fs/hfs/brec.c:159  hfs_cat_create+0x41d/0xa50 fs/hfs/catalog.c:118  hfs_mkdir+0x6c/0xe0 fs/hfs/dir.c:232  vfs_mkdir+0x2f9/0x4f0 fs/namei.c:4257  do_mkdirat+0x264/0x3a0 fs/namei.c:4280  __do_sys_mkdir fs/namei.c:4300 [inline]  __se_sys_mkdir fs/namei.c:4298 [inline]  __x64_sys_mkdir+0x6c/0x80 fs/namei.c:4298  do_syscall_x64 arch/x86/entry/common.c:52 [inline]  do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83  entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7fbdd6057a99  Add a check for key length in hfs_bnode_read_key to prevent out-of-bounds memory access. If the key length is invalid, the key buffer is cleared, improving stability and reliability.",Semantic - Improper input validation,OOB access,TRUE,#N/A,,
CVE-2025-21919,https://www.cve.org/CVERecord?id=CVE-2025-21919,Linux,"sched/fair: Fix potential memory corruption in child_cfs_rq_on_list  child_cfs_rq_on_list attempts to convert a 'prev' pointer to a cfs_rq. This 'prev' pointer can originate from struct rq's leaf_cfs_rq_list, making the conversion invalid and potentially leading to memory corruption. Depending on the relative positions of leaf_cfs_rq_list and the task group (tg) pointer within the struct, this can cause a memory fault or access garbage data.  The issue arises in list_add_leaf_cfs_rq, where both cfs_rq->leaf_cfs_rq_list and rq->leaf_cfs_rq_list are added to the same leaf list. Also, rq->tmp_alone_branch can be set to rq->leaf_cfs_rq_list.  This adds a check `if (prev == &rq->leaf_cfs_rq_list)` after the main conditional in child_cfs_rq_on_list. This ensures that the container_of operation will convert a correct cfs_rq struct.  This check is sufficient because only cfs_rqs on the same CPU are added to the list, so verifying the 'prev' pointer against the current rq's list head is enough.  Fixes a potential memory corruption issue that due to current struct layout might not be manifesting as a crash but could lead to unpredictable behavior when the layout changes.",Semantic - Logic error,OOB access,TRUE,#N/A,,
CVE-2025-37744,https://www.cve.org/CVERecord?id=CVE-2025-37744,Linux,"wifi: ath12k: fix memory leak in ath12k_pci_remove()  Kmemleak reported this error:    unreferenced object 0xffff1c165cec3060 (size 32):     comm ""insmod"", pid 560, jiffies 4296964570 (age 235.596s)     backtrace:       [<000000005434db68>] __kmem_cache_alloc_node+0x1f4/0x2c0       [<000000001203b155>] kmalloc_trace+0x40/0x88       [<0000000028adc9c8>] _request_firmware+0xb8/0x608       [<00000000cad1aef7>] firmware_request_nowarn+0x50/0x80       [<000000005011a682>] local_pci_probe+0x48/0xd0       [<00000000077cd295>] pci_device_probe+0xb4/0x200       [<0000000087184c94>] really_probe+0x150/0x2c0  The firmware memory was allocated in ath12k_pci_probe(), but not freed in ath12k_pci_remove() in case ATH12K_FLAG_QMI_FAIL bit is set. So call ath12k_fw_unmap() to free the memory.  Tested-on: WCN7850 hw2.0 PCI WLAN.HMT.2.0-02280-QCAHMTSWPL_V1.0_V2.0_SILICONZ-1",Language - Lifetime violation,Resource leak,FALSE,#N/A,,
CVE-2025-21974,https://www.cve.org/CVERecord?id=CVE-2025-21974,Linux,"eth: bnxt: return fail if interface is down in bnxt_queue_mem_alloc()  The bnxt_queue_mem_alloc() is called to allocate new queue memory when a queue is restarted. It internally accesses rx buffer descriptor corresponding to the index. The rx buffer descriptor is allocated and set when the interface is up and it's freed when the interface is down. So, if queue is restarted if interface is down, kernel panic occurs.  Splat looks like:  BUG: unable to handle page fault for address: 000000000000b240  #PF: supervisor read access in kernel mode  #PF: error_code(0x0000) - not-present page  PGD 0 P4D 0  Oops: Oops: 0000 [#1] PREEMPT SMP NOPTI  CPU: 3 UID: 0 PID: 1563 Comm: ncdevmem2 Not tainted 6.14.0-rc2+ #9 844ddba6e7c459cafd0bf4db9a3198e  Hardware name: ASUS System Product Name/PRIME Z690-P D4, BIOS 0603 11/01/2021  RIP: 0010:bnxt_queue_mem_alloc+0x3f/0x4e0 [bnxt_en]  Code: 41 54 4d 89 c4 4d 69 c0 c0 05 00 00 55 48 89 f5 53 48 89 fb 4c 8d b5 40 05 00 00 48 83 ec 15  RSP: 0018:ffff9dcc83fef9e8 EFLAGS: 00010202  RAX: ffffffffc0457720 RBX: ffff934ed8d40000 RCX: 0000000000000000  RDX: 000000000000001f RSI: ffff934ea508f800 RDI: ffff934ea508f808  RBP: ffff934ea508f800 R08: 000000000000b240 R09: ffff934e84f4b000  R10: ffff9dcc83fefa30 R11: ffff934e84f4b000 R12: 000000000000001f  R13: ffff934ed8d40ac0 R14: ffff934ea508fd40 R15: ffff934e84f4b000  FS:  00007fa73888c740(0000) GS:ffff93559f780000(0000) knlGS:0000000000000000  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033  CR2: 000000000000b240 CR3: 0000000145a2e000 CR4: 00000000007506f0  PKRU: 55555554  Call Trace:   <TASK>   ? __die+0x20/0x70   ? page_fault_oops+0x15a/0x460   ? exc_page_fault+0x6e/0x180   ? asm_exc_page_fault+0x22/0x30   ? __pfx_bnxt_queue_mem_alloc+0x10/0x10 [bnxt_en 7f85e76f4d724ba07471d7e39d9e773aea6597b7]   ? bnxt_queue_mem_alloc+0x3f/0x4e0 [bnxt_en 7f85e76f4d724ba07471d7e39d9e773aea6597b7]   netdev_rx_queue_restart+0xc5/0x240   net_devmem_bind_dmabuf_to_queue+0xf8/0x200   netdev_nl_bind_rx_doit+0x3a7/0x450   genl_family_rcv_msg_doit+0xd9/0x130   genl_rcv_msg+0x184/0x2b0   ? __pfx_netdev_nl_bind_rx_doit+0x10/0x10   ? __pfx_genl_rcv_msg+0x10/0x10   netlink_rcv_skb+0x54/0x100   genl_rcv+0x24/0x40 ...",Semantic - Improper input validation,Invalid pointer dereference,TRUE,#N/A,"failt to check null pointer, null pointer derefrence",
CVE-2025-22077,https://www.cve.org/CVERecord?id=CVE-2025-22077,Linux,"Revert ""smb: client: fix TCP timers deadlock after rmmod""  This reverts commit e9f2517a3e18a54a3943c098d2226b245d488801.  Commit e9f2517a3e18 (""smb: client: fix TCP timers deadlock after rmmod"") is intended to fix a null-ptr-deref in LOCKDEP, which is mentioned as CVE-2024-54680, but is actually did not fix anything; The issue can be reproduced on top of it. [0]  Also, it reverted the change by commit ef7134c7fc48 (""smb: client: Fix use-after-free of network namespace."") and introduced a real issue by reviving the kernel TCP socket.  When a reconnect happens for a CIFS connection, the socket state transitions to FIN_WAIT_1.  Then, inet_csk_clear_xmit_timers_sync() in tcp_close() stops all timers for the socket.  If an incoming FIN packet is lost, the socket will stay at FIN_WAIT_1 forever, and such sockets could be leaked up to net.ipv4.tcp_max_orphans.  Usually, FIN can be retransmitted by the peer, but if the peer aborts the connection, the issue comes into reality.  I warned about this privately by pointing out the exact report [1], but the bogus fix was finally merged.  So, we should not stop the timers to finally kill the connection on our side in that case, meaning we must not use a kernel socket for TCP whose sk->sk_net_refcnt is 0.  The kernel socket does not have a reference to its netns to make it possible to tear down netns without cleaning up every resource in it.  For example, tunnel devices use a UDP socket internally, but we can destroy netns without removing such devices and let it complete during exit.  Otherwise, netns would be leaked when the last application died.  However, this is problematic for TCP sockets because TCP has timers to close the connection gracefully even after the socket is close()d.  The lifetime of the socket and its netns is different from the lifetime of the underlying connection.  If the socket user does not maintain the netns lifetime, the timer could be fired after the socket is close()d and its netns is freed up, resulting in use-after-free.  Actually, we have seen so many similar issues and converted such sockets to have a reference to netns.  That's why I converted the CIFS client socket to have a reference to netns (sk->sk_net_refcnt == 1), which is somehow mentioned as out-of-scope of CIFS and technically wrong in e9f2517a3e18, but **is in-scope and right fix**.  Regarding the LOCKDEP issue, we can prevent the module unload by bumping the module refcount when switching the LOCKDDEP key in sock_lock_init_class_and_name(). [2]  For a while, let's revert the bogus fix.  Note that now we can use sk_net_refcnt_upgrade() for the socket conversion, but I'll do so later separately to make backport easy.",Semantic - Spec error,Resource leak,FALSE,#N/A,Spec error allows TCP sockets to get stuck in FIN_WAIT_1 status.,
CVE-2025-22098,https://www.cve.org/CVERecord?id=CVE-2025-22098,Linux,"drm: zynqmp_dp: Fix a deadlock in zynqmp_dp_ignore_hpd_set()  Instead of attempting the same mutex twice, lock and unlock it.  This bug has been detected by the Clang thread-safety analyzer.",Race condition - Improper usage of synchronization primitives,Failure to release CPU,FALSE,#N/A,"Accidentlly reacquired lock instead of releasing, immediate deadlock ",
CVE-2025-22071,https://www.cve.org/CVERecord?id=CVE-2025-22071,Linux,"spufs: fix a leak in spufs_create_context()  Leak fixes back in 2008 missed one case - if we are trying to set affinity and spufs_mkdir() fails, we need to drop the reference to neighbor.",Language - Lifetime violation,Resource leak,FALSE,#N/A,Didn't drop refrence in edge case,
CVE-2025-21847,https://www.cve.org/CVERecord?id=CVE-2025-21847,Linux,ASoC: SOF: stream-ipc: Check for cstream nullity in sof_ipc_msg_data()  The nullity of sps->cstream should be checked similarly as it is done in sof_set_stream_data_offset() function. Assuming that it is not NULL if sps->stream is NULL is incorrect and can lead to NULL pointer dereference.,Semantic - Improper input validation,Invalid pointer dereference,TRUE,#N/A,"Didn't check for null field, leading to potential null ptr deref",
CVE-2025-37783,https://www.cve.org/CVERecord?id=CVE-2025-37783,Linux,"drm/msm/dpu: Fix error pointers in dpu_plane_virtual_atomic_check  The function dpu_plane_virtual_atomic_check was dereferencing pointers returned by drm_atomic_get_plane_state without checking for errors. This could lead to undefined behavior if the function returns an error pointer.  This commit adds checks using IS_ERR to ensure that plane_state is valid before dereferencing them.  Similar to commit da29abe71e16 (""drm/amd/display: Fix error pointers in amdgpu_dm_crtc_mem_type_changed"").  Patchwork: https://patchwork.freedesktop.org/patch/643132/",Semantic - Missing return value check,Invalid pointer dereference,TRUE,#N/A,Didn't check return for possible error pointer,
CVE-2025-21774,https://www.cve.org/CVERecord?id=CVE-2025-21774,Linux,can: rockchip: rkcanfd_handle_rx_fifo_overflow_int(): bail out if skb cannot be allocated  Fix NULL pointer check in rkcanfd_handle_rx_fifo_overflow_int() to bail out if skb cannot be allocated.,Semantic - Logic error,Invalid pointer dereference,TRUE,#N/A,"Forgot the ! in null check, ie, if(!null) was if(null)",
CVE-2025-21672,https://www.cve.org/CVERecord?id=CVE-2025-21672,Linux,"afs: Fix merge preference rule failure condition  syzbot reported a lock held when returning to userspace[1].  This is because if argc is less than 0 and the function returns directly, the held inode lock is not released.  Fix this by store the error in ret and jump to done to clean up instead of returning directly.  [dh: Modified Lizhi Xu's original patch to make it honour the error code from afs_split_string()]  [1] WARNING: lock held when returning to user space! 6.13.0-rc3-syzkaller-00209-g499551201b5f #0 Not tainted ------------------------------------------------ syz-executor133/5823 is leaving the kernel with locks still held! 1 lock held by syz-executor133/5823:  #0: ffff888071cffc00 (&sb->s_type->i_mutex_key#9){++++}-{4:4}, at: inode_lock include/linux/fs.h:818 [inline]  #0: ffff888071cffc00 (&sb->s_type->i_mutex_key#9){++++}-{4:4}, at: afs_proc_addr_prefs_write+0x2bb/0x14e0 fs/afs/addr_prefs.c:388",Race condition - Improper usage of synchronization primitives,Failure to release CPU,FALSE,#N/A,Failure to release lock in some return path. Potential deadlock,
CVE-2025-21632,https://www.cve.org/CVERecord?id=CVE-2025-21632,Linux,"x86/fpu: Ensure shadow stack is active before ""getting"" registers  The x86 shadow stack support has its own set of registers. Those registers are XSAVE-managed, but they are ""supervisor state components"" which means that userspace can not touch them with XSAVE/XRSTOR.  It also means that they are not accessible from the existing ptrace ABI for XSAVE state. Thus, there is a new ptrace get/set interface for it.  The regset code that ptrace uses provides an ->active() handler in addition to the get/set ones. For shadow stack this ->active() handler verifies that shadow stack is enabled via the ARCH_SHSTK_SHSTK bit in the thread struct. The ->active() handler is checked from some call sites of the regset get/set handlers, but not the ptrace ones. This was not understood when shadow stack support was put in place.  As a result, both the set/get handlers can be called with XFEATURE_CET_USER in its init state, which would cause get_xsave_addr() to return NULL and trigger a WARN_ON(). The ssp_set() handler luckily has an ssp_active() check to avoid surprising the kernel with shadow stack behavior when the kernel is not ready for it (ARCH_SHSTK_SHSTK==0). That check just happened to avoid the warning.  But the ->get() side wasn't so lucky. It can be called with shadow stacks disabled, triggering the warning in practice, as reported by Christina Schimpe:  WARNING: CPU: 5 PID: 1773 at arch/x86/kernel/fpu/regset.c:198 ssp_get+0x89/0xa0 [...] Call Trace: <TASK> ? show_regs+0x6e/0x80 ? ssp_get+0x89/0xa0 ? __warn+0x91/0x150 ? ssp_get+0x89/0xa0 ? report_bug+0x19d/0x1b0 ? handle_bug+0x46/0x80 ? exc_invalid_op+0x1d/0x80 ? asm_exc_invalid_op+0x1f/0x30 ? __pfx_ssp_get+0x10/0x10 ? ssp_get+0x89/0xa0 ? ssp_get+0x52/0xa0 __regset_get+0xad/0xf0 copy_regset_to_user+0x52/0xc0 ptrace_regset+0x119/0x140 ptrace_request+0x13c/0x850 ? wait_task_inactive+0x142/0x1d0 ? do_syscall_64+0x6d/0x90 arch_ptrace+0x102/0x300 [...]  Ensure that shadow stacks are active in a thread before looking them up in the XSAVE buffer. Since ARCH_SHSTK_SHSTK and user_ssp[SHSTK_EN] are set at the same time, the active check ensures that there will be something to find in the XSAVE buffer.  [ dhansen: changelog/subject tweaks ]",Semantic - Spec error,High level spec violation,FALSE,#N/A,Spec error allowed to query shadow stack when not active.,
CVE-2025-23153,https://www.cve.org/CVERecord?id=CVE-2025-23153,Linux,arm/crc-t10dif: fix use of out-of-scope array in crc_t10dif_arch()  Fix a silly bug where an array was used outside of its scope.,Language - Lifetime violation,Use after free,TRUE,#N/A,Local buffer used after it's lifetime scope.,
CVE-2025-21948,https://www.cve.org/CVERecord?id=CVE-2025-21948,Linux,"HID: appleir: Fix potential NULL dereference at raw event handle  Syzkaller reports a NULL pointer dereference issue in input_event().  BUG: KASAN: null-ptr-deref in instrument_atomic_read include/linux/instrumented.h:68 [inline] BUG: KASAN: null-ptr-deref in _test_bit include/asm-generic/bitops/instrumented-non-atomic.h:141 [inline] BUG: KASAN: null-ptr-deref in is_event_supported drivers/input/input.c:67 [inline] BUG: KASAN: null-ptr-deref in input_event+0x42/0xa0 drivers/input/input.c:395 Read of size 8 at addr 0000000000000028 by task syz-executor199/2949  CPU: 0 UID: 0 PID: 2949 Comm: syz-executor199 Not tainted 6.13.0-rc4-syzkaller-00076-gf097a36ef88d #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 Call Trace:  <IRQ>  __dump_stack lib/dump_stack.c:94 [inline]  dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120  kasan_report+0xd9/0x110 mm/kasan/report.c:602  check_region_inline mm/kasan/generic.c:183 [inline]  kasan_check_range+0xef/0x1a0 mm/kasan/generic.c:189  instrument_atomic_read include/linux/instrumented.h:68 [inline]  _test_bit include/asm-generic/bitops/instrumented-non-atomic.h:141 [inline]  is_event_supported drivers/input/input.c:67 [inline]  input_event+0x42/0xa0 drivers/input/input.c:395  input_report_key include/linux/input.h:439 [inline]  key_down drivers/hid/hid-appleir.c:159 [inline]  appleir_raw_event+0x3e5/0x5e0 drivers/hid/hid-appleir.c:232  __hid_input_report.constprop.0+0x312/0x440 drivers/hid/hid-core.c:2111  hid_ctrl+0x49f/0x550 drivers/hid/usbhid/hid-core.c:484  __usb_hcd_giveback_urb+0x389/0x6e0 drivers/usb/core/hcd.c:1650  usb_hcd_giveback_urb+0x396/0x450 drivers/usb/core/hcd.c:1734  dummy_timer+0x17f7/0x3960 drivers/usb/gadget/udc/dummy_hcd.c:1993  __run_hrtimer kernel/time/hrtimer.c:1739 [inline]  __hrtimer_run_queues+0x20a/0xae0 kernel/time/hrtimer.c:1803  hrtimer_run_softirq+0x17d/0x350 kernel/time/hrtimer.c:1820  handle_softirqs+0x206/0x8d0 kernel/softirq.c:561  __do_softirq kernel/softirq.c:595 [inline]  invoke_softirq kernel/softirq.c:435 [inline]  __irq_exit_rcu+0xfa/0x160 kernel/softirq.c:662  irq_exit_rcu+0x9/0x30 kernel/softirq.c:678  instr_sysvec_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1049 [inline]  sysvec_apic_timer_interrupt+0x90/0xb0 arch/x86/kernel/apic/apic.c:1049  </IRQ>  <TASK>  asm_sysvec_apic_timer_interrupt+0x1a/0x20 arch/x86/include/asm/idtentry.h:702  __mod_timer+0x8f6/0xdc0 kernel/time/timer.c:1185  add_timer+0x62/0x90 kernel/time/timer.c:1295  schedule_timeout+0x11f/0x280 kernel/time/sleep_timeout.c:98  usbhid_wait_io+0x1c7/0x380 drivers/hid/usbhid/hid-core.c:645  usbhid_init_reports+0x19f/0x390 drivers/hid/usbhid/hid-core.c:784  hiddev_ioctl+0x1133/0x15b0 drivers/hid/usbhid/hiddev.c:794  vfs_ioctl fs/ioctl.c:51 [inline]  __do_sys_ioctl fs/ioctl.c:906 [inline]  __se_sys_ioctl fs/ioctl.c:892 [inline]  __x64_sys_ioctl+0x190/0x200 fs/ioctl.c:892  do_syscall_x64 arch/x86/entry/common.c:52 [inline]  do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83  entry_SYSCALL_64_after_hwframe+0x77/0x7f  </TASK>  This happens due to the malformed report items sent by the emulated device which results in a report, that has no fields, being added to the report list. Due to this appleir_input_configured() is never called, hidinput_connect() fails which results in the HID_CLAIMED_INPUT flag is not being set. However, it  does not make appleir_probe() fail and lets the event callback to be called without the associated input device.  Thus, add a check for the HID_CLAIMED_INPUT flag and leave the event hook early if the driver didn't claim any input_dev for some reason. Moreover, some other hid drivers accessing input_dev in their event callbacks do have similar checks, too.  Found by Linux Verification Center (linuxtesting.org) with Syzkaller.",Semantic - Improper input validation,Invalid pointer dereference,TRUE,#N/A,"Malformed input report allowed event with no associated device to be processed, leading to null ptr deref. Fixed by checking report is valid before continuing.",
CVE-2025-22035,https://www.cve.org/CVERecord?id=CVE-2025-22035,Linux,"tracing: Fix use-after-free in print_graph_function_flags during tracer switching  Kairui reported a UAF issue in print_graph_function_flags() during ftrace stress testing [1]. This issue can be reproduced if puting a 'mdelay(10)' after 'mutex_unlock(&trace_types_lock)' in s_start(), and executing the following script:    $ echo function_graph > current_tracer   $ cat trace > /dev/null &   $ sleep 5  # Ensure the 'cat' reaches the 'mdelay(10)' point   $ echo timerlat > current_tracer  The root cause lies in the two calls to print_graph_function_flags within print_trace_line during each s_show():    * One through 'iter->trace->print_line()';   * Another through 'event->funcs->trace()', which is hidden in     print_trace_fmt() before print_trace_line returns.  Tracer switching only updates the former, while the latter continues to use the print_line function of the old tracer, which in the script above is print_graph_function_flags.  Moreover, when switching from the 'function_graph' tracer to the 'timerlat' tracer, s_start only calls graph_trace_close of the 'function_graph' tracer to free 'iter->private', but does not set it to NULL. This provides an opportunity for 'event->funcs->trace()' to use an invalid 'iter->private'.  To fix this issue, set 'iter->private' to NULL immediately after freeing it in graph_trace_close(), ensuring that an invalid pointer is not passed to other tracers. Additionally, clean up the unnecessary 'iter->private = NULL' during each 'cat trace' when using wakeup and irqsoff tracers.   [1] https://lore.kernel.org/all/20231112150030.84609-1-ryncsn@gmail.com/",Race condition - TOUTOC,Use after free,TRUE,#N/A,"When freeing a pointer, the field that refrences it isn't set to null. Leading to potential UAF.",
CVE-2025-23162,https://www.cve.org/CVERecord?id=CVE-2025-23162,Linux,drm/xe/vf: Don't try to trigger a full GT reset if VF  VFs don't have access to the GDRST(0x941c) register that driver uses to reset a GT. Attempt to trigger a reset using debugfs:   $ cat /sys/kernel/debug/dri/0000:00:02.1/gt0/force_reset  or due to a hang condition detected by the driver leads to:   [ ] xe 0000:00:02.1: [drm] GT0: trying reset from force_reset [xe]  [ ] xe 0000:00:02.1: [drm] GT0: reset queued  [ ] xe 0000:00:02.1: [drm] GT0: reset started  [ ] ------------[ cut here ]------------  [ ] xe 0000:00:02.1: [drm] GT0: VF is trying to write 0x1 to an inaccessible register 0x941c+0x0  [ ] WARNING: CPU: 3 PID: 3069 at drivers/gpu/drm/xe/xe_gt_sriov_vf.c:996 xe_gt_sriov_vf_write32+0xc6/0x580 [xe]  [ ] RIP: 0010:xe_gt_sriov_vf_write32+0xc6/0x580 [xe]  [ ] Call Trace:  [ ]  <TASK>  [ ]  ? show_regs+0x6c/0x80  [ ]  ? __warn+0x93/0x1c0  [ ]  ? xe_gt_sriov_vf_write32+0xc6/0x580 [xe]  [ ]  ? report_bug+0x182/0x1b0  [ ]  ? handle_bug+0x6e/0xb0  [ ]  ? exc_invalid_op+0x18/0x80  [ ]  ? asm_exc_invalid_op+0x1b/0x20  [ ]  ? xe_gt_sriov_vf_write32+0xc6/0x580 [xe]  [ ]  ? xe_gt_sriov_vf_write32+0xc6/0x580 [xe]  [ ]  ? xe_gt_tlb_invalidation_reset+0xef/0x110 [xe]  [ ]  ? __mutex_unlock_slowpath+0x41/0x2e0  [ ]  xe_mmio_write32+0x64/0x150 [xe]  [ ]  do_gt_reset+0x2f/0xa0 [xe]  [ ]  gt_reset_worker+0x14e/0x1e0 [xe]  [ ]  process_one_work+0x21c/0x740  [ ]  worker_thread+0x1db/0x3c0  Fix that by sending H2G VF_RESET(0x5507) action instead.,Semantic - Spec error,High level spec violation,FALSE,#N/A,"VF's were using register they don't have access too, in this case protections in place so access violation results in error",
CVE-2025-21712,https://www.cve.org/CVERecord?id=CVE-2025-21712,Linux,"md/md-bitmap: Synchronize bitmap_get_stats() with bitmap lifetime  After commit ec6bb299c7c3 (""md/md-bitmap: add 'sync_size' into struct md_bitmap_stats""), following panic is reported:  Oops: general protection fault, probably for non-canonical address RIP: 0010:bitmap_get_stats+0x2b/0xa0 Call Trace:  <TASK>  md_seq_show+0x2d2/0x5b0  seq_read_iter+0x2b9/0x470  seq_read+0x12f/0x180  proc_reg_read+0x57/0xb0  vfs_read+0xf6/0x380  ksys_read+0x6c/0xf0  do_syscall_64+0x82/0x170  entry_SYSCALL_64_after_hwframe+0x76/0x7e  Root cause is that bitmap_get_stats() can be called at anytime if mddev is still there, even if bitmap is destroyed, or not fully initialized. Deferenceing bitmap in this case can crash the kernel. Meanwhile, the above commit start to deferencing bitmap->storage, make the problem easier to trigger.  Fix the problem by protecting bitmap_get_stats() with bitmap_info.mutex.",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,#N/A,"Race due to missing mutex lock, allows null deref/UAF",
CVE-2025-21798,https://www.cve.org/CVERecord?id=CVE-2025-21798,Linux,"firewire: test: Fix potential null dereference in firewire kunit test  kunit_kzalloc() may return a NULL pointer, dereferencing it without NULL check may lead to NULL dereference. Add a NULL check for test_state.",Semantic - Missing return value check,Invalid pointer dereference,TRUE,#N/A,Mising return value check from allocator kunit_kzalloc().,
CVE-2025-21769,https://www.cve.org/CVERecord?id=CVE-2025-21769,Linux,"ptp: vmclock: Add .owner to vmclock_miscdev_fops  Without the .owner field, the module can be unloaded while /dev/vmclock0 is open, leading to an oops.",Language - Improper memory initialization,High level spec violation,FALSE,#N/A,"Forgot to register module ownership, leading to potential UAF.",
CVE-2025-21941,https://www.cve.org/CVERecord?id=CVE-2025-21941,Linux,drm/amd/display: Fix null check for pipe_ctx->plane_state in resource_build_scaling_params  Null pointer dereference issue could occur when pipe_ctx->plane_state is null. The fix adds a check to ensure 'pipe_ctx->plane_state' is not null before accessing. This prevents a null pointer dereference.  Found by code review.  (cherry picked from commit 63e6a77ccf239337baa9b1e7787cde9fa0462092),Semantic - Improper input validation,Invalid pointer dereference,TRUE,#N/A,Missing check for null,
CVE-2025-21815,https://www.cve.org/CVERecord?id=CVE-2025-21815,Linux,mm/compaction: fix UBSAN shift-out-of-bounds warning  syzkaller reported a UBSAN shift-out-of-bounds warning of (1UL << order) in isolate_freepages_block().  The bogus compound_order can be any value because it is union with flags.  Add back the MAX_PAGE_ORDER check to fix the warning.,Semantic - Improper input validation,OOB access,TRUE,#N/A,"Forgot to validate an edge case where a value could be corrupted due to union overlap with flags, potentially causing OOB access.",
CVE-2025-22123,https://www.cve.org/CVERecord?id=CVE-2025-22123,Linux,"f2fs: fix to avoid accessing uninitialized curseg  syzbot reports a f2fs bug as below:  F2FS-fs (loop3): Stopped filesystem due to reason: 7 kworker/u8:7: attempt to access beyond end of device BUG: unable to handle page fault for address: ffffed1604ea3dfa RIP: 0010:get_ckpt_valid_blocks fs/f2fs/segment.h:361 [inline] RIP: 0010:has_curseg_enough_space fs/f2fs/segment.h:570 [inline] RIP: 0010:__get_secs_required fs/f2fs/segment.h:620 [inline] RIP: 0010:has_not_enough_free_secs fs/f2fs/segment.h:633 [inline] RIP: 0010:has_enough_free_secs+0x575/0x1660 fs/f2fs/segment.h:649  <TASK>  f2fs_is_checkpoint_ready fs/f2fs/segment.h:671 [inline]  f2fs_write_inode+0x425/0x540 fs/f2fs/inode.c:791  write_inode fs/fs-writeback.c:1525 [inline]  __writeback_single_inode+0x708/0x10d0 fs/fs-writeback.c:1745  writeback_sb_inodes+0x820/0x1360 fs/fs-writeback.c:1976  wb_writeback+0x413/0xb80 fs/fs-writeback.c:2156  wb_do_writeback fs/fs-writeback.c:2303 [inline]  wb_workfn+0x410/0x1080 fs/fs-writeback.c:2343  process_one_work kernel/workqueue.c:3236 [inline]  process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3317  worker_thread+0x870/0xd30 kernel/workqueue.c:3398  kthread+0x7a9/0x920 kernel/kthread.c:464  ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:148  ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244  Commit 8b10d3653735 (""f2fs: introduce FAULT_NO_SEGMENT"") allows to trigger no free segment fault in allocator, then it will update curseg->segno to NULL_SEGNO, though, CP_ERROR_FLAG has been set, f2fs_write_inode() missed to check the flag, and access invalid curseg->segno directly in below call path, then resulting in panic:  - f2fs_write_inode  - f2fs_is_checkpoint_ready   - has_enough_free_secs    - has_not_enough_free_secs     - __get_secs_required      - has_curseg_enough_space       - get_ckpt_valid_blocks       : access invalid curseg->segno  To avoid this issue, let's: - check CP_ERROR_FLAG flag in prior to f2fs_is_checkpoint_ready() in f2fs_write_inode(). - in has_curseg_enough_space(), save curseg->segno into a temp variable, and verify its validation before use.",Semantic - Missing return value check,OOB access,TRUE,#N/A,"Didn't check if error flags were set previously, allows OOB access.",
CVE-2025-21965,https://www.cve.org/CVERecord?id=CVE-2025-21965,Linux,"sched_ext: Validate prev_cpu in scx_bpf_select_cpu_dfl()  If a BPF scheduler provides an invalid CPU (outside the nr_cpu_ids range) as prev_cpu to scx_bpf_select_cpu_dfl() it can cause a kernel crash.  To prevent this, validate prev_cpu in scx_bpf_select_cpu_dfl() and trigger an scx error if an invalid CPU is specified.",Semantic - Improper input validation,Explicit exception/panic,FALSE,#N/A,Missing check for valid cpu id can cause panic,
CVE-2025-22081,https://www.cve.org/CVERecord?id=CVE-2025-22081,Linux,"fs/ntfs3: Fix a couple integer overflows on 32bit systems  On 32bit systems the ""off + sizeof(struct NTFS_DE)"" addition can have an integer wrapping issue.  Fix it by using size_add().",Language - Integer overflow,OOB access,TRUE,#N/A,wrapping unsigned int when calculating index leads to inconsistent state. ,
CVE-2025-37785,https://www.cve.org/CVERecord?id=CVE-2025-37785,Linux,"ext4: fix OOB access when checking dotdot dir  Mounting a corrupted filesystem with directory which contains '.' dir entry with rec_len == block size results in out-of-bounds read (later on, when the corrupted directory is removed).  ext4_empty_dir() assumes every ext4 directory contains at least '.' and '..' as directory entries in the first data block. It first loads the '.' dir entry, performs sanity checks by calling ext4_check_dir_entry() and then uses its rec_len member to compute the location of '..' dir entry (in ext4_next_entry). It assumes the '..' dir entry fits into the same data block.  If the rec_len of '.' is precisely one block (4KB), it slips through the sanity checks (it is considered the last directory entry in the data block) and leaves ""struct ext4_dir_entry_2 *de"" point exactly past the memory slot allocated to the data block. The following call to ext4_check_dir_entry() on new value of de then dereferences this pointer which results in out-of-bounds mem access.  Fix this by extending __ext4_check_dir_entry() to check for '.' dir entries that reach the end of data block. Make sure to ignore the phony dir entries for checksum (by checking name_len for non-zero).  Note: This is reported by KASAN as use-after-free in case another structure was recently freed from the slot past the bound, but it is really an OOB access.  This issue was found by syzkaller tool.  Call Trace: [   38.594108] BUG: KASAN: slab-use-after-free in __ext4_check_dir_entry+0x67e/0x710 [   38.594649] Read of size 2 at addr ffff88802b41a004 by task syz-executor/5375 [   38.595158] [   38.595288] CPU: 0 UID: 0 PID: 5375 Comm: syz-executor Not tainted 6.14.0-rc7 #1 [   38.595298] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014 [   38.595304] Call Trace: [   38.595308]  <TASK> [   38.595311]  dump_stack_lvl+0xa7/0xd0 [   38.595325]  print_address_description.constprop.0+0x2c/0x3f0 [   38.595339]  ? __ext4_check_dir_entry+0x67e/0x710 [   38.595349]  print_report+0xaa/0x250 [   38.595359]  ? __ext4_check_dir_entry+0x67e/0x710 [   38.595368]  ? kasan_addr_to_slab+0x9/0x90 [   38.595378]  kasan_report+0xab/0xe0 [   38.595389]  ? __ext4_check_dir_entry+0x67e/0x710 [   38.595400]  __ext4_check_dir_entry+0x67e/0x710 [   38.595410]  ext4_empty_dir+0x465/0x990 [   38.595421]  ? __pfx_ext4_empty_dir+0x10/0x10 [   38.595432]  ext4_rmdir.part.0+0x29a/0xd10 [   38.595441]  ? __dquot_initialize+0x2a7/0xbf0 [   38.595455]  ? __pfx_ext4_rmdir.part.0+0x10/0x10 [   38.595464]  ? __pfx___dquot_initialize+0x10/0x10 [   38.595478]  ? down_write+0xdb/0x140 [   38.595487]  ? __pfx_down_write+0x10/0x10 [   38.595497]  ext4_rmdir+0xee/0x140 [   38.595506]  vfs_rmdir+0x209/0x670 [   38.595517]  ? lookup_one_qstr_excl+0x3b/0x190 [   38.595529]  do_rmdir+0x363/0x3c0 [   38.595537]  ? __pfx_do_rmdir+0x10/0x10 [   38.595544]  ? strncpy_from_user+0x1ff/0x2e0 [   38.595561]  __x64_sys_unlinkat+0xf0/0x130 [   38.595570]  do_syscall_64+0x5b/0x180 [   38.595583]  entry_SYSCALL_64_after_hwframe+0x76/0x7e",Semantic - Logic error,OOB access,TRUE,#N/A,Missing edge case in logic leads to OOB issues,
CVE-2025-21704,https://www.cve.org/CVERecord?id=CVE-2025-21704,Linux,"usb: cdc-acm: Check control transfer buffer size before access  If the first fragment is shorter than struct usb_cdc_notification, we can't calculate an expected_size. Log an error and discard the notification instead of reading lengths from memory outside the received data, which can lead to memory corruption when the expected_size decreases between fragments, causing `expected_size - acm->nb_index` to wrap.  This issue has been present since the beginning of git history; however, it only leads to memory corruption since commit ea2583529cd1 (""cdc-acm: reassemble fragmented notifications"").  A mitigating factor is that acm_ctrl_irq() can only execute after userspace has opened /dev/ttyACM*; but if ModemManager is running, ModemManager will do that automatically depending on the USB device's vendor/product IDs and its other interfaces.",Semantic - Improper input validation,OOB access,TRUE,#N/A,"lengths can wrap, leading to OOB issues, better input validation needed",
CVE-2025-21843,https://www.cve.org/CVERecord?id=CVE-2025-21843,Linux,"drm/panthor: avoid garbage value in panthor_ioctl_dev_query()  'priorities_info' is uninitialized, and the uninitialized value is copied to user object when calling PANTHOR_UOBJ_SET(). Using memset to initialize 'priorities_info' to avoid this garbage value problem.",Language - Improper memory initialization,Uninitialized memory access,FALSE,#N/A,memory isn't zeroed,
CVE-2025-21853,https://www.cve.org/CVERecord?id=CVE-2025-21853,Linux,"bpf: avoid holding freeze_mutex during mmap operation  We use map->freeze_mutex to prevent races between map_freeze() and memory mapping BPF map contents with writable permissions. The way we naively do this means we'll hold freeze_mutex for entire duration of all the mm and VMA manipulations, which is completely unnecessary. This can potentially also lead to deadlocks, as reported by syzbot in [0].  So, instead, hold freeze_mutex only during writeability checks, bump (proactively) ""write active"" count for the map, unlock the mutex and proceed with mmap logic. And only if something went wrong during mmap logic, then undo that ""write active"" counter increment.    [0] https://lore.kernel.org/bpf/678dcbc9.050a0220.303755.0066.GAE@google.com/",Semantic - Spec error,Failure to release CPU,FALSE,#N/A,"Original spec was too conservative with mutex lock, patch makes it more relaxed to free up resources",
CVE-2025-21858,https://www.cve.org/CVERecord?id=CVE-2025-21858,Linux,"geneve: Fix use-after-free in geneve_find_dev().  syzkaller reported a use-after-free in geneve_find_dev() [0] without repro.  geneve_configure() links struct geneve_dev.next to net_generic(net, geneve_net_id)->geneve_list.  The net here could differ from dev_net(dev) if IFLA_NET_NS_PID, IFLA_NET_NS_FD, or IFLA_TARGET_NETNSID is set.  When dev_net(dev) is dismantled, geneve_exit_batch_rtnl() finally calls unregister_netdevice_queue() for each dev in the netns, and later the dev is freed.  However, its geneve_dev.next is still linked to the backend UDP socket netns.  Then, use-after-free will occur when another geneve dev is created in the netns.  Let's call geneve_dellink() instead in geneve_destroy_tunnels().  [0]: BUG: KASAN: slab-use-after-free in geneve_find_dev drivers/net/geneve.c:1295 [inline] BUG: KASAN: slab-use-after-free in geneve_configure+0x234/0x858 drivers/net/geneve.c:1343 Read of size 2 at addr ffff000054d6ee24 by task syz.1.4029/13441  CPU: 1 UID: 0 PID: 13441 Comm: syz.1.4029 Not tainted 6.13.0-g0ad9617c78ac #24 dc35ca22c79fb82e8e7bc5c9c9adafea898b1e3d Hardware name: linux,dummy-virt (DT) Call trace:  show_stack+0x38/0x50 arch/arm64/kernel/stacktrace.c:466 (C)  __dump_stack lib/dump_stack.c:94 [inline]  dump_stack_lvl+0xbc/0x108 lib/dump_stack.c:120  print_address_description mm/kasan/report.c:378 [inline]  print_report+0x16c/0x6f0 mm/kasan/report.c:489  kasan_report+0xc0/0x120 mm/kasan/report.c:602  __asan_report_load2_noabort+0x20/0x30 mm/kasan/report_generic.c:379  geneve_find_dev drivers/net/geneve.c:1295 [inline]  geneve_configure+0x234/0x858 drivers/net/geneve.c:1343  geneve_newlink+0xb8/0x128 drivers/net/geneve.c:1634  rtnl_newlink_create+0x23c/0x868 net/core/rtnetlink.c:3795  __rtnl_newlink net/core/rtnetlink.c:3906 [inline]  rtnl_newlink+0x1054/0x1630 net/core/rtnetlink.c:4021  rtnetlink_rcv_msg+0x61c/0x918 net/core/rtnetlink.c:6911  netlink_rcv_skb+0x1dc/0x398 net/netlink/af_netlink.c:2543  rtnetlink_rcv+0x34/0x50 net/core/rtnetlink.c:6938  netlink_unicast_kernel net/netlink/af_netlink.c:1322 [inline]  netlink_unicast+0x618/0x838 net/netlink/af_netlink.c:1348  netlink_sendmsg+0x5fc/0x8b0 net/netlink/af_netlink.c:1892  sock_sendmsg_nosec net/socket.c:713 [inline]  __sock_sendmsg net/socket.c:728 [inline]  ____sys_sendmsg+0x410/0x6f8 net/socket.c:2568  ___sys_sendmsg+0x178/0x1d8 net/socket.c:2622  __sys_sendmsg net/socket.c:2654 [inline]  __do_sys_sendmsg net/socket.c:2659 [inline]  __se_sys_sendmsg net/socket.c:2657 [inline]  __arm64_sys_sendmsg+0x12c/0x1c8 net/socket.c:2657  __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline]  invoke_syscall+0x90/0x278 arch/arm64/kernel/syscall.c:49  el0_svc_common+0x13c/0x250 arch/arm64/kernel/syscall.c:132  do_el0_svc+0x54/0x70 arch/arm64/kernel/syscall.c:151  el0_svc+0x4c/0xa8 arch/arm64/kernel/entry-common.c:744  el0t_64_sync_handler+0x78/0x108 arch/arm64/kernel/entry-common.c:762  el0t_64_sync+0x198/0x1a0 arch/arm64/kernel/entry.S:600  Allocated by task 13247:  kasan_save_stack mm/kasan/common.c:47 [inline]  kasan_save_track+0x30/0x68 mm/kasan/common.c:68  kasan_save_alloc_info+0x44/0x58 mm/kasan/generic.c:568  poison_kmalloc_redzone mm/kasan/common.c:377 [inline]  __kasan_kmalloc+0x84/0xa0 mm/kasan/common.c:394  kasan_kmalloc include/linux/kasan.h:260 [inline]  __do_kmalloc_node mm/slub.c:4298 [inline]  __kmalloc_node_noprof+0x2a0/0x560 mm/slub.c:4304  __kvmalloc_node_noprof+0x9c/0x230 mm/util.c:645  alloc_netdev_mqs+0xb8/0x11a0 net/core/dev.c:11470  rtnl_create_link+0x2b8/0xb50 net/core/rtnetlink.c:3604  rtnl_newlink_create+0x19c/0x868 net/core/rtnetlink.c:3780  __rtnl_newlink net/core/rtnetlink.c:3906 [inline]  rtnl_newlink+0x1054/0x1630 net/core/rtnetlink.c:4021  rtnetlink_rcv_msg+0x61c/0x918 net/core/rtnetlink.c:6911  netlink_rcv_skb+0x1dc/0x398 net/netlink/af_netlink.c:2543  rtnetlink_rcv+0x34/0x50 net/core/rtnetlink.c:6938  netlink_unicast_kernel net/netlink/af_n ---truncated---",Language - Lifetime violation,Use after free,TRUE,#N/A,"Stale pointer left after cleanup, potential UAF",
CVE-2025-21736,https://www.cve.org/CVERecord?id=CVE-2025-21736,Linux,"nilfs2: fix possible int overflows in nilfs_fiemap()  Since nilfs_bmap_lookup_contig() in nilfs_fiemap() calculates its result by being prepared to go through potentially maxblocks == INT_MAX blocks, the value in n may experience an overflow caused by left shift of blkbits.  While it is extremely unlikely to occur, play it safe and cast right hand expression to wider type to mitigate the issue.  Found by Linux Verification Center (linuxtesting.org) with static analysis tool SVACE.",Language - Integer overflow,High level spec violation,FALSE,#N/A,"Address potential int overflow case, otherwise leaves system in logically inconsistent state on OF",
CVE-2025-21773,https://www.cve.org/CVERecord?id=CVE-2025-21773,Linux,"can: etas_es58x: fix potential NULL pointer dereference on udev->serial  The driver assumed that es58x_dev->udev->serial could never be NULL. While this is true on commercially available devices, an attacker could spoof the device identity providing a NULL USB serial number. That would trigger a NULL pointer dereference.  Add a check on es58x_dev->udev->serial before accessing it.",Semantic - Improper input validation,Invalid pointer dereference,TRUE,#N/A,Add null check for edge case.,
CVE-2025-22005,https://www.cve.org/CVERecord?id=CVE-2025-22005,Linux,"ipv6: Fix memleak of nhc_pcpu_rth_output in fib_check_nh_v6_gw().  fib_check_nh_v6_gw() expects that fib6_nh_init() cleans up everything when it fails.  Commit 7dd73168e273 (""ipv6: Always allocate pcpu memory in a fib6_nh"") moved fib_nh_common_init() before alloc_percpu_gfp() within fib6_nh_init() but forgot to add cleanup for fib6_nh->nh_common.nhc_pcpu_rth_output in case it fails to allocate fib6_nh->rt6i_pcpu, resulting in memleak.  Let's call fib_nh_common_release() and clear nhc_pcpu_rth_output in the error path.  Note that we can remove the fib6_nh_release() call in nh_create_ipv6() later in net-next.git.",Language - Lifetime violation,Resource leak,FALSE,#N/A,Memory leak due to missing free in error path,
CVE-2025-22074,https://www.cve.org/CVERecord?id=CVE-2025-22074,Linux,"ksmbd: fix r_count dec/increment mismatch  r_count is only increased when there is an oplock break wait, so r_count inc/decrement are not paired. This can cause r_count to become negative, which can lead to a problem where the ksmbd thread does not terminate.",Language - Lifetime violation,Failure to release CPU,FALSE,#N/A,Logic bug in ref counting causes thread to not terminate,
CVE-2025-21688,https://www.cve.org/CVERecord?id=CVE-2025-21688,Linux,"drm/v3d: Assign job pointer to NULL before signaling the fence  In commit e4b5ccd392b9 (""drm/v3d: Ensure job pointer is set to NULL after job completion""), we introduced a change to assign the job pointer to NULL after completing a job, indicating job completion.  However, this approach created a race condition between the DRM scheduler workqueue and the IRQ execution thread. As soon as the fence is signaled in the IRQ execution thread, a new job starts to be executed. This results in a race condition where the IRQ execution thread sets the job pointer to NULL simultaneously as the `run_job()` function assigns a new job to the pointer.  This race condition can lead to a NULL pointer dereference if the IRQ execution thread sets the job pointer to NULL after `run_job()` assigns it to the new job. When the new job completes and the GPU emits an interrupt, `v3d_irq()` is triggered, potentially causing a crash.  [  466.310099] Unable to handle kernel NULL pointer dereference at virtual address 00000000000000c0 [  466.318928] Mem abort info: [  466.321723]   ESR = 0x0000000096000005 [  466.325479]   EC = 0x25: DABT (current EL), IL = 32 bits [  466.330807]   SET = 0, FnV = 0 [  466.333864]   EA = 0, S1PTW = 0 [  466.337010]   FSC = 0x05: level 1 translation fault [  466.341900] Data abort info: [  466.344783]   ISV = 0, ISS = 0x00000005, ISS2 = 0x00000000 [  466.350285]   CM = 0, WnR = 0, TnD = 0, TagAccess = 0 [  466.355350]   GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0 [  466.360677] user pgtable: 4k pages, 39-bit VAs, pgdp=0000000089772000 [  466.367140] [00000000000000c0] pgd=0000000000000000, p4d=0000000000000000, pud=0000000000000000 [  466.375875] Internal error: Oops: 0000000096000005 [#1] PREEMPT SMP [  466.382163] Modules linked in: rfcomm snd_seq_dummy snd_hrtimer snd_seq snd_seq_device algif_hash algif_skcipher af_alg bnep binfmt_misc vc4 snd_soc_hdmi_codec drm_display_helper cec brcmfmac_wcc spidev rpivid_hevc(C) drm_client_lib brcmfmac hci_uart drm_dma_helper pisp_be btbcm brcmutil snd_soc_core aes_ce_blk v4l2_mem2mem bluetooth aes_ce_cipher snd_compress videobuf2_dma_contig ghash_ce cfg80211 gf128mul snd_pcm_dmaengine videobuf2_memops ecdh_generic sha2_ce ecc videobuf2_v4l2 snd_pcm v3d sha256_arm64 rfkill videodev snd_timer sha1_ce libaes gpu_sched snd videobuf2_common sha1_generic drm_shmem_helper mc rp1_pio drm_kms_helper raspberrypi_hwmon spi_bcm2835 gpio_keys i2c_brcmstb rp1 raspberrypi_gpiomem rp1_mailbox rp1_adc nvmem_rmem uio_pdrv_genirq uio i2c_dev drm ledtrig_pattern drm_panel_orientation_quirks backlight fuse dm_mod ip_tables x_tables ipv6 [  466.458429] CPU: 0 UID: 1000 PID: 2008 Comm: chromium Tainted: G         C         6.13.0-v8+ #18 [  466.467336] Tainted: [C]=CRAP [  466.470306] Hardware name: Raspberry Pi 5 Model B Rev 1.0 (DT) [  466.476157] pstate: 404000c9 (nZcv daIF +PAN -UAO -TCO -DIT -SSBS BTYPE=--) [  466.483143] pc : v3d_irq+0x118/0x2e0 [v3d] [  466.487258] lr : __handle_irq_event_percpu+0x60/0x228 [  466.492327] sp : ffffffc080003ea0 [  466.495646] x29: ffffffc080003ea0 x28: ffffff80c0c94200 x27: 0000000000000000 [  466.502807] x26: ffffffd08dd81d7b x25: ffffff80c0c94200 x24: ffffff8003bdc200 [  466.509969] x23: 0000000000000001 x22: 00000000000000a7 x21: 0000000000000000 [  466.517130] x20: ffffff8041bb0000 x19: 0000000000000001 x18: 0000000000000000 [  466.524291] x17: ffffffafadfb0000 x16: ffffffc080000000 x15: 0000000000000000 [  466.531452] x14: 0000000000000000 x13: 0000000000000000 x12: 0000000000000000 [  466.538613] x11: 0000000000000000 x10: 0000000000000000 x9 : ffffffd08c527eb0 [  466.545777] x8 : 0000000000000000 x7 : 0000000000000000 x6 : 0000000000000000 [  466.552941] x5 : ffffffd08c4100d0 x4 : ffffffafadfb0000 x3 : ffffffc080003f70 [  466.560102] x2 : ffffffc0829e8058 x1 : 0000000000000001 x0 : 0000000000000000 [  466.567263] Call trace: [  466.569711]  v3d_irq+0x118/0x2e0 [v3d] (P) [  466. ---truncated---",Race condition - Improper usage of synchronization primitives,Invalid pointer dereference,TRUE,#N/A,"On cleanup sets pointer to null, race condition between reusing this field and setting to null.",
CVE-2025-21663,https://www.cve.org/CVERecord?id=CVE-2025-21663,Linux,"net: stmmac: dwmac-tegra: Read iommu stream id from device tree  Nvidia's Tegra MGBE controllers require the IOMMU ""Stream ID"" (SID) to be written to the MGBE_WRAP_AXI_ASID0_CTRL register.  The current driver is hard coded to use MGBE0's SID for all controllers. This causes softirq time outs and kernel panics when using controllers other than MGBE0.  Example dmesg errors when an ethernet cable is connected to MGBE1:  [  116.133290] tegra-mgbe 6910000.ethernet eth1: Link is Up - 1Gbps/Full - flow control rx/tx [  121.851283] tegra-mgbe 6910000.ethernet eth1: NETDEV WATCHDOG: CPU: 5: transmit queue 0 timed out 5690 ms [  121.851782] tegra-mgbe 6910000.ethernet eth1: Reset adapter. [  121.892464] tegra-mgbe 6910000.ethernet eth1: Register MEM_TYPE_PAGE_POOL RxQ-0 [  121.905920] tegra-mgbe 6910000.ethernet eth1: PHY [stmmac-1:00] driver [Aquantia AQR113] (irq=171) [  121.907356] tegra-mgbe 6910000.ethernet eth1: Enabling Safety Features [  121.907578] tegra-mgbe 6910000.ethernet eth1: IEEE 1588-2008 Advanced Timestamp supported [  121.908399] tegra-mgbe 6910000.ethernet eth1: registered PTP clock [  121.908582] tegra-mgbe 6910000.ethernet eth1: configuring for phy/10gbase-r link mode [  125.961292] tegra-mgbe 6910000.ethernet eth1: Link is Up - 1Gbps/Full - flow control rx/tx [  181.921198] rcu: INFO: rcu_preempt detected stalls on CPUs/tasks: [  181.921404] rcu:  7-....: (1 GPs behind) idle=540c/1/0x4000000000000002 softirq=1748/1749 fqs=2337 [  181.921684] rcu:  (detected by 4, t=6002 jiffies, g=1357, q=1254 ncpus=8) [  181.921878] Sending NMI from CPU 4 to CPUs 7: [  181.921886] NMI backtrace for cpu 7 [  181.922131] CPU: 7 UID: 0 PID: 0 Comm: swapper/7 Kdump: loaded Not tainted 6.13.0-rc3+ #6 [  181.922390] Hardware name: NVIDIA CTI Forge + Orin AGX/Jetson, BIOS 202402.1-Unknown 10/28/2024 [  181.922658] pstate: 40400009 (nZcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) [  181.922847] pc : handle_softirqs+0x98/0x368 [  181.922978] lr : __do_softirq+0x18/0x20 [  181.923095] sp : ffff80008003bf50 [  181.923189] x29: ffff80008003bf50 x28: 0000000000000008 x27: 0000000000000000 [  181.923379] x26: ffffce78ea277000 x25: 0000000000000000 x24: 0000001c61befda0 [  181.924486] x23: 0000000060400009 x22: ffffce78e99918bc x21: ffff80008018bd70 [  181.925568] x20: ffffce78e8bb00d8 x19: ffff80008018bc20 x18: 0000000000000000 [  181.926655] x17: ffff318ebe7d3000 x16: ffff800080038000 x15: 0000000000000000 [  181.931455] x14: ffff000080816680 x13: ffff318ebe7d3000 x12: 000000003464d91d [  181.938628] x11: 0000000000000040 x10: ffff000080165a70 x9 : ffffce78e8bb0160 [  181.945804] x8 : ffff8000827b3160 x7 : f9157b241586f343 x6 : eeb6502a01c81c74 [  181.953068] x5 : a4acfcdd2e8096bb x4 : ffffce78ea277340 x3 : 00000000ffffd1e1 [  181.960329] x2 : 0000000000000101 x1 : ffffce78ea277340 x0 : ffff318ebe7d3000 [  181.967591] Call trace: [  181.970043]  handle_softirqs+0x98/0x368 (P) [  181.974240]  __do_softirq+0x18/0x20 [  181.977743]  ____do_softirq+0x14/0x28 [  181.981415]  call_on_irq_stack+0x24/0x30 [  181.985180]  do_softirq_own_stack+0x20/0x30 [  181.989379]  __irq_exit_rcu+0x114/0x140 [  181.993142]  irq_exit_rcu+0x14/0x28 [  181.996816]  el1_interrupt+0x44/0xb8 [  182.000316]  el1h_64_irq_handler+0x14/0x20 [  182.004343]  el1h_64_irq+0x80/0x88 [  182.007755]  cpuidle_enter_state+0xc4/0x4a8 (P) [  182.012305]  cpuidle_enter+0x3c/0x58 [  182.015980]  cpuidle_idle_call+0x128/0x1c0 [  182.020005]  do_idle+0xe0/0xf0 [  182.023155]  cpu_startup_entry+0x3c/0x48 [  182.026917]  secondary_start_kernel+0xdc/0x120 [  182.031379]  __secondary_switched+0x74/0x78 [  212.971162] rcu: INFO: rcu_preempt detected expedited stalls on CPUs/tasks: { 7-.... } 6103 jiffies s: 417 root: 0x80/. [  212.985935] rcu: blocking rcu_node structures (internal RCU debug): [  212.992758] Sending NMI from CPU 0 to CPUs 7: [  212.998539] NMI backtrace for cpu 7 [  213.004304] CPU: 7 UID: 0 PI ---truncated---",Semantic - Logic error,Failure to release CPU,FALSE,#N/A,"Wrong device id used, causes softirq time outs",
CVE-2025-21835,https://www.cve.org/CVERecord?id=CVE-2025-21835,Linux,"usb: gadget: f_midi: fix MIDI Streaming descriptor lengths  While the MIDI jacks are configured correctly, and the MIDIStreaming endpoint descriptors are filled with the correct information, bNumEmbMIDIJack and bLength are set incorrectly in these descriptors.  This does not matter when the numbers of in and out ports are equal, but when they differ the host will receive broken descriptors with uninitialized stack memory leaking into the descriptor for whichever value is smaller.  The precise meaning of ""in"" and ""out"" in the port counts is not clearly defined and can be confusing.  But elsewhere the driver consistently uses this to match the USB meaning of IN and OUT viewed from the host, so that ""in"" ports send data to the host and ""out"" ports receive data from it.",Semantic - Logic error,OOB access,TRUE,#N/A,"OOB read from logic error, leads to memory disclosure",
CVE-2025-37766,https://www.cve.org/CVERecord?id=CVE-2025-37766,Linux,"drm/amd/pm: Prevent division by zero  The user can set any speed value. If speed is greater than UINT_MAX/8, division by zero is possible.  Found by Linux Verification Center (linuxtesting.org) with SVACE.",Semantic - Improper input validation,Explicit exception/panic,FALSE,#N/A,Divison by 0,
CVE-2025-22094,https://www.cve.org/CVERecord?id=CVE-2025-22094,Linux,"powerpc/perf: Fix ref-counting on the PMU 'vpa_pmu'  Commit 176cda0619b6 (""powerpc/perf: Add perf interface to expose vpa counters"") introduced 'vpa_pmu' to expose Book3s-HV nested APIv2 provided L1<->L2 context switch latency counters to L1 user-space via perf-events. However the newly introduced PMU named 'vpa_pmu' doesn't assign ownership of the PMU to the module 'vpa_pmu'. Consequently the module 'vpa_pmu' can be unloaded while one of the perf-events are still active, which can lead to kernel oops and panic of the form below on a Pseries-LPAR:  BUG: Kernel NULL pointer dereference on read at 0x00000058 <snip>  NIP [c000000000506cb8] event_sched_out+0x40/0x258  LR [c00000000050e8a4] __perf_remove_from_context+0x7c/0x2b0  Call Trace:  [c00000025fc3fc30] [c00000025f8457a8] 0xc00000025f8457a8 (unreliable)  [c00000025fc3fc80] [fffffffffffffee0] 0xfffffffffffffee0  [c00000025fc3fcd0] [c000000000501e70] event_function+0xa8/0x120 <snip>  Kernel panic - not syncing: Aiee, killing interrupt handler!  Fix this by adding the module ownership to 'vpa_pmu' so that the module 'vpa_pmu' is ref-counted and prevented from being unloaded when perf-events are initialized.",Semantic - Logic error,Invalid pointer dereference,TRUE,#N/A,"Didn't register PMU correctly, which can cause null ptr deref.",
CVE-2025-21738,https://www.cve.org/CVERecord?id=CVE-2025-21738,Linux,"ata: libata-sff: Ensure that we cannot write outside the allocated buffer  reveliofuzzing reported that a SCSI_IOCTL_SEND_COMMAND ioctl with out_len set to 0xd42, SCSI command set to ATA_16 PASS-THROUGH, ATA command set to ATA_NOP, and protocol set to ATA_PROT_PIO, can cause ata_pio_sector() to write outside the allocated buffer, overwriting random memory.  While a ATA device is supposed to abort a ATA_NOP command, there does seem to be a bug either in libata-sff or QEMU, where either this status is not set, or the status is cleared before read by ata_sff_hsm_move(). Anyway, that is most likely a separate bug.  Looking at __atapi_pio_bytes(), it already has a safety check to ensure that __atapi_pio_bytes() cannot write outside the allocated buffer.  Add a similar check to ata_pio_sector(), such that also ata_pio_sector() cannot write outside the allocated buffer.",Semantic - Improper input validation,OOB access,TRUE,#N/A,"Edge case allows OOB write, added more bound checking.",
CVE-2025-21763,https://www.cve.org/CVERecord?id=CVE-2025-21763,Linux,neighbour: use RCU protection in __neigh_notify()  __neigh_notify() can be called without RTNL or RCU protection.  Use RCU protection to avoid potential UAF.,Race condition - Improper usage of synchronization primitives,Use after free,TRUE,#N/A,Missing synchronization allows for UAF.,
CVE-2025-23144,https://www.cve.org/CVERecord?id=CVE-2025-23144,Linux,"backlight: led_bl: Hold led_access lock when calling led_sysfs_disable()  Lockdep detects the following issue on led-backlight removal:   [  142.315935] ------------[ cut here ]------------   [  142.315954] WARNING: CPU: 2 PID: 292 at drivers/leds/led-core.c:455 led_sysfs_enable+0x54/0x80   ...   [  142.500725] Call trace:   [  142.503176]  led_sysfs_enable+0x54/0x80 (P)   [  142.507370]  led_bl_remove+0x80/0xa8 [led_bl]   [  142.511742]  platform_remove+0x30/0x58   [  142.515501]  device_remove+0x54/0x90   ...  Indeed, led_sysfs_enable() has to be called with the led_access lock held.  Hold the lock when calling led_sysfs_disable().",Race condition - Improper usage of synchronization primitives,High level spec violation,FALSE,#N/A,"Spec expects lock, leading to WARN_ON() trigger when it isn't held. Leads to potentially logically incosistent state",
CVE-2025-21977,https://www.cve.org/CVERecord?id=CVE-2025-21977,Linux,"fbdev: hyperv_fb: Fix hang in kdump kernel when on Hyper-V Gen 2 VMs  Gen 2 Hyper-V VMs boot via EFI and have a standard EFI framebuffer device. When the kdump kernel runs in such a VM, loading the efifb driver may hang because of accessing the framebuffer at the wrong memory address.  The scenario occurs when the hyperv_fb driver in the original kernel moves the framebuffer to a different MMIO address because of conflicts with an already-running efifb or simplefb driver. The hyperv_fb driver then informs Hyper-V of the change, which is allowed by the Hyper-V FB VMBus device protocol. However, when the kexec command loads the kdump kernel into crash memory via the kexec_file_load() system call, the system call doesn't know the framebuffer has moved, and it sets up the kdump screen_info using the original framebuffer address. The transition to the kdump kernel does not go through the Hyper-V host, so Hyper-V does not reset the framebuffer address like it would do on a reboot. When efifb tries to run, it accesses a non-existent framebuffer address, which traps to the Hyper-V host. After many such accesses, the Hyper-V host thinks the guest is being malicious, and throttles the guest to the point that it runs very slowly or appears to have hung.  When the kdump kernel is loaded into crash memory via the kexec_load() system call, the problem does not occur. In this case, the kexec command builds the screen_info table itself in user space from data returned by the FBIOGET_FSCREENINFO ioctl against /dev/fb0, which gives it the new framebuffer location.  This problem was originally reported in 2020 [1], resulting in commit 3cb73bc3fa2a (""hyperv_fb: Update screen_info after removing old framebuffer""). This commit solved the problem by setting orig_video_isVGA to 0, so the kdump kernel was unaware of the EFI framebuffer. The efifb driver did not try to load, and no hang occurred. But in 2024, commit c25a19afb81c (""fbdev/hyperv_fb: Do not clear global screen_info"") effectively reverted 3cb73bc3fa2a. Commit c25a19afb81c has no reference to 3cb73bc3fa2a, so perhaps it was done without knowing the implications that were reported with 3cb73bc3fa2a. In any case, as of commit c25a19afb81c, the original problem came back again.  Interestingly, the hyperv_drm driver does not have this problem because it never moves the framebuffer. The difference is that the hyperv_drm driver removes any conflicting framebuffers *before* allocating an MMIO address, while the hyperv_fb drivers removes conflicting framebuffers *after* allocating an MMIO address. With the ""after"" ordering, hyperv_fb may encounter a conflict and move the framebuffer to a different MMIO address. But the conflict is essentially bogus because it is removed a few lines of code later.  Rather than fix the problem with the approach from 2020 in commit 3cb73bc3fa2a, instead slightly reorder the steps in hyperv_fb so conflicting framebuffers are removed before allocating an MMIO address. Then the default framebuffer MMIO address should always be available, and there's never any confusion about which framebuffer address the kdump kernel should use -- it's always the original address provided by the Hyper-V host. This approach is already used by the hyperv_drm driver, and is consistent with the usage guidelines at the head of the module with the function aperture_remove_conflicting_devices().  This approach also solves a related minor problem when kexec_load() is used to load the kdump kernel. With current code, unbinding and rebinding the hyperv_fb driver could result in the framebuffer moving back to the default framebuffer address, because on the rebind there are no conflicts. If such a move is done after the kdump kernel is loaded with the new framebuffer address, at kdump time it could again have the wrong address.  This problem and fix are described in terms of the kdump kernel, but it can also occur ---truncated---",Semantic - Logic error,High level spec violation,FALSE,#N/A,"Logic error in vm leads to incorrect framebuffer address which leads to system hangs, due to safety throttle mechanism. Cheri could mitigate to DoS avoiding hang",
CVE-2025-21902,https://www.cve.org/CVERecord?id=CVE-2025-21902,Linux,"acpi: typec: ucsi: Introduce a ->poll_cci method  For the ACPI backend of UCSI the UCSI ""registers"" are just a memory copy of the register values in an opregion. The ACPI implementation in the BIOS ensures that the opregion contents are synced to the embedded controller and it ensures that the registers (in particular CCI) are synced back to the opregion on notifications. While there is an ACPI call that syncs the actual registers to the opregion there is rarely a need to do this and on some ACPI implementations it actually breaks in various interesting ways.  The only reason to force a sync from the embedded controller is to poll CCI while notifications are disabled. Only the ucsi core knows if this is the case and guessing based on the current command is suboptimal, i.e. leading to the following spurious assertion splat:  WARNING: CPU: 3 PID: 76 at drivers/usb/typec/ucsi/ucsi.c:1388 ucsi_reset_ppm+0x1b4/0x1c0 [typec_ucsi] CPU: 3 UID: 0 PID: 76 Comm: kworker/3:0 Not tainted 6.12.11-200.fc41.x86_64 #1 Hardware name: LENOVO 21D0/LNVNB161216, BIOS J6CN45WW 03/17/2023 Workqueue: events_long ucsi_init_work [typec_ucsi] RIP: 0010:ucsi_reset_ppm+0x1b4/0x1c0 [typec_ucsi] Call Trace:  <TASK>  ucsi_init_work+0x3c/0xac0 [typec_ucsi]  process_one_work+0x179/0x330  worker_thread+0x252/0x390  kthread+0xd2/0x100  ret_from_fork+0x34/0x50  ret_from_fork_asm+0x1a/0x30  </TASK>  Thus introduce a ->poll_cci() method that works like ->read_cci() with an additional forced sync and document that this should be used when polling with notifications disabled. For all other backends that presumably don't have this issue use the same implementation for both methods.",Semantic - Spec error,High level spec violation,FALSE,#N/A,Change spec to remove warning,
CVE-2025-21819,https://www.cve.org/CVERecord?id=CVE-2025-21819,Linux,"Revert ""drm/amd/display: Use HW lock mgr for PSR1""  This reverts commit a2b5a9956269 (""drm/amd/display: Use HW lock mgr for PSR1"")  Because it may cause system hang while connect with two edp panel.",Semantic - Logic error,Failure to release CPU,FALSE,#N/A,System hang due to improper || logic.,
CVE-2025-22069,https://www.cve.org/CVERecord?id=CVE-2025-22069,Linux,"riscv: fgraph: Fix stack layout to match __arch_ftrace_regs argument of ftrace_return_to_handler  Naresh Kamboju reported a ""Bad frame pointer"" kernel warning while running LTP trace ftrace_stress_test.sh in riscv. We can reproduce the same issue with the following command:  ``` $ cd /sys/kernel/debug/tracing $ echo 'f:myprobe do_nanosleep%return args1=$retval' > dynamic_events $ echo 1 > events/fprobes/enable $ echo 1 > tracing_on $ sleep 1 ```  And we can get the following kernel warning:  [  127.692888] ------------[ cut here ]------------ [  127.693755] Bad frame pointer: expected ff2000000065be50, received ba34c141e9594000 [  127.693755]   from func do_nanosleep return to ffffffff800ccb16 [  127.698699] WARNING: CPU: 1 PID: 129 at kernel/trace/fgraph.c:755 ftrace_return_to_handler+0x1b2/0x1be [  127.699894] Modules linked in: [  127.700908] CPU: 1 UID: 0 PID: 129 Comm: sleep Not tainted 6.14.0-rc3-g0ab191c74642 #32 [  127.701453] Hardware name: riscv-virtio,qemu (DT) [  127.701859] epc : ftrace_return_to_handler+0x1b2/0x1be [  127.702032]  ra : ftrace_return_to_handler+0x1b2/0x1be [  127.702151] epc : ffffffff8013b5e0 ra : ffffffff8013b5e0 sp : ff2000000065bd10 [  127.702221]  gp : ffffffff819c12f8 tp : ff60000080853100 t0 : 6e00000000000000 [  127.702284]  t1 : 0000000000000020 t2 : 6e7566206d6f7266 s0 : ff2000000065bd80 [  127.702346]  s1 : ff60000081262000 a0 : 000000000000007b a1 : ffffffff81894f20 [  127.702408]  a2 : 0000000000000010 a3 : fffffffffffffffe a4 : 0000000000000000 [  127.702470]  a5 : 0000000000000000 a6 : 0000000000000008 a7 : 0000000000000038 [  127.702530]  s2 : ba34c141e9594000 s3 : 0000000000000000 s4 : ff2000000065bdd0 [  127.702591]  s5 : 00007fff8adcf400 s6 : 000055556dc1d8c0 s7 : 0000000000000068 [  127.702651]  s8 : 00007fff8adf5d10 s9 : 000000000000006d s10: 0000000000000001 [  127.702710]  s11: 00005555737377c8 t3 : ffffffff819d899e t4 : ffffffff819d899e [  127.702769]  t5 : ffffffff819d89a0 t6 : ff2000000065bb18 [  127.702826] status: 0000000200000120 badaddr: 0000000000000000 cause: 0000000000000003 [  127.703292] [<ffffffff8013b5e0>] ftrace_return_to_handler+0x1b2/0x1be [  127.703760] [<ffffffff80017bce>] return_to_handler+0x16/0x26 [  127.704009] [<ffffffff80017bb8>] return_to_handler+0x0/0x26 [  127.704057] [<ffffffff800d3352>] common_nsleep+0x42/0x54 [  127.704117] [<ffffffff800d44a2>] __riscv_sys_clock_nanosleep+0xba/0x10a [  127.704176] [<ffffffff80901c56>] do_trap_ecall_u+0x188/0x218 [  127.704295] [<ffffffff8090cc3e>] handle_exception+0x14a/0x156 [  127.705436] ---[ end trace 0000000000000000 ]---  The reason is that the stack layout for constructing argument for the ftrace_return_to_handler in the return_to_handler does not match the __arch_ftrace_regs structure of riscv, leading to unexpected results.",Semantic - Spec error,High level spec violation,FALSE,#N/A,Stack layout for ftrace_return_to_handler wasn't riscv compliant leading to warning.,
CVE-2025-22113,https://www.cve.org/CVERecord?id=CVE-2025-22113,Linux,"ext4: avoid journaling sb update on error if journal is destroying  Presently we always BUG_ON if trying to start a transaction on a journal marked with JBD2_UNMOUNT, since this should never happen. However, while ltp running stress tests, it was observed that in case of some error handling paths, it is possible for update_super_work to start a transaction after the journal is destroyed eg:  (umount) ext4_kill_sb   kill_block_super     generic_shutdown_super       sync_filesystem /* commits all txns */       evict_inodes         /* might start a new txn */       ext4_put_super  flush_work(&sbi->s_sb_upd_work) /* flush the workqueue */         jbd2_journal_destroy           journal_kill_thread             journal->j_flags |= JBD2_UNMOUNT;           jbd2_journal_commit_transaction             jbd2_journal_get_descriptor_buffer               jbd2_journal_bmap                 ext4_journal_bmap                   ext4_map_blocks                     ...                     ext4_inode_error                       ext4_handle_error                         schedule_work(&sbi->s_sb_upd_work)                                                 /* work queue kicks in */                                                update_super_work                                                  jbd2_journal_start                                                    start_this_handle                                                      BUG_ON(journal->j_flags &                                                             JBD2_UNMOUNT)  Hence, introduce a new mount flag to indicate journal is destroying and only do a journaled (and deferred) update of sb if this flag is not set. Otherwise, just fallback to an un-journaled commit.  Further, in the journal destroy path, we have the following sequence:    1. Set mount flag indicating journal is destroying   2. force a commit and wait for it   3. flush pending sb updates  This sequence is important as it ensures that, after this point, there is no sb update that might be journaled so it is safe to update the sb outside the journal. (To avoid race discussed in 2d01ddc86606)  Also, we don't need a similar check in ext4_grp_locked_error since it is only called from mballoc and AFAICT it would be always valid to schedule work here.",Semantic - Spec error,Explicit exception/panic,FALSE,#N/A,"Edge case triggers BUG_ON(), ie panics. Patch involves adding extra flag to avoid this edge case.",
CVE-2025-21925,https://www.cve.org/CVERecord?id=CVE-2025-21925,Linux,"llc: do not use skb_get() before dev_queue_xmit()  syzbot is able to crash hosts [1], using llc and devices not supporting IFF_TX_SKB_SHARING.  In this case, e1000 driver calls eth_skb_pad(), while the skb is shared.  Simply replace skb_get() by skb_clone() in net/llc/llc_s_ac.c  Note that e1000 driver might have an issue with pktgen, because it does not clear IFF_TX_SKB_SHARING, this is an orthogonal change.  We need to audit other skb_get() uses in net/llc.  [1]  kernel BUG at net/core/skbuff.c:2178 ! Oops: invalid opcode: 0000 [#1] PREEMPT SMP KASAN NOPTI CPU: 0 UID: 0 PID: 16371 Comm: syz.2.2764 Not tainted 6.14.0-rc4-syzkaller-00052-gac9c34d1e45a #0 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014  RIP: 0010:pskb_expand_head+0x6ce/0x1240 net/core/skbuff.c:2178 Call Trace:  <TASK>   __skb_pad+0x18a/0x610 net/core/skbuff.c:2466   __skb_put_padto include/linux/skbuff.h:3843 [inline]   skb_put_padto include/linux/skbuff.h:3862 [inline]   eth_skb_pad include/linux/etherdevice.h:656 [inline]   e1000_xmit_frame+0x2d99/0x5800 drivers/net/ethernet/intel/e1000/e1000_main.c:3128   __netdev_start_xmit include/linux/netdevice.h:5151 [inline]   netdev_start_xmit include/linux/netdevice.h:5160 [inline]   xmit_one net/core/dev.c:3806 [inline]   dev_hard_start_xmit+0x9a/0x7b0 net/core/dev.c:3822   sch_direct_xmit+0x1ae/0xc30 net/sched/sch_generic.c:343   __dev_xmit_skb net/core/dev.c:4045 [inline]   __dev_queue_xmit+0x13d4/0x43e0 net/core/dev.c:4621   dev_queue_xmit include/linux/netdevice.h:3313 [inline]   llc_sap_action_send_test_c+0x268/0x320 net/llc/llc_s_ac.c:144   llc_exec_sap_trans_actions net/llc/llc_sap.c:153 [inline]   llc_sap_next_state net/llc/llc_sap.c:182 [inline]   llc_sap_state_process+0x239/0x510 net/llc/llc_sap.c:209   llc_ui_sendmsg+0xd0d/0x14e0 net/llc/af_llc.c:993   sock_sendmsg_nosec net/socket.c:718 [inline]",Semantic - Spec error,Use after free,TRUE,#N/A,"Spec didn't account for devices with skb sharing disabled. Leads to UAF since on error obtaining a reference, resource will be freed. Patch changes spec to clone the resource instead of aliasing.",
CVE-2025-22042,https://www.cve.org/CVERecord?id=CVE-2025-22042,Linux,ksmbd: add bounds check for create lease context  Add missing bounds check for create lease context.,Semantic - Improper input validation,OOB access,TRUE,#N/A,Completely missing bound check,
CVE-2025-21906,https://www.cve.org/CVERecord?id=CVE-2025-21906,Linux,"wifi: iwlwifi: mvm: clean up ROC on failure  If the firmware fails to start the session protection, then we do call iwl_mvm_roc_finished() here, but that won't do anything at all because IWL_MVM_STATUS_ROC_P2P_RUNNING was never set. Set IWL_MVM_STATUS_ROC_P2P_RUNNING in the failure/stop path. If it started successfully before, it's already set, so that doesn't matter, and if it didn't start it needs to be set to clean up.  Not doing so will lead to a WARN_ON() later on a fresh remain- on-channel, since the link is already active when activated as it was never deactivated.",Language - Lifetime violation,Resource leak,FALSE,#N/A,Improper clean up on fail path leads to WARN_ON() triggering and resource leak.,
CVE-2025-21812,https://www.cve.org/CVERecord?id=CVE-2025-21812,Linux,"ax25: rcu protect dev->ax25_ptr  syzbot found a lockdep issue [1].  We should remove ax25 RTNL dependency in ax25_setsockopt()  This should also fix a variety of possible UAF in ax25.  [1]  WARNING: possible circular locking dependency detected 6.13.0-rc3-syzkaller-00762-g9268abe611b0 #0 Not tainted ------------------------------------------------------ syz.5.1818/12806 is trying to acquire lock:  ffffffff8fcb3988 (rtnl_mutex){+.+.}-{4:4}, at: ax25_setsockopt+0xa55/0xe90 net/ax25/af_ax25.c:680  but task is already holding lock:  ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: lock_sock include/net/sock.h:1618 [inline]  ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: ax25_setsockopt+0x209/0xe90 net/ax25/af_ax25.c:574  which lock already depends on the new lock.  the existing dependency chain (in reverse order) is:  -> #1 (sk_lock-AF_AX25){+.+.}-{0:0}:         lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5849         lock_sock_nested+0x48/0x100 net/core/sock.c:3642         lock_sock include/net/sock.h:1618 [inline]         ax25_kill_by_device net/ax25/af_ax25.c:101 [inline]         ax25_device_event+0x24d/0x580 net/ax25/af_ax25.c:146         notifier_call_chain+0x1a5/0x3f0 kernel/notifier.c:85        __dev_notify_flags+0x207/0x400         dev_change_flags+0xf0/0x1a0 net/core/dev.c:9026         dev_ifsioc+0x7c8/0xe70 net/core/dev_ioctl.c:563         dev_ioctl+0x719/0x1340 net/core/dev_ioctl.c:820         sock_do_ioctl+0x240/0x460 net/socket.c:1234         sock_ioctl+0x626/0x8e0 net/socket.c:1339         vfs_ioctl fs/ioctl.c:51 [inline]         __do_sys_ioctl fs/ioctl.c:906 [inline]         __se_sys_ioctl+0xf5/0x170 fs/ioctl.c:892         do_syscall_x64 arch/x86/entry/common.c:52 [inline]         do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83        entry_SYSCALL_64_after_hwframe+0x77/0x7f  -> #0 (rtnl_mutex){+.+.}-{4:4}:         check_prev_add kernel/locking/lockdep.c:3161 [inline]         check_prevs_add kernel/locking/lockdep.c:3280 [inline]         validate_chain+0x18ef/0x5920 kernel/locking/lockdep.c:3904         __lock_acquire+0x1397/0x2100 kernel/locking/lockdep.c:5226         lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5849         __mutex_lock_common kernel/locking/mutex.c:585 [inline]         __mutex_lock+0x1ac/0xee0 kernel/locking/mutex.c:735         ax25_setsockopt+0xa55/0xe90 net/ax25/af_ax25.c:680         do_sock_setsockopt+0x3af/0x720 net/socket.c:2324         __sys_setsockopt net/socket.c:2349 [inline]         __do_sys_setsockopt net/socket.c:2355 [inline]         __se_sys_setsockopt net/socket.c:2352 [inline]         __x64_sys_setsockopt+0x1ee/0x280 net/socket.c:2352         do_syscall_x64 arch/x86/entry/common.c:52 [inline]         do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83        entry_SYSCALL_64_after_hwframe+0x77/0x7f  other info that might help us debug this:   Possible unsafe locking scenario:         CPU0                    CPU1        ----                    ----   lock(sk_lock-AF_AX25);                                lock(rtnl_mutex);                                lock(sk_lock-AF_AX25);   lock(rtnl_mutex);   *** DEADLOCK ***  1 lock held by syz.5.1818/12806:   #0: ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: lock_sock include/net/sock.h:1618 [inline]   #0: ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: ax25_setsockopt+0x209/0xe90 net/ax25/af_ax25.c:574  stack backtrace: CPU: 1 UID: 0 PID: 12806 Comm: syz.5.1818 Not tainted 6.13.0-rc3-syzkaller-00762-g9268abe611b0 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 Call Trace:  <TASK>   __dump_stack lib/dump_stack.c:94 [inline]   dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120   print_circular_bug+0x13a/0x1b0 kernel/locking/lockdep.c:2074   check_noncircular+0x36a/0x4a0 kernel/locking/lockdep.c:2206   check_prev_add kernel/locking/lockdep.c:3161 [inline]   check_prevs_add kernel/lockin ---truncated---",Semantic - Spec error,Failure to release CPU,FALSE,#N/A,Bad locking spec can lead to deadlock due to circular dependency. Patch changed spec.,
CVE-2025-21867,https://www.cve.org/CVERecord?id=CVE-2025-21867,Linux,"bpf, test_run: Fix use-after-free issue in eth_skb_pkt_type()  KMSAN reported a use-after-free issue in eth_skb_pkt_type()[1]. The cause of the issue was that eth_skb_pkt_type() accessed skb's data that didn't contain an Ethernet header. This occurs when bpf_prog_test_run_xdp() passes an invalid value as the user_data argument to bpf_test_init().  Fix this by returning an error when user_data is less than ETH_HLEN in bpf_test_init(). Additionally, remove the check for ""if (user_size > size)"" as it is unnecessary.  [1] BUG: KMSAN: use-after-free in eth_skb_pkt_type include/linux/etherdevice.h:627 [inline] BUG: KMSAN: use-after-free in eth_type_trans+0x4ee/0x980 net/ethernet/eth.c:165  eth_skb_pkt_type include/linux/etherdevice.h:627 [inline]  eth_type_trans+0x4ee/0x980 net/ethernet/eth.c:165  __xdp_build_skb_from_frame+0x5a8/0xa50 net/core/xdp.c:635  xdp_recv_frames net/bpf/test_run.c:272 [inline]  xdp_test_run_batch net/bpf/test_run.c:361 [inline]  bpf_test_run_xdp_live+0x2954/0x3330 net/bpf/test_run.c:390  bpf_prog_test_run_xdp+0x148e/0x1b10 net/bpf/test_run.c:1318  bpf_prog_test_run+0x5b7/0xa30 kernel/bpf/syscall.c:4371  __sys_bpf+0x6a6/0xe20 kernel/bpf/syscall.c:5777  __do_sys_bpf kernel/bpf/syscall.c:5866 [inline]  __se_sys_bpf kernel/bpf/syscall.c:5864 [inline]  __x64_sys_bpf+0xa4/0xf0 kernel/bpf/syscall.c:5864  x64_sys_call+0x2ea0/0x3d90 arch/x86/include/generated/asm/syscalls_64.h:322  do_syscall_x64 arch/x86/entry/common.c:52 [inline]  do_syscall_64+0xd9/0x1d0 arch/x86/entry/common.c:83  entry_SYSCALL_64_after_hwframe+0x77/0x7f  Uninit was created at:  free_pages_prepare mm/page_alloc.c:1056 [inline]  free_unref_page+0x156/0x1320 mm/page_alloc.c:2657  __free_pages+0xa3/0x1b0 mm/page_alloc.c:4838  bpf_ringbuf_free kernel/bpf/ringbuf.c:226 [inline]  ringbuf_map_free+0xff/0x1e0 kernel/bpf/ringbuf.c:235  bpf_map_free kernel/bpf/syscall.c:838 [inline]  bpf_map_free_deferred+0x17c/0x310 kernel/bpf/syscall.c:862  process_one_work kernel/workqueue.c:3229 [inline]  process_scheduled_works+0xa2b/0x1b60 kernel/workqueue.c:3310  worker_thread+0xedf/0x1550 kernel/workqueue.c:3391  kthread+0x535/0x6b0 kernel/kthread.c:389  ret_from_fork+0x6e/0x90 arch/x86/kernel/process.c:147  ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244  CPU: 1 UID: 0 PID: 17276 Comm: syz.1.16450 Not tainted 6.12.0-05490-g9bb88c659673 #8 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-3.fc41 04/01/2014",Semantic - Improper input validation,OOB access,TRUE,#N/A,"Didn't check length of user passed buffer for errors. If wrong buffer or incorrect length passed, we can have OOB issues. Flagged by KMSAN as UAF, but really OOB access.",
CVE-2025-21817,https://www.cve.org/CVERecord?id=CVE-2025-21817,Linux,"block: mark GFP_NOIO around sysfs ->store()  sysfs ->store is called with queue freezed, meantime we have several ->store() callbacks(update_nr_requests, wbt, scheduler) to allocate memory with GFP_KERNEL which may run into direct reclaim code path, then potential deadlock can be caused.  Fix the issue by marking NOIO around sysfs ->store()",Protocol - Missing Protocol Steps,Failure to release CPU,FALSE,#N/A,Potential deadlock due to missing memalloc_noio_save() in IO-sensitive store operation.,
CVE-2025-21823,https://www.cve.org/CVERecord?id=CVE-2025-21823,Linux,"batman-adv: Drop unmanaged ELP metric worker  The ELP worker needs to calculate new metric values for all neighbors ""reachable"" over an interface. Some of the used metric sources require locks which might need to sleep. This sleep is incompatible with the RCU list iterator used for the recorded neighbors. The initial approach to work around of this problem was to queue another work item per neighbor and then run this in a new context.  Even when this solved the RCU vs might_sleep() conflict, it has a major problems: Nothing was stopping the work item in case it is not needed anymore - for example because one of the related interfaces was removed or the batman-adv module was unloaded - resulting in potential invalid memory accesses.  Directly canceling the metric worker also has various problems:  * cancel_work_sync for a to-be-deactivated interface is called with   rtnl_lock held. But the code in the ELP metric worker also tries to use   rtnl_lock() - which will never return in this case. This also means that   cancel_work_sync would never return because it is waiting for the worker   to finish. * iterating over the neighbor list for the to-be-deactivated interface is   currently done using the RCU specific methods. Which means that it is   possible to miss items when iterating over it without the associated   spinlock - a behaviour which is acceptable for a periodic metric check   but not for a cleanup routine (which must ""stop"" all still running   workers)  The better approch is to get rid of the per interface neighbor metric worker and handle everything in the interface worker. The original problems are solved by:  * creating a list of neighbors which require new metric information inside   the RCU protected context, gathering the metric according to the new list   outside the RCU protected context * only use rcu_trylock inside metric gathering code to avoid a deadlock   when the cancel_delayed_work_sync is called in the interface removal code   (which is called with the rtnl_lock held)",Semantic - Spec error,Failure to release CPU,FALSE,#N/A,Bad spec resulted in deadlock/RCU/UAF issues. Cheri would only mitigate the UAF issues.,
CVE-2025-21654,https://www.cve.org/CVERecord?id=CVE-2025-21654,Linux,"ovl: support encoding fid from inode with no alias  Dmitry Safonov reported that a WARN_ON() assertion can be trigered by userspace when calling inotify_show_fdinfo() for an overlayfs watched inode, whose dentry aliases were discarded with drop_caches.  The WARN_ON() assertion in inotify_show_fdinfo() was removed, because it is possible for encoding file handle to fail for other reason, but the impact of failing to encode an overlayfs file handle goes beyond this assertion.  As shown in the LTP test case mentioned in the link below, failure to encode an overlayfs file handle from a non-aliased inode also leads to failure to report an fid with FAN_DELETE_SELF fanotify events.  As Dmitry notes in his analyzis of the problem, ovl_encode_fh() fails if it cannot find an alias for the inode, but this failure can be fixed. ovl_encode_fh() seldom uses the alias and in the case of non-decodable file handles, as is often the case with fanotify fid info, ovl_encode_fh() never needs to use the alias to encode a file handle.  Defer finding an alias until it is actually needed so ovl_encode_fh() will not fail in the common case of FAN_DELETE_SELF fanotify events.",Semantic - Spec error,Resource leak,FALSE,#N/A,"Spec designed to require a resource alias for look up, but there are cases where this isn't true, which can trigger explicit WARN_ON() assert. Patch changes spec.",
CVE-2025-21827,https://www.cve.org/CVERecord?id=CVE-2025-21827,Linux,"Bluetooth: btusb: mediatek: Add locks for usb_driver_claim_interface()  The documentation for usb_driver_claim_interface() says that ""the device lock"" is needed when the function is called from places other than probe(). This appears to be the lock for the USB interface device. The Mediatek btusb code gets called via this path:    Workqueue: hci0 hci_power_on [bluetooth]   Call trace:    usb_driver_claim_interface    btusb_mtk_claim_iso_intf    btusb_mtk_setup    hci_dev_open_sync    hci_power_on    process_scheduled_works    worker_thread    kthread  With the above call trace the device lock hasn't been claimed. Claim it.  Without this fix, we'd sometimes see the error ""Failed to claim iso interface"". Sometimes we'd even see worse errors, like a NULL pointer dereference (where `intf->dev.driver` was NULL) with a trace like:    Call trace:    usb_suspend_both    usb_runtime_suspend    __rpm_callback    rpm_suspend    pm_runtime_work    process_scheduled_works  Both errors appear to be fixed with the proper locking.",Race condition - Improper usage of synchronization primitives,Invalid pointer dereference,TRUE,#N/A,"Didn't lock, leading to race errors (null ptr deref).",
CVE-2025-21788,https://www.cve.org/CVERecord?id=CVE-2025-21788,Linux,net: ethernet: ti: am65-cpsw: fix memleak in certain XDP cases  If the XDP program doesn't result in XDP_PASS then we leak the memory allocated by am65_cpsw_build_skb().  It is pointless to allocate SKB memory before running the XDP program as we would be wasting CPU cycles for cases other than XDP_PASS. Move the SKB allocation after evaluating the XDP program result.  This fixes the memleak. A performance boost is seen for XDP_DROP test.  XDP_DROP test: Before: 460256 rx/s                  0 err/s After:  784130 rx/s                  0 err/s,Language - Lifetime violation,Resource leak,FALSE,#N/A,"Missing free associated with am65_cpsw_build_skb for some code paths, leading to memory leak.",
CVE-2025-37778,https://www.cve.org/CVERecord?id=CVE-2025-37778,Linux,"ksmbd: Fix dangling pointer in krb_authenticate  krb_authenticate frees sess->user and does not set the pointer to NULL. It calls ksmbd_krb5_authenticate to reinitialise sess->user but that function may return without doing so. If that happens then smb2_sess_setup, which calls krb_authenticate, will be accessing free'd memory when it later uses sess->user.",Language - Lifetime violation,Use after free,TRUE,#N/A,Field that contains pointer was not set to null after the associated pointer is free'd. If field not replaced with valid pointer before re-use will be UAF.,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,
,,,,,,FALSE,FALSE,,