CVE ID,URL,OS,Description,Causes,Symptoms,Solved by CHERI?,Solved by Rust?,Notes
CVE-2024-26907,https://www.cve.org/CVERecord?id=CVE-2024-26907,Linux,"RDMA/mlx5: Fix fortify source warning while accessing Eth segment\n\n ------------[ cut here ]------------\n memcpy: detected field-spanning write (size 56) of single field ""eseg->inline_hdr.start"" at /var/lib/dkms/mlnx-ofed-kernel/5.8/build/drivers/infiniband/hw/mlx5/wr.c:131 (size 2)\n WARNING: CPU: 0 PID: 293779 at /var/lib/dkms/mlnx-ofed-kernel/5.8/build/drivers/infiniband/hw/mlx5/wr.c:131 mlx5_ib_post_send+0x191b/0x1a60 [mlx5_ib]\n Modules linked in: 8021q garp mrp stp llc rdma_ucm(OE) rdma_cm(OE) iw_cm(OE) ib_ipoib(OE) ib_cm(OE) ib_umad(OE) mlx5_ib(OE) ib_uverbs(OE) ib_core(OE) mlx5_core(OE) pci_hyperv_intf mlxdevm(OE) mlx_compat(OE) tls mlxfw(OE) psample nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip_set nf_tables libcrc32c nfnetlink mst_pciconf(OE) knem(OE) vfio_pci vfio_pci_core vfio_iommu_type1 vfio iommufd irqbypass cuse nfsv3 nfs fscache netfs xfrm_user xfrm_algo ipmi_devintf ipmi_msghandler binfmt_misc crct10dif_pclmul crc32_pclmul polyval_clmulni polyval_generic ghash_clmulni_intel sha512_ssse3 snd_pcsp aesni_intel crypto_simd cryptd snd_pcm snd_timer joydev snd soundcore input_leds serio_raw evbug nfsd auth_rpcgss nfs_acl lockd grace sch_fq_codel sunrpc drm efi_pstore ip_tables x_tables autofs4 psmouse virtio_net net_failover failover floppy\n  [last unloaded: mlx_compat(OE)]\n CPU: 0 PID: 293779 Comm: ssh Tainted: G           OE      6.2.0-32-generic #32~22.04.1-Ubuntu\n Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011\n RIP: 0010:mlx5_ib_post_send+0x191b/0x1a60 [mlx5_ib]\n Code: 0c 01 00 a8 01 75 25 48 8b 75 a0 b9 02 00 00 00 48 c7 c2 10 5b fd c0 48 c7 c7 80 5b fd c0 c6 05 57 0c 03 00 01 e8 95 4d 93 da <0f> 0b 44 8b 4d b0 4c 8b 45 c8 48 8b 4d c0 e9 49 fb ff ff 41 0f b7\n RSP: 0018:ffffb5b48478b570 EFLAGS: 00010046\n RAX: 0000000000000000 RBX: 0000000000000001 RCX: 0000000000000000\n RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000\n RBP: ffffb5b48478b628 R08: 0000000000000000 R09: 0000000000000000\n R10: 0000000000000000 R11: 0000000000000000 R12: ffffb5b48478b5e8\n R13: ffff963a3c609b5e R14: ffff9639c3fbd800 R15: ffffb5b480475a80\n FS:  00007fc03b444c80(0000) GS:ffff963a3dc00000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000556f46bdf000 CR3: 0000000006ac6003 CR4: 00000000003706f0\n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n Call Trace:\n  <TASK>\n  ? show_regs+0x72/0x90\n  ? mlx5_ib_post_send+0x191b/0x1a60 [mlx5_ib]\n  ? __warn+0x8d/0x160\n  ? mlx5_ib_post_send+0x191b/0x1a60 [mlx5_ib]\n  ? report_bug+0x1bb/0x1d0\n  ? handle_bug+0x46/0x90\n  ? exc_invalid_op+0x19/0x80\n  ? asm_exc_invalid_op+0x1b/0x20\n  ? mlx5_ib_post_send+0x191b/0x1a60 [mlx5_ib]\n  mlx5_ib_post_send_nodrain+0xb/0x20 [mlx5_ib]\n  ipoib_send+0x2ec/0x770 [ib_ipoib]\n  ipoib_start_xmit+0x5a0/0x770 [ib_ipoib]\n  dev_hard_start_xmit+0x8e/0x1e0\n  ? validate_xmit_skb_list+0x4d/0x80\n  sch_direct_xmit+0x116/0x3a0\n  __dev_xmit_skb+0x1fd/0x580\n  __dev_queue_xmit+0x284/0x6b0\n  ? _raw_spin_unlock_irq+0xe/0x50\n  ? __flush_work.isra.0+0x20d/0x370\n  ? push_pseudo_header+0x17/0x40 [ib_ipoib]\n  neigh_connected_output+0xcd/0x110\n  ip_finish_output2+0x179/0x480\n  ? __smp_call_single_queue+0x61/0xa0\n  __ip_finish_output+0xc3/0x190\n  ip_finish_output+0x2e/0xf0\n  ip_output+0x78/0x110\n  ? __pfx_ip_finish_output+0x10/0x10\n  ip_local_out+0x64/0x70\n  __ip_queue_xmit+0x18a/0x460\n  ip_queue_xmit+0x15/0x30\n  __tcp_transmit_skb+0x914/0x9c0\n  tcp_write_xmit+0x334/0x8d0\n  tcp_push_one+0x3c/0x60\n  tcp_sendmsg_locked+0x2e1/0xac0\n  tcp_sendmsg+0x2d/0x50\n  inet_sendmsg+0x43/0x90\n  sock_sendmsg+0x68/0x80\n  sock_write_iter+0x93/0x100\n  vfs_write+0x326/0x3c0\n  ksys_write+0xbd/0xf0\n  ? do_syscall_64+0x69/0x90\n  __x64_sys_write+0x19/0x30\n  do_syscall_\n---truncated---",Language -  Polymorphism,OOB access,TRUE,TRUE,OOB write
CVE-2024-26895,https://www.cve.org/CVERecord?id=CVE-2024-26895,Linux,"wifi: wilc1000: prevent use-after-free on vif when cleaning up all interfaces\n\nwilc_netdev_cleanup currently triggers a KASAN warning, which can be\nobserved on interface registration error path, or simply by\nremoving the module/unbinding device from driver:\n\necho spi0.1 > /sys/bus/spi/drivers/wilc1000_spi/unbind\n\n==================================================================\nBUG: KASAN: slab-use-after-free in wilc_netdev_cleanup+0x508/0x5cc\nRead of size 4 at addr c54d1ce8 by task sh/86\n\nCPU: 0 PID: 86 Comm: sh Not tainted 6.8.0-rc1+ #117\nHardware name: Atmel SAMA5\n unwind_backtrace from show_stack+0x18/0x1c\n show_stack from dump_stack_lvl+0x34/0x58\n dump_stack_lvl from print_report+0x154/0x500\n print_report from kasan_report+0xac/0xd8\n kasan_report from wilc_netdev_cleanup+0x508/0x5cc\n wilc_netdev_cleanup from wilc_bus_remove+0xc8/0xec\n wilc_bus_remove from spi_remove+0x8c/0xac\n spi_remove from device_release_driver_internal+0x434/0x5f8\n device_release_driver_internal from unbind_store+0xbc/0x108\n unbind_store from kernfs_fop_write_iter+0x398/0x584\n kernfs_fop_write_iter from vfs_write+0x728/0xf88\n vfs_write from ksys_write+0x110/0x1e4\n ksys_write from ret_fast_syscall+0x0/0x1c\n\n[...]\n\nAllocated by task 1:\n kasan_save_track+0x30/0x5c\n __kasan_kmalloc+0x8c/0x94\n __kmalloc_node+0x1cc/0x3e4\n kvmalloc_node+0x48/0x180\n alloc_netdev_mqs+0x68/0x11dc\n alloc_etherdev_mqs+0x28/0x34\n wilc_netdev_ifc_init+0x34/0x8ec\n wilc_cfg80211_init+0x690/0x910\n wilc_bus_probe+0xe0/0x4a0\n spi_probe+0x158/0x1b0\n really_probe+0x270/0xdf4\n __driver_probe_device+0x1dc/0x580\n driver_probe_device+0x60/0x140\n __driver_attach+0x228/0x5d4\n bus_for_each_dev+0x13c/0x1a8\n bus_add_driver+0x2a0/0x608\n driver_register+0x24c/0x578\n do_one_initcall+0x180/0x310\n kernel_init_freeable+0x424/0x484\n kernel_init+0x20/0x148\n ret_from_fork+0x14/0x28\n\nFreed by task 86:\n kasan_save_track+0x30/0x5c\n kasan_save_free_info+0x38/0x58\n __kasan_slab_free+0xe4/0x140\n kfree+0xb0/0x238\n device_release+0xc0/0x2a8\n kobject_put+0x1d4/0x46c\n netdev_run_todo+0x8fc/0x11d0\n wilc_netdev_cleanup+0x1e4/0x5cc\n wilc_bus_remove+0xc8/0xec\n spi_remove+0x8c/0xac\n device_release_driver_internal+0x434/0x5f8\n unbind_store+0xbc/0x108\n kernfs_fop_write_iter+0x398/0x584\n vfs_write+0x728/0xf88\n ksys_write+0x110/0x1e4\n ret_fast_syscall+0x0/0x1c\n [...]\n\nDavid Mosberger-Tan initial investigation [1] showed that this\nuse-after-free is due to netdevice unregistration during vif list\ntraversal. When unregistering a net device, since the needs_free_netdev has\nbeen set to true during registration, the netdevice object is also freed,\nand as a consequence, the corresponding vif object too, since it is\nattached to it as private netdevice data. The next occurrence of the loop\nthen tries to access freed vif pointer to the list to move forward in the\nlist.\n\nFix this use-after-free thanks to two mechanisms:\n- navigate in the list with list_for_each_entry_safe, which allows to\n  safely modify the list as we go through each element. For each element,\n  remove it from the list with list_del_rcu\n- make sure to wait for RCU grace period end after each vif removal to make\n  sure it is safe to free the corresponding vif too (through\n  unregister_netdev)\n\nSince we are in a RCU ""modifier"" path (not a ""reader"" path), and because\nsuch path is expected not to be concurrent to any other modifier (we are\nusing the vif_mutex lock), we do not need to use RCU list API, that's why\nwe can benefit from list_for_each_entry_safe.\n\n[1] https://lore.kernel.org/linux-wireless/ab077dbe58b1ea5de0a3b2ca21f275a07af967d2.camel@egauge.net/",Language - Lifetime violation,Use after free,TRUE,TRUE,The freeing was implicitly triggered outside the current code (needs_free_netdev).
CVE-2024-26882,https://www.cve.org/CVERecord?id=CVE-2024-26882,Linux,"net: ip_tunnel: make sure to pull inner header in ip_tunnel_rcv()\n\nApply the same fix than ones found in :\n\n8d975c15c0cd (""ip6_tunnel: make sure to pull inner header in __ip6_tnl_rcv()"")\n1ca1ba465e55 (""geneve: make sure to pull inner header in geneve_rx()"")\n\nWe have to save skb->network_header in a temporary variable\nin order to be able to recompute the network_header pointer\nafter a pskb_inet_may_pull() call.\n\npskb_inet_may_pull() makes sure the needed headers are in skb->head.\n\nsyzbot reported:\nBUG: KMSAN: uninit-value in __INET_ECN_decapsulate include/net/inet_ecn.h:253 [inline]\n BUG: KMSAN: uninit-value in INET_ECN_decapsulate include/net/inet_ecn.h:275 [inline]\n BUG: KMSAN: uninit-value in IP_ECN_decapsulate include/net/inet_ecn.h:302 [inline]\n BUG: KMSAN: uninit-value in ip_tunnel_rcv+0xed9/0x2ed0 net/ipv4/ip_tunnel.c:409\n  __INET_ECN_decapsulate include/net/inet_ecn.h:253 [inline]\n  INET_ECN_decapsulate include/net/inet_ecn.h:275 [inline]\n  IP_ECN_decapsulate include/net/inet_ecn.h:302 [inline]\n  ip_tunnel_rcv+0xed9/0x2ed0 net/ipv4/ip_tunnel.c:409\n  __ipgre_rcv+0x9bc/0xbc0 net/ipv4/ip_gre.c:389\n  ipgre_rcv net/ipv4/ip_gre.c:411 [inline]\n  gre_rcv+0x423/0x19f0 net/ipv4/ip_gre.c:447\n  gre_rcv+0x2a4/0x390 net/ipv4/gre_demux.c:163\n  ip_protocol_deliver_rcu+0x264/0x1300 net/ipv4/ip_input.c:205\n  ip_local_deliver_finish+0x2b8/0x440 net/ipv4/ip_input.c:233\n  NF_HOOK include/linux/netfilter.h:314 [inline]\n  ip_local_deliver+0x21f/0x490 net/ipv4/ip_input.c:254\n  dst_input include/net/dst.h:461 [inline]\n  ip_rcv_finish net/ipv4/ip_input.c:449 [inline]\n  NF_HOOK include/linux/netfilter.h:314 [inline]\n  ip_rcv+0x46f/0x760 net/ipv4/ip_input.c:569\n  __netif_receive_skb_one_core net/core/dev.c:5534 [inline]\n  __netif_receive_skb+0x1a6/0x5a0 net/core/dev.c:5648\n  netif_receive_skb_internal net/core/dev.c:5734 [inline]\n  netif_receive_skb+0x58/0x660 net/core/dev.c:5793\n  tun_rx_batched+0x3ee/0x980 drivers/net/tun.c:1556\n  tun_get_user+0x53b9/0x66e0 drivers/net/tun.c:2009\n  tun_chr_write_iter+0x3af/0x5d0 drivers/net/tun.c:2055\n  call_write_iter include/linux/fs.h:2087 [inline]\n  new_sync_write fs/read_write.c:497 [inline]\n  vfs_write+0xb6b/0x1520 fs/read_write.c:590\n  ksys_write+0x20f/0x4c0 fs/read_write.c:643\n  __do_sys_write fs/read_write.c:655 [inline]\n  __se_sys_write fs/read_write.c:652 [inline]\n  __x64_sys_write+0x93/0xd0 fs/read_write.c:652\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcf/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x63/0x6b\n\nUninit was created at:\n  __alloc_pages+0x9a6/0xe00 mm/page_alloc.c:4590\n  alloc_pages_mpol+0x62b/0x9d0 mm/mempolicy.c:2133\n  alloc_pages+0x1be/0x1e0 mm/mempolicy.c:2204\n  skb_page_frag_refill+0x2bf/0x7c0 net/core/sock.c:2909\n  tun_build_skb drivers/net/tun.c:1686 [inline]\n  tun_get_user+0xe0a/0x66e0 drivers/net/tun.c:1826\n  tun_chr_write_iter+0x3af/0x5d0 drivers/net/tun.c:2055\n  call_write_iter include/linux/fs.h:2087 [inline]\n  new_sync_write fs/read_write.c:497 [inline]\n  vfs_write+0xb6b/0x1520 fs/read_write.c:590\n  ksys_write+0x20f/0x4c0 fs/read_write.c:643\n  __do_sys_write fs/read_write.c:655 [inline]\n  __se_sys_write fs/read_write.c:652 [inline]\n  __x64_sys_write+0x93/0xd0 fs/read_write.c:652\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcf/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x63/0x6b",Semantic - Logic error,Uninitialized memory access,FALSE,TRUE,The previous code didn't recompute the network header offset and causes invalid access to uninitalized data.
CVE-2024-26867,https://www.cve.org/CVERecord?id=CVE-2024-26867,Linux,"comedi: comedi_8255: Correct error in subdevice initialization\n\nThe refactoring done in commit 5c57b1ccecc7 (""comedi: comedi_8255: Rework\nsubdevice initialization functions"") to the initialization of the io\nfield of struct subdev_8255_private broke all cards using the\ndrivers/comedi/drivers/comedi_8255.c module.\n\nPrior to 5c57b1ccecc7, __subdev_8255_init() initialized the io field\nin the newly allocated struct subdev_8255_private to the non-NULL\ncallback given to the function, otherwise it used a flag parameter to\nselect between subdev_8255_mmio and subdev_8255_io. The refactoring\nremoved that logic and the flag, as subdev_8255_mm_init() and\nsubdev_8255_io_init() now explicitly pass subdev_8255_mmio and\nsubdev_8255_io respectively to __subdev_8255_init(), only\n__subdev_8255_init() never sets spriv->io to the supplied\ncallback. That spriv->io is NULL leads to a later BUG:\n\nBUG: kernel NULL pointer dereference, address: 0000000000000000\nPGD 0 P4D 0\nOops: 0010 [#1] SMP PTI\nCPU: 1 PID: 1210 Comm: systemd-udevd Not tainted 6.7.3-x86_64 #1\nHardware name: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nRIP: 0010:0x0\nCode: Unable to access opcode bytes at 0xffffffffffffffd6.\nRSP: 0018:ffffa3f1c02d7b78 EFLAGS: 00010202\nRAX: 0000000000000000 RBX: ffff91f847aefd00 RCX: 000000000000009b\nRDX: 0000000000000003 RSI: 0000000000000001 RDI: ffff91f840f6fc00\nRBP: ffff91f840f6fc00 R08: 0000000000000000 R09: 0000000000000001\nR10: 0000000000000000 R11: 000000000000005f R12: 0000000000000000\nR13: 0000000000000000 R14: ffffffffc0102498 R15: ffff91f847ce6ba8\nFS:  00007f72f4e8f500(0000) GS:ffff91f8d5c80000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: ffffffffffffffd6 CR3: 000000010540e000 CR4: 00000000000406f0\nCall Trace:\n <TASK>\n ? __die_body+0x15/0x57\n ? page_fault_oops+0x2ef/0x33c\n ? insert_vmap_area.constprop.0+0xb6/0xd5\n ? alloc_vmap_area+0x529/0x5ee\n ? exc_page_fault+0x15a/0x489\n ? asm_exc_page_fault+0x22/0x30\n __subdev_8255_init+0x79/0x8d [comedi_8255]\n pci_8255_auto_attach+0x11a/0x139 [8255_pci]\n comedi_auto_config+0xac/0x117 [comedi]\n ? __pfx___driver_attach+0x10/0x10\n pci_device_probe+0x88/0xf9\n really_probe+0x101/0x248\n __driver_probe_device+0xbb/0xed\n driver_probe_device+0x1a/0x72\n __driver_attach+0xd4/0xed\n bus_for_each_dev+0x76/0xb8\n bus_add_driver+0xbe/0x1be\n driver_register+0x9a/0xd8\n comedi_pci_driver_register+0x28/0x48 [comedi_pci]\n ? __pfx_pci_8255_driver_init+0x10/0x10 [8255_pci]\n do_one_initcall+0x72/0x183\n do_init_module+0x5b/0x1e8\n init_module_from_file+0x86/0xac\n __do_sys_finit_module+0x151/0x218\n do_syscall_64+0x72/0xdb\n entry_SYSCALL_64_after_hwframe+0x6e/0x76\nRIP: 0033:0x7f72f50a0cb9\nCode: ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 47 71 0c 00 f7 d8 64 89 01 48\nRSP: 002b:00007ffd47e512d8 EFLAGS: 00000246 ORIG_RAX: 0000000000000139\nRAX: ffffffffffffffda RBX: 0000562dd06ae070 RCX: 00007f72f50a0cb9\nRDX: 0000000000000000 RSI: 00007f72f52d32df RDI: 000000000000000e\nRBP: 0000000000000000 R08: 00007f72f5168b20 R09: 0000000000000000\nR10: 0000000000000050 R11: 0000000000000246 R12: 00007f72f52d32df\nR13: 0000000000020000 R14: 0000562dd06785c0 R15: 0000562dcfd0e9a8\n </TASK>\nModules linked in: 8255_pci(+) comedi_8255 comedi_pci comedi intel_gtt e100(+) acpi_cpufreq rtc_cmos usbhid\nCR2: 0000000000000000\n---[ end trace 0000000000000000 ]---\nRIP: 0010:0x0\nCode: Unable to access opcode bytes at 0xffffffffffffffd6.\nRSP: 0018:ffffa3f1c02d7b78 EFLAGS: 00010202\nRAX: 0000000000000000 RBX: ffff91f847aefd00 RCX: 000000000000009b\nRDX: 0000000000000003 RSI: 0000000000000001 RDI: ffff91f840f6fc00\nRBP: ffff91f840f6fc00 R08: 0000000000000000 R09: 0000000000000001\nR10: 0000000000000000 R11: 000000000000005f R12: 0000000000000000\nR13: 0000000000000000 R14: ffffffffc0102498 R15: ffff91f847ce6ba8\nFS: \n---truncated---",Language - Improper memory initialization,Invalid pointer dereference,TRUE,TRUE,"The previous code didn't initialize the pointer which stayed NULL. In Rust, this would be modeled as Option which forces explicit unwrapping."
CVE-2024-26857,https://www.cve.org/CVERecord?id=CVE-2024-26857,Linux,"geneve: make sure to pull inner header in geneve_rx()\n\nsyzbot triggered a bug in geneve_rx() [1]\n\nIssue is similar to the one I fixed in commit 8d975c15c0cd\n(""ip6_tunnel: make sure to pull inner header in __ip6_tnl_rcv()"")\n\nWe have to save skb->network_header in a temporary variable\nin order to be able to recompute the network_header pointer\nafter a pskb_inet_may_pull() call.\n\npskb_inet_may_pull() makes sure the needed headers are in skb->head.\n\n[1]\nBUG: KMSAN: uninit-value in IP_ECN_decapsulate include/net/inet_ecn.h:302 [inline]\n BUG: KMSAN: uninit-value in geneve_rx drivers/net/geneve.c:279 [inline]\n BUG: KMSAN: uninit-value in geneve_udp_encap_recv+0x36f9/0x3c10 drivers/net/geneve.c:391\n  IP_ECN_decapsulate include/net/inet_ecn.h:302 [inline]\n  geneve_rx drivers/net/geneve.c:279 [inline]\n  geneve_udp_encap_recv+0x36f9/0x3c10 drivers/net/geneve.c:391\n  udp_queue_rcv_one_skb+0x1d39/0x1f20 net/ipv4/udp.c:2108\n  udp_queue_rcv_skb+0x6ae/0x6e0 net/ipv4/udp.c:2186\n  udp_unicast_rcv_skb+0x184/0x4b0 net/ipv4/udp.c:2346\n  __udp4_lib_rcv+0x1c6b/0x3010 net/ipv4/udp.c:2422\n  udp_rcv+0x7d/0xa0 net/ipv4/udp.c:2604\n  ip_protocol_deliver_rcu+0x264/0x1300 net/ipv4/ip_input.c:205\n  ip_local_deliver_finish+0x2b8/0x440 net/ipv4/ip_input.c:233\n  NF_HOOK include/linux/netfilter.h:314 [inline]\n  ip_local_deliver+0x21f/0x490 net/ipv4/ip_input.c:254\n  dst_input include/net/dst.h:461 [inline]\n  ip_rcv_finish net/ipv4/ip_input.c:449 [inline]\n  NF_HOOK include/linux/netfilter.h:314 [inline]\n  ip_rcv+0x46f/0x760 net/ipv4/ip_input.c:569\n  __netif_receive_skb_one_core net/core/dev.c:5534 [inline]\n  __netif_receive_skb+0x1a6/0x5a0 net/core/dev.c:5648\n  process_backlog+0x480/0x8b0 net/core/dev.c:5976\n  __napi_poll+0xe3/0x980 net/core/dev.c:6576\n  napi_poll net/core/dev.c:6645 [inline]\n  net_rx_action+0x8b8/0x1870 net/core/dev.c:6778\n  __do_softirq+0x1b7/0x7c5 kernel/softirq.c:553\n  do_softirq+0x9a/0xf0 kernel/softirq.c:454\n  __local_bh_enable_ip+0x9b/0xa0 kernel/softirq.c:381\n  local_bh_enable include/linux/bottom_half.h:33 [inline]\n  rcu_read_unlock_bh include/linux/rcupdate.h:820 [inline]\n  __dev_queue_xmit+0x2768/0x51c0 net/core/dev.c:4378\n  dev_queue_xmit include/linux/netdevice.h:3171 [inline]\n  packet_xmit+0x9c/0x6b0 net/packet/af_packet.c:276\n  packet_snd net/packet/af_packet.c:3081 [inline]\n  packet_sendmsg+0x8aef/0x9f10 net/packet/af_packet.c:3113\n  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg net/socket.c:745 [inline]\n  __sys_sendto+0x735/0xa10 net/socket.c:2191\n  __do_sys_sendto net/socket.c:2203 [inline]\n  __se_sys_sendto net/socket.c:2199 [inline]\n  __x64_sys_sendto+0x125/0x1c0 net/socket.c:2199\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcf/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x63/0x6b\n\nUninit was created at:\n  slab_post_alloc_hook mm/slub.c:3819 [inline]\n  slab_alloc_node mm/slub.c:3860 [inline]\n  kmem_cache_alloc_node+0x5cb/0xbc0 mm/slub.c:3903\n  kmalloc_reserve+0x13d/0x4a0 net/core/skbuff.c:560\n  __alloc_skb+0x352/0x790 net/core/skbuff.c:651\n  alloc_skb include/linux/skbuff.h:1296 [inline]\n  alloc_skb_with_frags+0xc8/0xbd0 net/core/skbuff.c:6394\n  sock_alloc_send_pskb+0xa80/0xbf0 net/core/sock.c:2783\n  packet_alloc_skb net/packet/af_packet.c:2930 [inline]\n  packet_snd net/packet/af_packet.c:3024 [inline]\n  packet_sendmsg+0x70c2/0x9f10 net/packet/af_packet.c:3113\n  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg net/socket.c:745 [inline]\n  __sys_sendto+0x735/0xa10 net/socket.c:2191\n  __do_sys_sendto net/socket.c:2203 [inline]\n  __se_sys_sendto net/socket.c:2199 [inline]\n  __x64_sys_sendto+0x125/0x1c0 net/socket.c:2199\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcf/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x63/0x6b",Semantic - Logic error,Uninitialized memory access,FALSE,FALSE,See CVE-2024-26882
CVE-2024-26798,https://www.cve.org/CVERecord?id=CVE-2024-26798,Linux,"fbcon: always restore the old font data in fbcon_do_set_font()\n\nCommit a5a923038d70 (fbdev: fbcon: Properly revert changes when\nvc_resize() failed) started restoring old font data upon failure (of\nvc_resize()). But it performs so only for user fonts. It means that the\n""system""/internal fonts are not restored at all. So in result, the very\nfirst call to fbcon_do_set_font() performs no restore at all upon\nfailing vc_resize().\n\nThis can be reproduced by Syzkaller to crash the system on the next\ninvocation of font_get(). It's rather hard to hit the allocation failure\nin vc_resize() on the first font_set(), but not impossible. Esp. if\nfault injection is used to aid the execution/failure. It was\ndemonstrated by Sirius:\n  BUG: unable to handle page fault for address: fffffffffffffff8\n  #PF: supervisor read access in kernel mode\n  #PF: error_code(0x0000) - not-present page\n  PGD cb7b067 P4D cb7b067 PUD cb7d067 PMD 0\n  Oops: 0000 [#1] PREEMPT SMP KASAN\n  CPU: 1 PID: 8007 Comm: poc Not tainted 6.7.0-g9d1694dc91ce #20\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\n  RIP: 0010:fbcon_get_font+0x229/0x800 drivers/video/fbdev/core/fbcon.c:2286\n  Call Trace:\n   <TASK>\n   con_font_get drivers/tty/vt/vt.c:4558 [inline]\n   con_font_op+0x1fc/0xf20 drivers/tty/vt/vt.c:4673\n   vt_k_ioctl drivers/tty/vt/vt_ioctl.c:474 [inline]\n   vt_ioctl+0x632/0x2ec0 drivers/tty/vt/vt_ioctl.c:752\n   tty_ioctl+0x6f8/0x1570 drivers/tty/tty_io.c:2803\n   vfs_ioctl fs/ioctl.c:51 [inline]\n  ...\n\nSo restore the font data in any case, not only for user fonts. Note the\nlater 'if' is now protected by 'old_userfont' and not 'old_data' as the\nlatter is always set now. (And it is supposed to be non-NULL. Otherwise\nwe would see the bug above again.)",Protocol - Missing Protocol Steps,Invalid pointer dereference,TRUE,TRUE,Page fault due to uninitialized memory access
CVE-2024-26797,https://www.cve.org/CVERecord?id=CVE-2024-26797,Linux,"drm/amd/display: Prevent potential buffer overflow in map_hw_resources\n\nAdds a check in the map_hw_resources function to prevent a potential\nbuffer overflow. The function was accessing arrays using an index that\ncould potentially be greater than the size of the arrays, leading to a\nbuffer overflow.\n\nAdds a check to ensure that the index is within the bounds of the\narrays. If the index is out of bounds, an error message is printed and\nbreak it will continue execution with just ignoring extra data early to\nprevent the buffer overflow.\n\nReported by smatch:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dml2/dml2_wrapper.c:79 map_hw_resources() error: buffer overflow 'dml2->v20.scratch.dml_to_dc_pipe_mapping.disp_cfg_to_stream_id' 6 <= 7\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dml2/dml2_wrapper.c:81 map_hw_resources() error: buffer overflow 'dml2->v20.scratch.dml_to_dc_pipe_mapping.disp_cfg_to_plane_id' 6 <= 7",Semantic - Logic error,OOB access,TRUE,TRUE,
CVE-2024-26753,https://www.cve.org/CVERecord?id=CVE-2024-26753,Linux,"crypto: virtio/akcipher - Fix stack overflow on memcpy\n\nsizeof(struct virtio_crypto_akcipher_session_para) is less than\nsizeof(struct virtio_crypto_op_ctrl_req::u), copying more bytes from\nstack variable leads stack overflow. Clang reports this issue by\ncommands:\nmake -j CC=clang-14 mrproper >/dev/null 2>&1\nmake -j O=/tmp/crypto-build CC=clang-14 allmodconfig >/dev/null 2>&1\nmake -j O=/tmp/crypto-build W=1 CC=clang-14 drivers/crypto/virtio/\n  virtio_crypto_akcipher_algs.o",Semantic - Logic error,OOB access,TRUE,TRUE,memcpy to wrong type
CVE-2024-26687,https://www.cve.org/CVERecord?id=CVE-2024-26687,Linux,"xen/events: close evtchn after mapping cleanup\n\nshutdown_pirq and startup_pirq are not taking the\nirq_mapping_update_lock because they can't due to lock inversion. Both\nare called with the irq_desc->lock being taking. The lock order,\nhowever, is first irq_mapping_update_lock and then irq_desc->lock.\n\nThis opens multiple races:\n- shutdown_pirq can be interrupted by a function that allocates an event\n  channel:\n\n  CPU0                        CPU1\n  shutdown_pirq {\n    xen_evtchn_close(e)\n                              __startup_pirq {\n                                EVTCHNOP_bind_pirq\n                                  -> returns just freed evtchn e\n                                set_evtchn_to_irq(e, irq)\n                              }\n    xen_irq_info_cleanup() {\n      set_evtchn_to_irq(e, -1)\n    }\n  }\n\n  Assume here event channel e refers here to the same event channel\n  number.\n  After this race the evtchn_to_irq mapping for e is invalid (-1).\n\n- __startup_pirq races with __unbind_from_irq in a similar way. Because\n  __startup_pirq doesn't take irq_mapping_update_lock it can grab the\n  evtchn that __unbind_from_irq is currently freeing and cleaning up. In\n  this case even though the event channel is allocated, its mapping can\n  be unset in evtchn_to_irq.\n\nThe fix is to first cleanup the mappings and then close the event\nchannel. In this way, when an event channel gets allocated it's\npotential previous evtchn_to_irq mappings are guaranteed to be unset already.\nThis is also the reverse order of the allocation where first the event\nchannel is allocated and then the mappings are setup.\n\nOn a 5.10 kernel prior to commit 3fcdaf3d7634 (""xen/events: modify internal\n[un]bind interfaces""), we hit a BUG like the following during probing of NVMe\ndevices. The issue is that during nvme_setup_io_queues, pci_free_irq\nis called for every device which results in a call to shutdown_pirq.\nWith many nvme devices it's therefore likely to hit this race during\nboot because there will be multiple calls to shutdown_pirq and\nstartup_pirq are running potentially in parallel.\n\n  ------------[ cut here ]------------\n  blkfront: xvda: barrier or flush: disabled; persistent grants: enabled; indirect descriptors: enabled; bounce buffer: enabled\n  kernel BUG at drivers/xen/events/events_base.c:499!\n  invalid opcode: 0000 [#1] SMP PTI\n  CPU: 44 PID: 375 Comm: kworker/u257:23 Not tainted 5.10.201-191.748.amzn2.x86_64 #1\n  Hardware name: Xen HVM domU, BIOS 4.11.amazon 08/24/2006\n  Workqueue: nvme-reset-wq nvme_reset_work\n  RIP: 0010:bind_evtchn_to_cpu+0xdf/0xf0\n  Code: 5d 41 5e c3 cc cc cc cc 44 89 f7 e8 2b 55 ad ff 49 89 c5 48 85 c0 0f 84 64 ff ff ff 4c 8b 68 30 41 83 fe ff 0f 85 60 ff ff ff <0f> 0b 66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 0f 1f 44 00 00\n  RSP: 0000:ffffc9000d533b08 EFLAGS: 00010046\n  RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000006\n  RDX: 0000000000000028 RSI: 00000000ffffffff RDI: 00000000ffffffff\n  RBP: ffff888107419680 R08: 0000000000000000 R09: ffffffff82d72b00\n  R10: 0000000000000000 R11: 0000000000000000 R12: 00000000000001ed\n  R13: 0000000000000000 R14: 00000000ffffffff R15: 0000000000000002\n  FS:  0000000000000000(0000) GS:ffff88bc8b500000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 0000000000000000 CR3: 0000000002610001 CR4: 00000000001706e0\n  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n  Call Trace:\n   ? show_trace_log_lvl+0x1c1/0x2d9\n   ? show_trace_log_lvl+0x1c1/0x2d9\n   ? set_affinity_irq+0xdc/0x1c0\n   ? __die_body.cold+0x8/0xd\n   ? die+0x2b/0x50\n   ? do_trap+0x90/0x110\n   ? bind_evtchn_to_cpu+0xdf/0xf0\n   ? do_error_trap+0x65/0x80\n   ? bind_evtchn_to_cpu+0xdf/0xf0\n   ? exc_invalid_op+0x4e/0x70\n   ? bind_evtchn_to_cpu+0xdf/0xf0\n   ? asm_exc_invalid_op+0x12/0x20\n   ? bind_evtchn_to_cpu+0xdf/0x\n---truncated---",Race condition - Improper usage of synchronization primitives,Failure to release CPU,FALSE,TRUE,
CVE-2024-26681,https://www.cve.org/CVERecord?id=CVE-2024-26681,Linux,"netdevsim: avoid potential loop in nsim_dev_trap_report_work()\n\nMany syzbot reports include the following trace [1]\n\nIf nsim_dev_trap_report_work() can not grab the mutex,\nit should rearm itself at least one jiffie later.\n\n[1]\nSending NMI from CPU 1 to CPUs 0:\nNMI backtrace for cpu 0\nCPU: 0 PID: 32383 Comm: kworker/0:2 Not tainted 6.8.0-rc2-syzkaller-00031-g861c0981648f #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 11/17/2023\nWorkqueue: events nsim_dev_trap_report_work\n RIP: 0010:bytes_is_nonzero mm/kasan/generic.c:89 [inline]\n RIP: 0010:memory_is_nonzero mm/kasan/generic.c:104 [inline]\n RIP: 0010:memory_is_poisoned_n mm/kasan/generic.c:129 [inline]\n RIP: 0010:memory_is_poisoned mm/kasan/generic.c:161 [inline]\n RIP: 0010:check_region_inline mm/kasan/generic.c:180 [inline]\n RIP: 0010:kasan_check_range+0x101/0x190 mm/kasan/generic.c:189\nCode: 07 49 39 d1 75 0a 45 3a 11 b8 01 00 00 00 7c 0b 44 89 c2 e8 21 ed ff ff 83 f0 01 5b 5d 41 5c c3 48 85 d2 74 4f 48 01 ea eb 09 <48> 83 c0 01 48 39 d0 74 41 80 38 00 74 f2 eb b6 41 bc 08 00 00 00\nRSP: 0018:ffffc90012dcf998 EFLAGS: 00000046\nRAX: fffffbfff258af1e RBX: fffffbfff258af1f RCX: ffffffff8168eda3\nRDX: fffffbfff258af1f RSI: 0000000000000004 RDI: ffffffff92c578f0\nRBP: fffffbfff258af1e R08: 0000000000000000 R09: fffffbfff258af1e\nR10: ffffffff92c578f3 R11: ffffffff8acbcbc0 R12: 0000000000000002\nR13: ffff88806db38400 R14: 1ffff920025b9f42 R15: ffffffff92c578e8\nFS:  0000000000000000(0000) GS:ffff8880b9800000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 000000c00994e078 CR3: 000000002c250000 CR4: 00000000003506f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <NMI>\n </NMI>\n <TASK>\n  instrument_atomic_read include/linux/instrumented.h:68 [inline]\n  atomic_read include/linux/atomic/atomic-instrumented.h:32 [inline]\n  queued_spin_is_locked include/asm-generic/qspinlock.h:57 [inline]\n  debug_spin_unlock kernel/locking/spinlock_debug.c:101 [inline]\n  do_raw_spin_unlock+0x53/0x230 kernel/locking/spinlock_debug.c:141\n  __raw_spin_unlock_irqrestore include/linux/spinlock_api_smp.h:150 [inline]\n  _raw_spin_unlock_irqrestore+0x22/0x70 kernel/locking/spinlock.c:194\n  debug_object_activate+0x349/0x540 lib/debugobjects.c:726\n  debug_work_activate kernel/workqueue.c:578 [inline]\n  insert_work+0x30/0x230 kernel/workqueue.c:1650\n  __queue_work+0x62e/0x11d0 kernel/workqueue.c:1802\n  __queue_delayed_work+0x1bf/0x270 kernel/workqueue.c:1953\n  queue_delayed_work_on+0x106/0x130 kernel/workqueue.c:1989\n  queue_delayed_work include/linux/workqueue.h:563 [inline]\n  schedule_delayed_work include/linux/workqueue.h:677 [inline]\n  nsim_dev_trap_report_work+0x9c0/0xc80 drivers/net/netdevsim/dev.c:842\n  process_one_work+0x886/0x15d0 kernel/workqueue.c:2633\n  process_scheduled_works kernel/workqueue.c:2706 [inline]\n  worker_thread+0x8b9/0x1290 kernel/workqueue.c:2787\n  kthread+0x2c6/0x3a0 kernel/kthread.c:388\n  ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:147\n  ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:242\n </TASK>",Semantic - Spec error,Failure to release CPU,FALSE,FALSE,"Potential wasteful loop caused by retrying to take a lock immediately. According to spec, after fail to aquire lock wait 0 units of time and try again, changes it to wait 1 unit of time."
CVE-2024-26675,https://www.cve.org/CVERecord?id=CVE-2024-26675,Linux,"ppp_async: limit MRU to 64K\n\nsyzbot triggered a warning [1] in __alloc_pages():\n\nWARN_ON_ONCE_GFP(order > MAX_PAGE_ORDER, gfp)\n\nWillem fixed a similar issue in commit c0a2a1b0d631 (""ppp: limit MRU to 64K"")\n\nAdopt the same sanity check for ppp_async_ioctl(PPPIOCSMRU)\n\n[1]:\n\n WARNING: CPU: 1 PID: 11 at mm/page_alloc.c:4543 __alloc_pages+0x308/0x698 mm/page_alloc.c:4543\nModules linked in:\nCPU: 1 PID: 11 Comm: kworker/u4:0 Not tainted 6.8.0-rc2-syzkaller-g41bccc98fb79 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 11/17/2023\nWorkqueue: events_unbound flush_to_ldisc\npstate: 204000c5 (nzCv daIF +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n pc : __alloc_pages+0x308/0x698 mm/page_alloc.c:4543\n lr : __alloc_pages+0xc8/0x698 mm/page_alloc.c:4537\nsp : ffff800093967580\nx29: ffff800093967660 x28: ffff8000939675a0 x27: dfff800000000000\nx26: ffff70001272ceb4 x25: 0000000000000000 x24: ffff8000939675c0\nx23: 0000000000000000 x22: 0000000000060820 x21: 1ffff0001272ceb8\nx20: ffff8000939675e0 x19: 0000000000000010 x18: ffff800093967120\nx17: ffff800083bded5c x16: ffff80008ac97500 x15: 0000000000000005\nx14: 1ffff0001272cebc x13: 0000000000000000 x12: 0000000000000000\nx11: ffff70001272cec1 x10: 1ffff0001272cec0 x9 : 0000000000000001\nx8 : ffff800091c91000 x7 : 0000000000000000 x6 : 000000000000003f\nx5 : 00000000ffffffff x4 : 0000000000000000 x3 : 0000000000000020\nx2 : 0000000000000008 x1 : 0000000000000000 x0 : ffff8000939675e0\nCall trace:\n  __alloc_pages+0x308/0x698 mm/page_alloc.c:4543\n  __alloc_pages_node include/linux/gfp.h:238 [inline]\n  alloc_pages_node include/linux/gfp.h:261 [inline]\n  __kmalloc_large_node+0xbc/0x1fc mm/slub.c:3926\n  __do_kmalloc_node mm/slub.c:3969 [inline]\n  __kmalloc_node_track_caller+0x418/0x620 mm/slub.c:4001\n  kmalloc_reserve+0x17c/0x23c net/core/skbuff.c:590\n  __alloc_skb+0x1c8/0x3d8 net/core/skbuff.c:651\n  __netdev_alloc_skb+0xb8/0x3e8 net/core/skbuff.c:715\n  netdev_alloc_skb include/linux/skbuff.h:3235 [inline]\n  dev_alloc_skb include/linux/skbuff.h:3248 [inline]\n  ppp_async_input drivers/net/ppp/ppp_async.c:863 [inline]\n  ppp_asynctty_receive+0x588/0x186c drivers/net/ppp/ppp_async.c:341\n  tty_ldisc_receive_buf+0x12c/0x15c drivers/tty/tty_buffer.c:390\n  tty_port_default_receive_buf+0x74/0xac drivers/tty/tty_port.c:37\n  receive_buf drivers/tty/tty_buffer.c:444 [inline]\n  flush_to_ldisc+0x284/0x6e4 drivers/tty/tty_buffer.c:494\n  process_one_work+0x694/0x1204 kernel/workqueue.c:2633\n  process_scheduled_works kernel/workqueue.c:2706 [inline]\n  worker_thread+0x938/0xef4 kernel/workqueue.c:2787\n  kthread+0x288/0x310 kernel/kthread.c:388\n  ret_from_fork+0x10/0x20 arch/arm64/kernel/entry.S:860",Semantic - Improper input validation,High level spec violation,FALSE,FALSE,"ppp_async_ioctl(PPPIOCSMRU) can allow userspace to trigger allocation of a buffer that's too big to be allocated, causing a BUG/DOS. The same can also happen in regular Rust, but RFL's liballoc configuration enforces fallible allocation so the programmable can handle it."
CVE-2024-26672,https://www.cve.org/CVERecord?id=CVE-2024-26672,Linux,"drm/amdgpu: Fix variable 'mca_funcs' dereferenced before NULL check in 'amdgpu_mca_smu_get_mca_entry()'\n\nFixes the below:\n\ndrivers/gpu/drm/amd/amdgpu/amdgpu_mca.c:377 amdgpu_mca_smu_get_mca_entry() warn: variable dereferenced before check 'mca_funcs' (see line 368)\n\n357 int amdgpu_mca_smu_get_mca_entry(struct amdgpu_device *adev,\n\t\t\t\t     enum amdgpu_mca_error_type type,\n358                                  int idx, struct mca_bank_entry *entry)\n359 {\n360         const struct amdgpu_mca_smu_funcs *mca_funcs =\n\t\t\t\t\t\tadev->mca.mca_funcs;\n361         int count;\n362\n363         switch (type) {\n364         case AMDGPU_MCA_ERROR_TYPE_UE:\n365                 count = mca_funcs->max_ue_count;\n\nmca_funcs is dereferenced here.\n\n366                 break;\n367         case AMDGPU_MCA_ERROR_TYPE_CE:\n368                 count = mca_funcs->max_ce_count;\n\nmca_funcs is dereferenced here.\n\n369                 break;\n370         default:\n371                 return -EINVAL;\n372         }\n373\n374         if (idx >= count)\n375                 return -EINVAL;\n376\n377         if (mca_funcs && mca_funcs->mca_get_mca_entry)\n\t        ^^^^^^^^^\n\nChecked too late!",Semantic - Improper input validation,Invalid pointer dereference,TRUE,TRUE,
CVE-2024-26671,https://www.cve.org/CVERecord?id=CVE-2024-26671,Linux,"blk-mq: fix IO hang from sbitmap wakeup race\n\nIn blk_mq_mark_tag_wait(), __add_wait_queue() may be re-ordered\nwith the following blk_mq_get_driver_tag() in case of getting driver\ntag failure.\n\nThen in __sbitmap_queue_wake_up(), waitqueue_active() may not observe\nthe added waiter in blk_mq_mark_tag_wait() and wake up nothing, meantime\nblk_mq_mark_tag_wait() can't get driver tag successfully.\n\nThis issue can be reproduced by running the following test in loop, and\nfio hang can be observed in < 30min when running it on my test VM\nin laptop.\n\n\tmodprobe -r scsi_debug\n\tmodprobe scsi_debug delay=0 dev_size_mb=4096 max_queue=1 host_max_queue=1 submit_queues=4\n\tdev=`ls -d /sys/bus/pseudo/drivers/scsi_debug/adapter*/host*/target*/*/block/* | head -1 | xargs basename`\n\tfio --filename=/dev/""$dev"" --direct=1 --rw=randrw --bs=4k --iodepth=1 \\n       \t\t--runtime=100 --numjobs=40 --time_based --name=test \\n        \t--ioengine=libaio\n\nFix the issue by adding one explicit barrier in blk_mq_mark_tag_wait(), which\nis just fine in case of running out of tag.",Race condition - TOUTOC,Failure to release CPU,FALSE,TRUE,Manual write barrier
CVE-2024-26662,https://www.cve.org/CVERecord?id=CVE-2024-26662,Linux,"drm/amd/display: Fix 'panel_cntl' could be null in 'dcn21_set_backlight_level()'\n\n'panel_cntl' structure used to control the display panel could be null,\ndereferencing it could lead to a null pointer access.\n\nFixes the below:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn21/dcn21_hwseq.c:269 dcn21_set_backlight_level() error: we previously assumed 'panel_cntl' could be null (see line 250)",Semantic - Improper input validation,Invalid pointer dereference,TRUE,TRUE,
CVE-2024-26660,https://www.cve.org/CVERecord?id=CVE-2024-26660,Linux,"drm/amd/display: Implement bounds check for stream encoder creation in DCN301\n\n'stream_enc_regs' array is an array of dcn10_stream_enc_registers\nstructures. The array is initialized with four elements, corresponding\nto the four calls to stream_enc_regs() in the array initializer. This\nmeans that valid indices for this array are 0, 1, 2, and 3.\n\nThe error message 'stream_enc_regs' 4 <= 5 below, is indicating that\nthere is an attempt to access this array with an index of 5, which is\nout of bounds. This could lead to undefined behavior\n\nHere, eng_id is used as an index to access the stream_enc_regs array. If\neng_id is 5, this would result in an out-of-bounds access on the\nstream_enc_regs array.\n\nThus fixing OOB access error in dcn301_stream_encoder_create\nreported by Smatch:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/resource/dcn301/dcn301_resource.c:1011 dcn301_stream_encoder_create() error: buffer overflow 'stream_enc_regs' 4 <= 5",Semantic - Improper input validation,OOB access,TRUE,TRUE,
CVE-2024-26648,https://www.cve.org/CVERecord?id=CVE-2024-26648,Linux,"drm/amd/display: Fix variable deferencing before NULL check in edp_setup_replay()\n\nIn edp_setup_replay(), 'struct dc *dc' & 'struct dmub_replay *replay'\nwas dereferenced before the pointer 'link' & 'replay' NULL check.\n\nFixes the below:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/link/protocols/link_edp_panel_control.c:947 edp_setup_replay() warn: variable dereferenced before check 'link' (see line 933)",Semantic - Logic error,Invalid pointer dereference,TRUE,TRUE,
CVE-2024-26647,https://www.cve.org/CVERecord?id=CVE-2024-26647,Linux,"drm/amd/display: Fix late derefrence 'dsc' check in 'link_set_dsc_pps_packet()'\n\nIn link_set_dsc_pps_packet(), 'struct display_stream_compressor *dsc'\nwas dereferenced in a DC_LOGGER_INIT(dsc->ctx->logger); before the 'dsc'\nNULL pointer check.\n\nFixes the below:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/link/link_dpms.c:905 link_set_dsc_pps_packet() warn: variable dereferenced before check 'dsc' (see line 903)",Semantic - Logic error,Invalid pointer dereference,TRUE,TRUE,
CVE-2024-26641,https://www.cve.org/CVERecord?id=CVE-2024-26641,Linux,"ip6_tunnel: make sure to pull inner header in __ip6_tnl_rcv()\n\nsyzbot found __ip6_tnl_rcv() could access unitiliazed data [1].\n\nCall pskb_inet_may_pull() to fix this, and initialize ipv6h\nvariable after this call as it can change skb->head.\n\n[1]\n BUG: KMSAN: uninit-value in __INET_ECN_decapsulate include/net/inet_ecn.h:253 [inline]\n BUG: KMSAN: uninit-value in INET_ECN_decapsulate include/net/inet_ecn.h:275 [inline]\n BUG: KMSAN: uninit-value in IP6_ECN_decapsulate+0x7df/0x1e50 include/net/inet_ecn.h:321\n  __INET_ECN_decapsulate include/net/inet_ecn.h:253 [inline]\n  INET_ECN_decapsulate include/net/inet_ecn.h:275 [inline]\n  IP6_ECN_decapsulate+0x7df/0x1e50 include/net/inet_ecn.h:321\n  ip6ip6_dscp_ecn_decapsulate+0x178/0x1b0 net/ipv6/ip6_tunnel.c:727\n  __ip6_tnl_rcv+0xd4e/0x1590 net/ipv6/ip6_tunnel.c:845\n  ip6_tnl_rcv+0xce/0x100 net/ipv6/ip6_tunnel.c:888\n gre_rcv+0x143f/0x1870\n  ip6_protocol_deliver_rcu+0xda6/0x2a60 net/ipv6/ip6_input.c:438\n  ip6_input_finish net/ipv6/ip6_input.c:483 [inline]\n  NF_HOOK include/linux/netfilter.h:314 [inline]\n  ip6_input+0x15d/0x430 net/ipv6/ip6_input.c:492\n  ip6_mc_input+0xa7e/0xc80 net/ipv6/ip6_input.c:586\n  dst_input include/net/dst.h:461 [inline]\n  ip6_rcv_finish+0x5db/0x870 net/ipv6/ip6_input.c:79\n  NF_HOOK include/linux/netfilter.h:314 [inline]\n  ipv6_rcv+0xda/0x390 net/ipv6/ip6_input.c:310\n  __netif_receive_skb_one_core net/core/dev.c:5532 [inline]\n  __netif_receive_skb+0x1a6/0x5a0 net/core/dev.c:5646\n  netif_receive_skb_internal net/core/dev.c:5732 [inline]\n  netif_receive_skb+0x58/0x660 net/core/dev.c:5791\n  tun_rx_batched+0x3ee/0x980 drivers/net/tun.c:1555\n  tun_get_user+0x53af/0x66d0 drivers/net/tun.c:2002\n  tun_chr_write_iter+0x3af/0x5d0 drivers/net/tun.c:2048\n  call_write_iter include/linux/fs.h:2084 [inline]\n  new_sync_write fs/read_write.c:497 [inline]\n  vfs_write+0x786/0x1200 fs/read_write.c:590\n  ksys_write+0x20f/0x4c0 fs/read_write.c:643\n  __do_sys_write fs/read_write.c:655 [inline]\n  __se_sys_write fs/read_write.c:652 [inline]\n  __x64_sys_write+0x93/0xd0 fs/read_write.c:652\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0x6d/0x140 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x63/0x6b\n\nUninit was created at:\n  slab_post_alloc_hook+0x129/0xa70 mm/slab.h:768\n  slab_alloc_node mm/slub.c:3478 [inline]\n  kmem_cache_alloc_node+0x5e9/0xb10 mm/slub.c:3523\n  kmalloc_reserve+0x13d/0x4a0 net/core/skbuff.c:560\n  __alloc_skb+0x318/0x740 net/core/skbuff.c:651\n  alloc_skb include/linux/skbuff.h:1286 [inline]\n  alloc_skb_with_frags+0xc8/0xbd0 net/core/skbuff.c:6334\n  sock_alloc_send_pskb+0xa80/0xbf0 net/core/sock.c:2787\n  tun_alloc_skb drivers/net/tun.c:1531 [inline]\n  tun_get_user+0x1e8a/0x66d0 drivers/net/tun.c:1846\n  tun_chr_write_iter+0x3af/0x5d0 drivers/net/tun.c:2048\n  call_write_iter include/linux/fs.h:2084 [inline]\n  new_sync_write fs/read_write.c:497 [inline]\n  vfs_write+0x786/0x1200 fs/read_write.c:590\n  ksys_write+0x20f/0x4c0 fs/read_write.c:643\n  __do_sys_write fs/read_write.c:655 [inline]\n  __se_sys_write fs/read_write.c:652 [inline]\n  __x64_sys_write+0x93/0xd0 fs/read_write.c:652\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0x6d/0x140 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x63/0x6b\n\nCPU: 0 PID: 5034 Comm: syz-executor331 Not tainted 6.7.0-syzkaller-00562-g9f8413c4a66f #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 11/17/2023",Semantic - Logic error,Uninitialized memory access,FALSE,FALSE,See CVE-2024-26882
CVE-2024-26638,https://www.cve.org/CVERecord?id=CVE-2024-26638,Linux,"nbd: always initialize struct msghdr completely\n\nsyzbot complains that msg->msg_get_inq value can be uninitialized [1]\n\nstruct msghdr got many new fields recently, we should always make\nsure their values is zero by default.\n\n[1]\n BUG: KMSAN: uninit-value in tcp_recvmsg+0x686/0xac0 net/ipv4/tcp.c:2571\n  tcp_recvmsg+0x686/0xac0 net/ipv4/tcp.c:2571\n  inet_recvmsg+0x131/0x580 net/ipv4/af_inet.c:879\n  sock_recvmsg_nosec net/socket.c:1044 [inline]\n  sock_recvmsg+0x12b/0x1e0 net/socket.c:1066\n  __sock_xmit+0x236/0x5c0 drivers/block/nbd.c:538\n  nbd_read_reply drivers/block/nbd.c:732 [inline]\n  recv_work+0x262/0x3100 drivers/block/nbd.c:863\n  process_one_work kernel/workqueue.c:2627 [inline]\n  process_scheduled_works+0x104e/0x1e70 kernel/workqueue.c:2700\n  worker_thread+0xf45/0x1490 kernel/workqueue.c:2781\n  kthread+0x3ed/0x540 kernel/kthread.c:388\n  ret_from_fork+0x66/0x80 arch/x86/kernel/process.c:147\n  ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:242\n\nLocal variable msg created at:\n  __sock_xmit+0x4c/0x5c0 drivers/block/nbd.c:513\n  nbd_read_reply drivers/block/nbd.c:732 [inline]\n  recv_work+0x262/0x3100 drivers/block/nbd.c:863\n\nCPU: 1 PID: 7465 Comm: kworker/u5:1 Not tainted 6.7.0-rc7-syzkaller-00041-gf016f7547aee #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 11/17/2023\nWorkqueue: nbd5-recv recv_work",Language - Improper memory initialization,Uninitialized memory access,FALSE,TRUE,Uninitialized value which should be explicitly set to 0
CVE-2024-26625,https://www.cve.org/CVERecord?id=CVE-2024-26625,Linux,"llc: call sock_orphan() at release time\n\nsyzbot reported an interesting trace [1] caused by a stale sk->sk_wq\npointer in a closed llc socket.\n\nIn commit ff7b11aa481f (""net: socket: set sock->sk to NULL after\ncalling proto_ops::release()"") Eric Biggers hinted that some protocols\nare missing a sock_orphan(), we need to perform a full audit.\n\nIn net-next, I plan to clear sock->sk from sock_orphan() and\namend Eric patch to add a warning.\n\n[1]\n BUG: KASAN: slab-use-after-free in list_empty include/linux/list.h:373 [inline]\n BUG: KASAN: slab-use-after-free in waitqueue_active include/linux/wait.h:127 [inline]\n BUG: KASAN: slab-use-after-free in sock_def_write_space_wfree net/core/sock.c:3384 [inline]\n BUG: KASAN: slab-use-after-free in sock_wfree+0x9a8/0x9d0 net/core/sock.c:2468\nRead of size 8 at addr ffff88802f4fc880 by task ksoftirqd/1/27\n\nCPU: 1 PID: 27 Comm: ksoftirqd/1 Not tainted 6.8.0-rc1-syzkaller-00049-g6098d87eaf31 #0\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.2-debian-1.16.2-1 04/01/2014\nCall Trace:\n <TASK>\n  __dump_stack lib/dump_stack.c:88 [inline]\n  dump_stack_lvl+0xd9/0x1b0 lib/dump_stack.c:106\n  print_address_description mm/kasan/report.c:377 [inline]\n  print_report+0xc4/0x620 mm/kasan/report.c:488\n  kasan_report+0xda/0x110 mm/kasan/report.c:601\n  list_empty include/linux/list.h:373 [inline]\n  waitqueue_active include/linux/wait.h:127 [inline]\n  sock_def_write_space_wfree net/core/sock.c:3384 [inline]\n  sock_wfree+0x9a8/0x9d0 net/core/sock.c:2468\n  skb_release_head_state+0xa3/0x2b0 net/core/skbuff.c:1080\n  skb_release_all net/core/skbuff.c:1092 [inline]\n  napi_consume_skb+0x119/0x2b0 net/core/skbuff.c:1404\n  e1000_unmap_and_free_tx_resource+0x144/0x200 drivers/net/ethernet/intel/e1000/e1000_main.c:1970\n  e1000_clean_tx_irq drivers/net/ethernet/intel/e1000/e1000_main.c:3860 [inline]\n  e1000_clean+0x4a1/0x26e0 drivers/net/ethernet/intel/e1000/e1000_main.c:3801\n  __napi_poll.constprop.0+0xb4/0x540 net/core/dev.c:6576\n  napi_poll net/core/dev.c:6645 [inline]\n  net_rx_action+0x956/0xe90 net/core/dev.c:6778\n  __do_softirq+0x21a/0x8de kernel/softirq.c:553\n  run_ksoftirqd kernel/softirq.c:921 [inline]\n  run_ksoftirqd+0x31/0x60 kernel/softirq.c:913\n  smpboot_thread_fn+0x660/0xa10 kernel/smpboot.c:164\n  kthread+0x2c6/0x3a0 kernel/kthread.c:388\n  ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:147\n  ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:242\n </TASK>\n\nAllocated by task 5167:\n  kasan_save_stack+0x33/0x50 mm/kasan/common.c:47\n  kasan_save_track+0x14/0x30 mm/kasan/common.c:68\n  unpoison_slab_object mm/kasan/common.c:314 [inline]\n  __kasan_slab_alloc+0x81/0x90 mm/kasan/common.c:340\n  kasan_slab_alloc include/linux/kasan.h:201 [inline]\n  slab_post_alloc_hook mm/slub.c:3813 [inline]\n  slab_alloc_node mm/slub.c:3860 [inline]\n  kmem_cache_alloc_lru+0x142/0x6f0 mm/slub.c:3879\n  alloc_inode_sb include/linux/fs.h:3019 [inline]\n  sock_alloc_inode+0x25/0x1c0 net/socket.c:308\n  alloc_inode+0x5d/0x220 fs/inode.c:260\n  new_inode_pseudo+0x16/0x80 fs/inode.c:1005\n  sock_alloc+0x40/0x270 net/socket.c:634\n  __sock_create+0xbc/0x800 net/socket.c:1535\n  sock_create net/socket.c:1622 [inline]\n  __sys_socket_create net/socket.c:1659 [inline]\n  __sys_socket+0x14c/0x260 net/socket.c:1706\n  __do_sys_socket net/socket.c:1720 [inline]\n  __se_sys_socket net/socket.c:1718 [inline]\n  __x64_sys_socket+0x72/0xb0 net/socket.c:1718\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xd3/0x250 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x63/0x6b\n\nFreed by task 0:\n  kasan_save_stack+0x33/0x50 mm/kasan/common.c:47\n  kasan_save_track+0x14/0x30 mm/kasan/common.c:68\n  kasan_save_free_info+0x3f/0x60 mm/kasan/generic.c:640\n  poison_slab_object mm/kasan/common.c:241 [inline]\n  __kasan_slab_free+0x121/0x1b0 mm/kasan/common.c:257\n  kasan_slab_free include/linux/kasan.h:184 [inline]\n  slab_free_hook mm/slub.c:2121 [inlin\n---truncated---",Language - Lifetime violation,Use after free,TRUE,TRUE,Removed because not a driver - UAF from missing sock_orphan
CVE-2024-25740,https://www.cve.org/CVERecord?id=CVE-2024-25740,Linux,"A memory leak flaw was found in the UBI driver in drivers/mtd/ubi/attach.c in the Linux kernel through 6.7.4 for UBI_IOCATT, because kobj->name is not released.",Language - Lifetime violation,Resource leak,FALSE,TRUE,
CVE-2024-25739,https://www.cve.org/CVERecord?id=CVE-2024-25739,Linux,"create_empty_lvol in drivers/mtd/ubi/vtbl.c in the Linux kernel through 6.7.4 can attempt to allocate zero bytes, and crash, because of a missing check for ubi->leb_size.",Semantic - Improper input validation,Explicit exception/panic,FALSE,FALSE,
CVE-2024-23851,https://www.cve.org/CVERecord?id=CVE-2024-23851,Linux,"copy_params in drivers/md/dm-ioctl.c in the Linux kernel through 6.7.1 can attempt to allocate more than INT_MAX bytes, and crash, because of a missing param_kernel->data_size check. This is related to ctl_ioctl.",Semantic - Logic error,Explicit exception/panic,FALSE,FALSE,
CVE-2024-23848,https://www.cve.org/CVERecord?id=CVE-2024-23848,Linux,"In the Linux kernel through 6.7.1, there is a use-after-free in cec_queue_msg_fh, related to drivers/media/cec/core/cec-adap.c and drivers/media/cec/core/cec-api.c.",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,
CVE-2024-0340,https://www.cve.org/CVERecord?id=CVE-2024-0340,Linux,"A vulnerability was found in vhost_new_msg in drivers/vhost/vhost.c in the Linux kernel, which does not properly initialize memory in messages passed between virtual guests and the host operating system in the vhost/vhost.c:vhost_new_msg() function. This issue can allow local privileged users to read some kernel memory contents when reading from the /dev/vhost-net device file.",Language - Improper memory initialization,Uninitialized memory access,FALSE,FALSE,Will be Yes+P if we consider WritableToBytes
CVE-2023-50431,https://www.cve.org/CVERecord?id=CVE-2023-50431,Linux,sec_attest_info in drivers/accel/habanalabs/common/habanalabs_ioctl.c in the Linux kernel through 6.6.5 allows an information leak to user space because info->pad0 is not initialized.,Language - Improper memory initialization,Uninitialized memory access,FALSE,FALSE,Patch zero'd memory.
CVE-2023-47233,https://www.cve.org/CVERecord?id=CVE-2023-47233,Linux,"The brcm80211 component in the Linux kernel through 6.5.10 has a brcmf_cfg80211_detach use-after-free in the device unplugging (disconnect the USB by hotplug) code. For physically proximate attackers with local access, this ""could be exploited in a real world scenario."" This is related to brcmf_cfg80211_escan_timeout_worker in drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c.",Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't remove associated timer on clean up, which could cause UAF."
CVE-2023-45871,https://www.cve.org/CVERecord?id=CVE-2023-45871,Linux,An issue was discovered in drivers/net/ethernet/intel/igb/igb_main.c in the IGB driver in the Linux kernel before 6.5.3. A buffer size may not be adequate for frames larger than the MTU.,Semantic - Logic error,OOB access,TRUE,TRUE,Missed edgecase that requires larger buffer.
CVE-2023-45862,https://www.cve.org/CVERecord?id=CVE-2023-45862,Linux,An issue was discovered in drivers/usb/storage/ene_ub6250.c for the ENE UB6250 reader driver in the Linux kernel before 6.2.5. An object could potentially extend beyond the end of an allocation.,Semantic - Logic error,OOB access,TRUE,TRUE,Not enough memory allocated for buffer. Logic bug where offset is not taken into account for size calculation.
CVE-2023-39198,https://www.cve.org/CVERecord?id=CVE-2023-39198,Linux,"A race condition was found in the QXL driver in the Linux kernel. The qxl_mode_dumb_create() function dereferences the qobj returned by the qxl_gem_object_create_with_handle(), but the handle is the only one holding a reference to it. This flaw allows an attacker to guess the returned handle value and trigger a use-after-free issue, potentially leading to a denial of service or privilege escalation.",Semantic - Spec error,Use after free,TRUE,TRUE,"Bad spec design, which passed around a refrence could lead to UAF. Patch reworked spec to pass the object directly."
CVE-2023-38409,https://www.cve.org/CVERecord?id=CVE-2023-38409,Linux,"An issue was discovered in set_con2fb_map in drivers/video/fbdev/core/fbcon.c in the Linux kernel before 6.2.12. Because an assignment occurs only for the first vc, the fbcon_registered_fb and fbcon_display arrays can be desynchronized in fbcon_mode_deleted (the con2fb_map points at the old fb_info).",Semantic - Logic error,Use after free,TRUE,FALSE,"During the code restructuring, the assignment was moved into an if block, but should have been there for all the cases. Even if you write it in Rust, this won't prevent this attack"
CVE-2023-37453,https://www.cve.org/CVERecord?id=CVE-2023-37453,Linux,An issue was discovered in the USB subsystem in the Linux kernel through 6.4.2. There is an out-of-bounds and crash in read_descriptors in drivers/usb/core/sysfs.c.,Semantic - Spec error,OOB access,TRUE,TRUE,"Error in spec allowed for race condition. This race lead to OOB access, the patch had to change the spec to fix. https://bugzilla.redhat.com/show_bug.cgi?id=2221039"
CVE-2023-35829,https://www.cve.org/CVERecord?id=CVE-2023-35829,Linux,An issue was discovered in the Linux kernel before 6.3.2. A use-after-free was found in rkvdec_remove in drivers/staging/media/rkvdec/rkvdec.c.,Language - Lifetime violation,Use after free,TRUE,TRUE,Didn't cancel pending work on tear down.
CVE-2023-35828,https://www.cve.org/CVERecord?id=CVE-2023-35828,Linux,An issue was discovered in the Linux kernel before 6.3.2. A use-after-free was found in renesas_usb3_remove in drivers/usb/gadget/udc/renesas_usb3.c.,Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't cancel pending work on tear down, leading to UAF. "
CVE-2023-35827,https://www.cve.org/CVERecord?id=CVE-2023-35827,Linux,An issue was discovered in the Linux kernel through 6.3.8. A use-after-free was found in ravb_remove in drivers/net/ethernet/renesas/ravb_main.c.,Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't cancel pending work on tear down, leading to UAF."
CVE-2023-35826,https://www.cve.org/CVERecord?id=CVE-2023-35826,Linux,An issue was discovered in the Linux kernel before 6.3.2. A use-after-free was found in cedrus_remove in drivers/staging/media/sunxi/cedrus/cedrus.c.,Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't cancel pending work on tear down, leading to UAF."
CVE-2023-35824,https://www.cve.org/CVERecord?id=CVE-2023-35824,Linux,An issue was discovered in the Linux kernel before 6.3.2. A use-after-free was found in dm1105_remove in drivers/media/pci/dm1105/dm1105.c.,Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't cancel pending work on tear down, leading to UAF."
CVE-2023-35823,https://www.cve.org/CVERecord?id=CVE-2023-35823,Linux,An issue was discovered in the Linux kernel before 6.3.2. A use-after-free was found in saa7134_finidev in drivers/media/pci/saa7134/saa7134-core.c.,Language - Lifetime violation,Use after free,TRUE,TRUE,Didn't remove timers on cleanup leading to potential UAF.
CVE-2023-33952,https://www.cve.org/CVERecord?id=CVE-2023-33952,Linux,A double-free vulnerability was found in the vmwgfx driver in the Linux kernel. The flaw exists within the handling of vmw_buffer_object objects. The issue results from the lack of validating the existence of an object prior to performing further free operations on the object. This flaw allows a local privileged user to escalate privileges and execute code in the context of the kernel.,Language - Lifetime violation,Double free,FALSE,TRUE,*User able to trigger an early free. Which caused double free when clean up happens. CVE issued because there is no checks prior to free.
CVE-2023-33951,https://www.cve.org/CVERecord?id=CVE-2023-33951,Linux,A race condition vulnerability was found in the vmwgfx driver in the Linux kernel. The flaw exists within the handling of GEM objects. The issue results from improper locking when performing operations on an object. This flaw allows a local privileged user to disclose information in the context of the kernel.,Language - Lifetime violation,Use after free,TRUE,TRUE,*User able to trigger an early free. CVE issued for UAF during rest of lifetime.
CVE-2023-33288,https://www.cve.org/CVERecord?id=CVE-2023-33288,Linux,An issue was discovered in the Linux kernel before 6.2.9. A use-after-free was found in bq24190_remove in drivers/power/supply/bq24190_charger.c. It could allow a local attacker to crash the system due to a race condition.,Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't cancel pending work on tear down, leading to UAF."
CVE-2023-33250,https://www.cve.org/CVERecord?id=CVE-2023-33250,Linux,The Linux kernel 6.3 has a use-after-free in iopt_unmap_iova_range in drivers/iommu/iommufd/io_pagetable.c.,Race condition - TOUTOC,Use after free,TRUE,TRUE,Race condition in protocol allowed UAF.
CVE-2023-33203,https://www.cve.org/CVERecord?id=CVE-2023-33203,Linux,The Linux kernel before 6.2.9 has a race condition and resultant use-after-free in drivers/net/ethernet/qualcomm/emac/emac.c if a physically proximate attacker unplugs an emac based device.,Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't cancel pending work on tear down, leading to UAF."
CVE-2023-32810,https://www.cve.org/CVERecord?id=CVE-2023-32810,Linux,"In bluetooth driver, there is a possible out of bounds read due to improper input validation. This could lead to local information leak with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07867212; Issue ID: ALPS07867212.",Semantic - Improper input validation,OOB access,TRUE,TRUE,
CVE-2023-31085,https://www.cve.org/CVERecord?id=CVE-2023-31085,Linux,"An issue was discovered in drivers/mtd/ubi/cdev.c in the Linux kernel 6.2. There is a divide-by-zero error in do_div(sz,mtd->erasesize), used indirectly by ctrl_cdev_ioctl, when mtd->erasesize is 0.",Semantic - Improper input validation,Explicit exception/panic,FALSE,TRUE,Divison by 0 due to improper check.
CVE-2023-31084,https://www.cve.org/CVERecord?id=CVE-2023-31084,Linux,"An issue was discovered in drivers/media/dvb-core/dvb_frontend.c in the Linux kernel 6.2. There is a blocking operation when a task is in !TASK_RUNNING. In dvb_frontend_get_event, wait_event_interruptible is called; the condition is dvb_frontend_test_event(fepriv,events). In dvb_frontend_test_event, down(&fepriv->sem) is called. However, wait_event_interruptible would put the process to sleep, and down(&fepriv->sem) may block the process.",Race condition - Improper usage of synchronization primitives,Failure to release CPU,FALSE,FALSE,"wait_event_interruptible(queue, dvb_frontend_test_event(fepriv, events));
dvb_frontend_test_event can potentially perform blocking operation, which violates spec of wait_event"
CVE-2023-31083,https://www.cve.org/CVERecord?id=CVE-2023-31083,Linux,"An issue was discovered in drivers/bluetooth/hci_ldisc.c in the Linux kernel 6.2. In hci_uart_tty_ioctl, there is a race condition between HCIUARTSETPROTO and HCIUARTGETPROTO. HCI_UART_PROTO_SET is set before hu->proto is set. A NULL pointer dereference may occur.",Race condition - TOUTOC,Use after free,TRUE,TRUE,
CVE-2023-31082,https://www.cve.org/CVERecord?id=CVE-2023-31082,Linux,"An issue was discovered in drivers/tty/n_gsm.c in the Linux kernel 6.2. There is a sleeping function called from an invalid context in gsmld_write, which will block the kernel.",Protocol - Sleeping in atomic context,Failure to release CPU,FALSE,FALSE,*
CVE-2023-31081,https://www.cve.org/CVERecord?id=CVE-2023-31081,Linux,"An issue was discovered in drivers/media/test-drivers/vidtv/vidtv_bridge.c in the Linux kernel 6.2. There is a NULL pointer dereference in vidtv_mux_stop_thread. In vidtv_stop_streaming, after dvb->mux=NULL occurs, it executes vidtv_mux_stop_thread(dvb->mux).",Race condition - TOUTOC,Invalid pointer dereference,TRUE,TRUE,Race in protocol which allows for a function to be called with a pointer that has been set to null.
CVE-2023-30772,https://www.cve.org/CVERecord?id=CVE-2023-30772,Linux,The Linux kernel before 6.2.9 has a race condition and resultant use-after-free in drivers/power/supply/da9150-charger.c if a physically proximate attacker unplugs a device.,Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't cancel queue'd work on clean up, could lead to UAF."
CVE-2023-28328,https://www.cve.org/CVERecord?id=CVE-2023-28328,Linux,A NULL pointer dereference flaw was found in the az6027 driver in drivers/media/usb/dev-usb/az6027.c in the Linux Kernel. The message from user space is not checked properly before transferring into the device. This flaw allows a local user to crash the system or potentially cause a denial of service.,Semantic - Improper input validation,Invalid pointer dereference,TRUE,TRUE,User input edge cases cause null pointer dereferences. 
CVE-2023-26242,https://www.cve.org/CVERecord?id=CVE-2023-26242,Linux,afu_mmio_region_get_by_offset in drivers/fpga/dfl-afu-region.c in the Linux kernel through 6.1.12 has an integer overflow.,Language - Integer overflow,OOB access,TRUE,TRUE,Overflow possible leading to mismatch between size allocated and the intended size.
CVE-2023-25012,https://www.cve.org/CVERecord?id=CVE-2023-25012,Linux,The Linux kernel through 6.1.9 has a Use-After-Free in bigben_remove in drivers/hid/hid-bigbenff.c via a crafted USB device because the LED controllers remain registered for too long.,Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't unregister device properly on clean up, leading to potential UAF."
CVE-2023-23559,https://www.cve.org/CVERecord?id=CVE-2023-23559,Linux,"In rndis_query_oid in drivers/net/wireless/rndis_wlan.c in the Linux kernel through 6.1.5, there is an integer overflow in an addition.",Language - Integer overflow,OOB access,TRUE,TRUE,"Ints in buffer operations could overflow to negative values, leading to buffer overflow vulnerabilities."
CVE-2023-23039,https://www.cve.org/CVERecord?id=CVE-2023-23039,Linux,"An issue was discovered in the Linux kernel through 6.2.0-rc2. drivers/tty/vcc.c has a race condition and resultant use-after-free if a physically proximate attacker removes a VCC device while calling open(), aka a race condition between vcc_open() and vcc_remove().",Race condition - TOUTOC,Use after free,TRUE,TRUE,"*The race will be solved by reference counting primitives in Rust. Race condition on physical removal of device may leave stale references, leading to UAF."
CVE-2023-23006,https://www.cve.org/CVERecord?id=CVE-2023-23006,Linux,"In the Linux kernel before 5.15.13, drivers/net/ethernet/mellanox/mlx5/core/steering/dr_domain.c misinterprets the mlx5_get_uars_page return value (expects it to be NULL in the error case, whereas it is actually an error pointer).",Language -  Polymorphism,Invalid pointer dereference,TRUE,TRUE,"Not checking error pointer correctly. Assumes error pointer == null, which isn't true in this case."
CVE-2023-23004,https://www.cve.org/CVERecord?id=CVE-2023-23004,Linux,"In the Linux kernel before 5.19, drivers/gpu/drm/arm/malidp_planes.c misinterprets the get_sg_table return value (expects it to be NULL in the error case, whereas it is actually an error pointer).",Language -  Polymorphism,Invalid pointer dereference,TRUE,TRUE,"Not checking error pointer correctly. Assumes error pointer == null, which isn't true in this case."
CVE-2023-23002,https://www.cve.org/CVERecord?id=CVE-2023-23002,Linux,"In the Linux kernel before 5.16.3, drivers/bluetooth/hci_qca.c misinterprets the devm_gpiod_get_index_optional return value (expects it to be NULL in the error case, whereas it is actually an error pointer).",Language -  Polymorphism,Invalid pointer dereference,TRUE,TRUE,"Not checking error pointer correctly. Could be error pointer or null so should use IS_ERR_OR_NULL(), which it doesn't."
CVE-2023-23001,https://www.cve.org/CVERecord?id=CVE-2023-23001,Linux,"In the Linux kernel before 5.16.3, drivers/scsi/ufs/ufs-mediatek.c misinterprets the regulator_get return value (expects it to be NULL in the error case, whereas it is actually an error pointer).",Language -  Polymorphism,Invalid pointer dereference,TRUE,TRUE,"Not checking error pointer correctly. Assumes error pointer == null, which isn't true in this case."
CVE-2023-23000,https://www.cve.org/CVERecord?id=CVE-2023-23000,Linux,"In the Linux kernel before 5.17, drivers/phy/tegra/xusb.c mishandles the tegra_xusb_find_port_node return value. Callers expect NULL in the error case, but an error pointer is used.",Language -  Polymorphism,Invalid pointer dereference,TRUE,TRUE,Confusion about whether error pointers should be null.
CVE-2023-22999,https://www.cve.org/CVERecord?id=CVE-2023-22999,Linux,"In the Linux kernel before 5.16.3, drivers/usb/dwc3/dwc3-qcom.c misinterprets the dwc3_qcom_create_urs_usb_platdev return value (expects it to be NULL in the error case, whereas it is actually an error pointer).",Language -  Polymorphism,Invalid pointer dereference,TRUE,TRUE,Checking if null for errors when it could also be an error pointer. Should use IS_ERR_OR_NULL() instead.
CVE-2023-22998,https://www.cve.org/CVERecord?id=CVE-2023-22998,Linux,"In the Linux kernel before 6.0.3, drivers/gpu/drm/virtio/virtgpu_object.c misinterprets the drm_gem_shmem_get_sg_table return value (expects it to be NULL in the error case, whereas it is actually an error pointer).",Language -  Polymorphism,Invalid pointer dereference,TRUE,TRUE,"Not checking error pointer correctly. Assumes error pointer == null, which isn't true in this case."
CVE-2023-22996,https://www.cve.org/CVERecord?id=CVE-2023-22996,Linux,"In the Linux kernel before 5.17.2, drivers/soc/qcom/qcom_aoss.c does not release an of_find_device_by_node reference after use, e.g., with put_device.",Language - Lifetime violation,Resource leak,FALSE,TRUE,Didn't decrease reference count on error path.
CVE-2023-22995,https://www.cve.org/CVERecord?id=CVE-2023-22995,Linux,"In the Linux kernel before 5.17, an error path in dwc3_qcom_acpi_register_core in drivers/usb/dwc3/dwc3-qcom.c lacks certain platform_device_put and kfree calls.",Language - Lifetime violation,Resource leak,FALSE,TRUE,Didn't decrease reference count on error path.
CVE-2023-7042,https://www.cve.org/CVERecord?id=CVE-2023-7042,Linux,A null pointer dereference vulnerability was found in ath10k_wmi_tlv_op_pull_mgmt_tx_compl_ev() in drivers/net/wireless/ath/ath10k/wmi-tlv.c in the Linux kernel. This issue could be exploited to trigger a denial of service.,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,For now
CVE-2023-6238,https://www.cve.org/CVERecord?id=CVE-2023-6238,Linux,"A buffer overflow vulnerability was found in the NVM Express (NVMe) driver in the Linux kernel. Only privileged user could specify a small meta buffer and let the device perform larger Direct Memory Access (DMA) into the same buffer, overwriting unrelated kernel memory, causing random kernel crashes and memory corruption.",Semantic - Improper input validation,OOB access,TRUE,FALSE,The device does DMA outside of the buffer. No Rust can save it. User specified buffer size can be too small.
CVE-2023-6039,https://www.cve.org/CVERecord?id=CVE-2023-6039,Linux,"A use-after-free flaw was found in lan78xx_disconnect in drivers/net/usb/lan78xx.c in the network sub-component, net/usb/lan78xx in the Linux Kernel. This flaw allows a local attacker to crash the system when the LAN78XX USB device detaches.",Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't cancel associated timers on tear down, leading to potential UAF."
CVE-2023-5178,https://www.cve.org/CVERecord?id=CVE-2023-5178,Linux,"A use-after-free vulnerability was found in drivers/nvme/target/tcp.c` in `nvmet_tcp_free_crypto` due to a logical bug in the NVMe/TCP subsystem in the Linux kernel. This issue may allow a malicious user to cause a use-after-free and double-free problem, which may permit remote code execution or lead to local privilege escalation.",Semantic - Logic error,Use after free,TRUE,TRUE,
CVE-2023-5158,https://www.cve.org/CVERecord?id=CVE-2023-5158,Linux,A flaw was found in vringh_kiov_advance in drivers/vhost/vringh.c in the host side of a virtio ring in the Linux Kernel. This issue may result in a denial of service from guest to host via zero length descriptor.,Semantic - Loop termination,Failure to release CPU,FALSE,FALSE,Can cause infinite loop DOS due to logic bug in iterator.
CVE-2023-4387,https://www.cve.org/CVERecord?id=CVE-2023-4387,Linux,"A use-after-free flaw was found in vmxnet3_rq_alloc_rx_buf in drivers/net/vmxnet3/vmxnet3_drv.c in VMware's vmxnet3 ethernet NIC driver in the Linux Kernel. This issue could allow a local attacker to crash the system due to a double-free while cleaning up vmxnet3_rq_cleanup_all, which could also lead to a kernel information leak problem.",Language - Lifetime violation,Double free,FALSE,TRUE,"Free on fail, and tries to free again on clean up."
CVE-2023-4273,https://www.cve.org/CVERecord?id=CVE-2023-4273,Linux,"A flaw was found in the exFAT driver of the Linux kernel. The vulnerability exists in the implementation of the file name reconstruction function, which is responsible for reading file name entries from a directory index and merging file name parts belonging to one file into a single long file name. Since the file name characters are copied into a stack variable, a local privileged attacker could use this flaw to overflow the kernel stack.",Semantic - Improper input validation,OOB access,TRUE,TRUE,"Missing bounds check, which allows user to overflow kernel stack."
CVE-2023-4133,https://www.cve.org/CVERecord?id=CVE-2023-4133,Linux,"A use-after-free vulnerability was found in the cxgb4 driver in the Linux kernel. The bug occurs when the cxgb4 device is detaching due to a possible rearming of the flower_stats_timer from the work queue. This flaw allows a local user to crash the system, causing a denial of service condition.",Semantic - Spec error,Use after free,TRUE,TRUE,Spec error had circular dependency which allowed UAF bugs.
CVE-2023-4010,https://www.cve.org/CVERecord?id=CVE-2023-4010,Linux,"A flaw was found in the USB Host Controller Driver framework in the Linux kernel. The usb_giveback_urb function has a logic loophole in its implementation. Due to the inappropriate judgment condition of the goto statement, the function cannot return under the input of a specific malformed descriptor file, so it falls into an endless loop, resulting in a denial of service.",Semantic - Loop termination,Failure to release CPU,FALSE,FALSE,Logic error in goto condition causes infinite loop.
CVE-2023-3812,https://www.cve.org/CVERecord?id=CVE-2023-3812,Linux,An out-of-bounds memory access flaw was found in the Linux kernel’s TUN/TAP device driver functionality in how a user generates a malicious (too big) networking packet when napi frags is enabled. This flaw allows a local user to crash or potentially escalate their privileges on the system.,Semantic - Improper input validation,OOB access,TRUE,TRUE,Missing edge case in input validation.
CVE-2023-3567,https://www.cve.org/CVERecord?id=CVE-2023-3567,Linux,A use-after-free flaw was found in vcs_read in drivers/tty/vt/vc_screen.c in vc_screen in the Linux Kernel. This issue may allow an attacker with local user access to cause a system crash or leak internal kernel information.,Semantic - Logic error,Use after free,TRUE,TRUE,Wrong logic order of execution order allowed for UAF.
CVE-2023-3359,https://www.cve.org/CVERecord?id=CVE-2023-3359,Linux,An issue was discovered in the Linux kernel brcm_nvram_parse in drivers/nvmem/brcm_nvram.c. Lacks for the check of the return value of kzalloc() can cause the NULL Pointer Dereference.,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,Didn't check return of kzalloc()
CVE-2023-3358,https://www.cve.org/CVERecord?id=CVE-2023-3358,Linux,A null pointer dereference was found in the Linux kernel's Integrated Sensor Hub (ISH) driver. This issue could allow a local user to crash the system.,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,ishtp_dma_tx_map could be null and wasn't checked before dereferencing.
CVE-2023-3357,https://www.cve.org/CVERecord?id=CVE-2023-3357,Linux,A NULL pointer dereference flaw was found in the Linux kernel AMD Sensor Fusion Hub driver. This flaw allows a local user to crash the system.,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,Missing return value check of allocation which returns null on fail.
CVE-2023-3355,https://www.cve.org/CVERecord?id=CVE-2023-3355,Linux,"A NULL pointer dereference flaw was found in the Linux kernel's drivers/gpu/drm/msm/msm_gem_submit.c code in the submit_lookup_cmds function, which fails because it lacks a check of the return value of kmalloc(). This issue allows a local user to crash the system.",Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,Didn't check return of kmalloc()
CVE-2023-3317,https://www.cve.org/CVERecord?id=CVE-2023-3317,Linux,A use-after-free flaw was found in mt7921_check_offload_capability in drivers/net/wireless/mediatek/mt76/mt7921/init.c in wifi mt76/mt7921 sub-component in the Linux Kernel. This flaw could allow an attacker to crash the system after 'features' memory release. This vulnerability could even lead to a kernel information leak problem.,Semantic - Spec error,Use after free,TRUE,TRUE,Spec refrenced free'd memory in turnary operator.
CVE-2023-3312,https://www.cve.org/CVERecord?id=CVE-2023-3312,Linux,"A vulnerability was found in drivers/cpufreq/qcom-cpufreq-hw.c in cpufreq subsystem in the Linux Kernel. This flaw, during device unbind will lead to double release problem leading to denial of service.",Semantic - Spec error,Double free,FALSE,TRUE,"*Double free due to bug in spec, where residual clean up code left from previous commit."
CVE-2023-3220,https://www.cve.org/CVERecord?id=CVE-2023-3220,Linux,An issue was discovered in the Linux kernel through 6.1-rc8. dpu_crtc_atomic_check in drivers/gpu/drm/msm/disp/dpu1/dpu_crtc.c lacks check of the return value of kzalloc() and will cause the NULL Pointer Dereference.,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,Didn't check return of kzalloc()
CVE-2023-3159,https://www.cve.org/CVERecord?id=CVE-2023-3159,Linux,A use after free issue was discovered in driver/firewire in outbound_phy_packet_callback in the Linux Kernel. In this flaw a local attacker with special privilege may cause a use after free problem when queue_event() fails.,Semantic - Spec error,Use after free,TRUE,TRUE,"Same object shared by refrence could lead to UAF, patch makes local copy to avoid UAF. Issue at spec level."
CVE-2023-3141,https://www.cve.org/CVERecord?id=CVE-2023-3141,Linux,"A use-after-free flaw was found in r592_remove in drivers/memstick/host/r592.c in media access in the Linux Kernel. This flaw allows a local attacker to crash the system at device disconnect, possibly leading to a kernel information leak.",Language - Lifetime violation,Use after free,TRUE,TRUE,"Work isn't cancelled on clean up, leading to potential UAF."
CVE-2023-3090,https://www.cve.org/CVERecord?id=CVE-2023-3090,Linux,A heap out-of-bounds write vulnerability in the Linux Kernel ipvlan network driver can be exploited to achieve local privilege escalation.\n\nThe out-of-bounds write is caused by missing skb->cb  initialization in the ipvlan network driver. The vulnerability is reachable if CONFIG_IPVLAN is enabled.\n\n\nWe recommend upgrading past commit 90cbed5247439a966b645b34eb0a2e037836ea8e.,Protocol - Missing Protocol Steps,Invalid pointer dereference,TRUE,TRUE,SKB has a scratchpad buffer (skb->cb) that could be used by any layer. Some one uses it and it is not reset. OOB could happen because of that.
CVE-2023-2269,https://www.cve.org/CVERecord?id=CVE-2023-2269,Linux,"A denial of service problem was found, due to a possible recursive locking scenario, resulting in a deadlock in table_clear in drivers/md/dm-ioctl.c in the Linux Kernel Device Mapper-Multipathing sub-component.",Race condition - Improper usage of synchronization primitives,Failure to release CPU,FALSE,FALSE,For now. This is a deadlock caused by logical bug
CVE-2023-2194,https://www.cve.org/CVERecord?id=CVE-2023-2194,Linux,"An out-of-bounds write vulnerability was found in the Linux kernel's SLIMpro I2C device driver. The userspace ""data->block[0]"" variable was not capped to a number between 0-255 and was used as the size of a memcpy, possibly writing beyond the end of dma_buffer. This flaw could allow a local privileged user to crash the system or potentially achieve code execution.",Semantic - Improper input validation,OOB access,TRUE,TRUE,Didn't check input for length that's OOB.
CVE-2023-2176,https://www.cve.org/CVERecord?id=CVE-2023-2176,Linux,"A vulnerability was found in compare_netdev_and_ip in drivers/infiniband/core/cma.c in RDMA in the Linux Kernel. The improper cleanup results in out-of-boundary read, where a local user can utilize this problem to crash the system or escalation of privilege.",Semantic - Spec error,OOB access,TRUE,TRUE,Spec allowed for OOB access due to it's incorrect error handling.
CVE-2023-2162,https://www.cve.org/CVERecord?id=CVE-2023-2162,Linux,A use-after-free vulnerability was found in iscsi_sw_tcp_session_create in drivers/scsi/iscsi_tcp.c in SCSI sub-component in the Linux Kernel. In this flaw an attacker could leak kernel internal information.,Semantic - Spec error,Use after free,TRUE,TRUE,"The driver advertises a pointer to the kernel but may deallocate it on fail, which could allow UAF. Patch changes spec to set pointer only after success. Userspace is accessing memory while the kernel can free it.

Yes because the abstraction can make ref-counting congruent across the driver and kernel. "
CVE-2023-2019,https://www.cve.org/CVERecord?id=CVE-2023-2019,Linux,"A flaw was found in the Linux kernel's netdevsim device driver, within the scheduling of events. This issue results from the improper management of a reference count. This may allow an attacker to create a denial of service condition on the system.",Language - Lifetime violation,Resource leak,FALSE,TRUE,
CVE-2023-2008,https://www.cve.org/CVERecord?id=CVE-2023-2008,Linux,"A flaw was found in the Linux kernel's udmabuf device driver. The specific flaw exists within a fault handler. The issue results from the lack of proper validation of user-supplied data, which can result in a memory access past the end of an array. An attacker can leverage this vulnerability to escalate privileges and execute arbitrary code in the context of the kernel.",Semantic - Improper input validation,OOB access,TRUE,TRUE,Missing input validation could allow user to trigger OOB access.
CVE-2023-1990,https://www.cve.org/CVERecord?id=CVE-2023-1990,Linux,A use-after-free flaw was found in ndlc_remove in drivers/nfc/st-nci/ndlc.c in the Linux Kernel. This flaw could allow an attacker to crash the system due to a race problem.,Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't cancel queue'd work on clean up, leading to potential UAF."
CVE-2023-1989,https://www.cve.org/CVERecord?id=CVE-2023-1989,Linux,"A use-after-free flaw was found in btsdio_remove in drivers\bluetooth\btsdio.c in the Linux Kernel. In this flaw, a call to btsdio_remove with an unfinished job, may cause a race problem leading to a UAF on hdev devices.",Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't cancel queue'd work on clean up, leading to potential UAF."
CVE-2023-1855,https://www.cve.org/CVERecord?id=CVE-2023-1855,Linux,A use-after-free flaw was found in xgene_hwmon_remove in drivers/hwmon/xgene-hwmon.c in the Hardware Monitoring Linux Kernel Driver (xgene-hwmon). This flaw could allow a local attacker to crash the system due to a race problem. This vulnerability could even lead to a kernel information leak problem.,Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't cancel queue'd work on clean up, leading to potential UAF."
CVE-2023-1838,https://www.cve.org/CVERecord?id=CVE-2023-1838,Linux,"A use-after-free flaw was found in vhost_net_set_backend in drivers/vhost/net.c in virtio network subcomponent in the Linux kernel due to a double fget. This flaw could allow a local attacker to crash the system, and could even lead to a kernel information leak problem. ",Semantic - Logic error,Use after free,TRUE,TRUE,
CVE-2023-1670,https://www.cve.org/CVERecord?id=CVE-2023-1670,Linux,A flaw use after free in the Linux kernel Xircom 16-bit PCMCIA (PC-card) Ethernet driver was found.A local user could use this flaw to crash the system or potentially escalate their privileges on the system.,Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't properly cancel work and remove refrences on clean up, leading to potential UAF."
CVE-2023-1380,https://www.cve.org/CVERecord?id=CVE-2023-1380,Linux,"A slab-out-of-bound read problem was found in brcmf_get_assoc_ies in drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c in the Linux Kernel. This issue could occur when assoc_info->req_len data is bigger than the size of the buffer, defined as WL_EXTRA_BUF_MAX, leading to a denial of service.",Semantic - Improper input validation,OOB access,TRUE,TRUE,Missing bound check.
CVE-2023-1118,https://www.cve.org/CVERecord?id=CVE-2023-1118,Linux,A flaw use after free in the Linux kernel integrated infrared receiver/transceiver driver was found in the way user detaching rc device. A local user could use this flaw to crash the system or potentially escalate their privileges on the system.,Language - Lifetime violation,Use after free,TRUE,TRUE,"Didn't remove timer associated with device on clean up, which allowed for UAF."
CVE-2023-1076,https://www.cve.org/CVERecord?id=CVE-2023-1076,Linux,"A flaw was found in the Linux Kernel. The tun/tap sockets have their socket UID hardcoded to 0 due to a type confusion in their initialization function. While it will be often correct, as tuntap devices require CAP_NET_ADMIN, it may not always be the case, e.g., a non-root user only having that capability. This would make tun/tap sockets being incorrectly treated in filtering/routing decisions, possibly bypassing network filters.",Language - Container_of,Access control violation,FALSE,TRUE,
CVE-2023-0030,https://www.cve.org/CVERecord?id=CVE-2023-0030,Linux,A use-after-free flaw was found in the Linux kernel’s nouveau driver in how a user triggers a memory overflow that causes the nvkm_vma_tail function to fail. This flaw allows a local user to crash or potentially escalate their privileges on the system.,Semantic - Missing return value check,Use after free,TRUE,TRUE,"Missing return value check, resource will free on fail and cause UAF."
CVE-2022-41858,https://www.cve.org/CVERecord?id=CVE-2022-41858,Linux,In 2023 linux dataset.,Protocol - Missing Protocol Steps,Invalid pointer dereference,TRUE,TRUE,Possible to trigger DOS. Missing null check allows for DOS in edge case
CVE-2022-4842,https://www.cve.org/CVERecord?id=CVE-2022-4842,Linux,In 2023 linux dataset.,Semantic - Logic error,Invalid pointer dereference,TRUE,TRUE,It's just triggering DOS. Cheri shouldn't fix it.
CVE-2022-4744,https://www.cve.org/CVERecord?id=CVE-2022-4744,Linux,In 2023 linux dataset.,Semantic - Spec error,Double free,FALSE,TRUE,"Improper spec allowed double free, was rewritten in patch. Not just a logic error."
CVE-2022-4382,https://www.cve.org/CVERecord?id=CVE-2022-4382,Linux,In 2023 linux dataset.,Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,Patch added locks to fix UAF.
CVE-2022-4139,https://www.cve.org/CVERecord?id=CVE-2022-4139,Linux,In 2023 linux dataset.,Protocol - Missing Protocol Steps,High level spec violation,FALSE,FALSE,driver fails to enable some bits that cause tlb invalidatation not work. 
CVE-2022-4095,https://www.cve.org/CVERecord?id=CVE-2022-4095,Linux,In 2023 linux dataset.,Semantic - Spec error,Use after free,TRUE,TRUE,"Error in spec, allowed for UAF"
CVE-2022-3707,https://www.cve.org/CVERecord?id=CVE-2022-3707,Linux,In 2023 linux dataset.,Language - Lifetime violation,Double free,FALSE,TRUE,On fail frees in function and in the return.
CVE-2022-3628,https://www.cve.org/CVERecord?id=CVE-2022-3628,Linux,In 2023 linux dataset.,Semantic - Improper input validation,OOB access,TRUE,TRUE,
CVE-2022-3424,https://www.cve.org/CVERecord?id=CVE-2022-3424,Linux,In 2023 linux dataset.,Semantic - Missing return value check,Use after free,TRUE,TRUE,"Didn't check return of gru_check_context_placement(), which frees on fail leading to UAF."
CVE-2022-47521,https://www.cve.org/CVERecord?id=CVE-2022-47521,Linux,An issue was discovered in the Linux kernel before 6.0.11. Missing validation of IEEE80211_P2P_ATTR_CHANNEL_LIST in drivers/net/wireless/microchip/wilc1000/cfg80211.c in the WILC1000 wireless driver can trigger a heap-based buffer overflow when parsing the operating channel attribute from Wi-Fi management frames.,Language - Integer overflow,OOB access,TRUE,TRUE,Length check missing. Rust vec will help but input sanitization still required 
CVE-2022-47520,https://www.cve.org/CVERecord?id=CVE-2022-47520,Linux,An issue was discovered in the Linux kernel before 6.0.11. Missing offset validation in drivers/net/wireless/microchip/wilc1000/hif.c in the WILC1000 wireless driver can trigger an out-of-bounds read when parsing a Robust Security Network (RSN) information element from a Netlink packet.,Semantic - Improper input validation,OOB access,TRUE,TRUE,"Either runtime panic or compiletime assertion must happen.
If rsn_ie gets reimplemented in rust as a vec, it might still trigger panic"
CVE-2022-47519,https://www.cve.org/CVERecord?id=CVE-2022-47519,Linux,An issue was discovered in the Linux kernel before 6.0.11. Missing validation of IEEE80211_P2P_ATTR_OPER_CHANNEL in drivers/net/wireless/microchip/wilc1000/cfg80211.c in the WILC1000 wireless driver can trigger an out-of-bounds write when parsing the channel list attribute from Wi-Fi management frames.,Semantic - Improper input validation,OOB access,TRUE,TRUE,Length validation. Simialr to CVE-2022-47521
CVE-2022-47518,https://www.cve.org/CVERecord?id=CVE-2022-47518,Linux,An issue was discovered in the Linux kernel before 6.0.11. Missing validation of the number of channels in drivers/net/wireless/microchip/wilc1000/cfg80211.c in the WILC1000 wireless driver can trigger a heap-based buffer overflow when copying the list of operating channels from Wi-Fi management frames.,Semantic - Improper input validation,OOB access,TRUE,TRUE,"memset arguments can cause OOB write, 
RDS will panic. "
CVE-2022-45919,https://www.cve.org/CVERecord?id=CVE-2022-45919,Linux,"An issue was discovered in the Linux kernel through 6.0.10. In drivers/media/dvb-core/dvb_ca_en50221.c, a use-after-free can occur is there is a disconnect after an open, because of the lack of a wait_event.",Race condition - TOUTOC,Use after free,TRUE,TRUE,"The bug is UAF, which after rust rewrite, it must
be fixed with mutex. P is not required, because rust will not allow race condition. "
CVE-2022-45888,https://www.cve.org/CVERecord?id=CVE-2022-45888,Linux,An issue was discovered in the Linux kernel through 6.0.9. drivers/char/xillybus/xillyusb.c has a race condition and use-after-free during physical removal of a USB device.,Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,"UAF, should be fixed by mutex"
CVE-2022-45886,https://www.cve.org/CVERecord?id=CVE-2022-45886,Linux,An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvb_net.c has a .disconnect versus dvb_device_open race condition that leads to a use-after-free.,Race condition - TOUTOC,Use after free,TRUE,TRUE,"
below are similar to above protocal violation where it is some race condition bug. It is completely implementation dependent, but as long as developers follows correctly given carefully reasoned abstractions, such as mutex, they should easily be able to rewrite those driver code without any race conditions. "
CVE-2022-45885,https://www.cve.org/CVERecord?id=CVE-2022-45885,Linux,An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvb_frontend.c has a race condition that can cause a use-after-free when a device is disconnected.,Race condition - TOUTOC,Use after free,TRUE,TRUE,"UAF, race, fixed by rust mutex. equivalent rust Program won't compile "
CVE-2022-45884,https://www.cve.org/CVERecord?id=CVE-2022-45884,Linux,"An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvbdev.c has a use-after-free, related to dvb_register_device dynamically allocating fops.",Race condition - TOUTOC,Use after free,TRUE,TRUE,"UAF, race, fixed by rust mutex. equivalent rust Program won't compile "
CVE-2022-44034,https://www.cve.org/CVERecord?id=CVE-2022-44034,Linux,"An issue was discovered in the Linux kernel through 6.0.6. drivers/char/pcmcia/scr24x_cs.c has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling open(), aka a race condition between scr24x_open() and scr24x_remove().",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,"UAF, race, fixed by rust mutex and alwaysRefernece trait "
CVE-2022-44033,https://www.cve.org/CVERecord?id=CVE-2022-44033,Linux,"An issue was discovered in the Linux kernel through 6.0.6. drivers/char/pcmcia/cm4040_cs.c has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling open(), aka a race condition between cm4040_open() and reader_detach().",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,"UAF, race, can be fixed by rust mutex.  "
CVE-2022-44032,https://www.cve.org/CVERecord?id=CVE-2022-44032,Linux,"An issue was discovered in the Linux kernel through 6.0.6. drivers/char/pcmcia/cm4000_cs.c has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling open(), aka a race condition between cmm_open() and cm4000_detach().",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,"UAF, race, fixed by rust mutex. equivalent rust Program won't compile "
CVE-2022-43750,https://www.cve.org/CVERecord?id=CVE-2022-43750,Linux,drivers/usb/mon/mon_bin.c in usbmon in the Linux kernel before 5.19.15 and 6.x before 6.0.1 allows a user-space client to corrupt the monitor's internal memory.,Semantic - Logic error,Explicit exception/panic,FALSE,FALSE,"Broken by design. If you allow Userspace to write to some memory (be it rust or C), then this is going to happen. Rust won't magically solve this."
CVE-2022-41850,https://www.cve.org/CVERecord?id=CVE-2022-41850,Linux,roccat_report_event in drivers/hid/hid-roccat.c in the Linux kernel through 5.19.12 has a race condition and resultant use-after-free in certain situations where a report is received while copying a report->value is in progress.,Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,"kernel was able to kfree from a thread, when another thread was copying the data to userspace using copy_to_user
If the mutubality rules were followed, then this won't happen.
Can this be applied to all the HW race condition bugs?"
CVE-2022-41849,https://www.cve.org/CVERecord?id=CVE-2022-41849,Linux,"drivers/video/fbdev/smscufx.c in the Linux kernel through 5.19.12 has a race condition and resultant use-after-free if a physically proximate attacker removes a USB device while calling open(), aka a race condition between ufx_ops_open and ufx_usb_disconnect.",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,"UAF, race, fixed by rust mutex. equivalent rust Program won't compile "
CVE-2022-41848,https://www.cve.org/CVERecord?id=CVE-2022-41848,Linux,"drivers/char/pcmcia/synclink_cs.c in the Linux kernel through 5.19.12 has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling ioctl, aka a race condition between mgslpc_ioctl and mgslpc_detach.",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,"UAF, race, fixed by rust mutex. equivalent rust Program won't compile "
CVE-2022-41218,https://www.cve.org/CVERecord?id=CVE-2022-41218,Linux,"In drivers/media/dvb-core/dmxdev.c in the Linux kernel through 5.19.10, there is a use-after-free caused by refcount races, affecting dvb_demux_open and dvb_dmxdev_release.",Race condition - TOUTOC,Use after free,TRUE,TRUE,"UAF, race, fixed by rust mutex. equivalent rust Program won't compile "
CVE-2022-40768,https://www.cve.org/CVERecord?id=CVE-2022-40768,Linux,drivers/scsi/stex.c in the Linux kernel through 5.19.9 allows local users to obtain sensitive information from kernel memory because stex_queuecommand_lck lacks a memset for the PASSTHRU_CMD case.,Language - Improper memory initialization,Uninitialized memory access,FALSE,TRUE,All value in safe rust be intilized.
CVE-2022-40307,https://www.cve.org/CVERecord?id=CVE-2022-40307,Linux,An issue was discovered in the Linux kernel through 5.19.8. drivers/firmware/efi/capsule-loader.c has a race condition with a resultant use-after-free.,Race condition - TOUTOC,Use after free,TRUE,TRUE,UAF
CVE-2022-38457,https://www.cve.org/CVERecord?id=CVE-2022-38457,Linux,,Language - Lifetime violation,Use after free,TRUE,TRUE,Only vague details are available and there is no upstream fix
CVE-2022-36280,https://www.cve.org/CVERecord?id=CVE-2022-36280,Linux,"An out-of-bounds(OOB) memory access vulnerability was found in vmwgfx driver in drivers/gpu/vmxgfx/vmxgfx_kms.c in GPU component in the Linux kernel with device file '/dev/dri/renderD128 (or Dxxx)'. This flaw allows a local attacker with a user account on the system to gain privilege, causing a denial of service(DoS).",Semantic - Improper input validation,OOB access,TRUE,TRUE,Enum type check failed to validate lower bound. RFL enforces integer check during runtime
CVE-2022-34495,https://www.cve.org/CVERecord?id=CVE-2022-34495,Linux,rpmsg_probe in drivers/rpmsg/virtio_rpmsg_bus.c in the Linux kernel before 5.18.4 has a double free.,Language - Lifetime violation,Double free,FALSE,TRUE,"Possible double free, rust ownership model prevent sharing mutable references.However the correct implementation "
CVE-2022-34494,https://www.cve.org/CVERecord?id=CVE-2022-34494,Linux,rpmsg_virtio_add_ctrl_dev in drivers/rpmsg/virtio_rpmsg_bus.c in the Linux kernel before 5.18.4 has a double free.,Language - Lifetime violation,Double free,FALSE,TRUE,"Possible double free, rust ownership model prevent sharing mutable references "
CVE-2022-33981,https://www.cve.org/CVERecord?id=CVE-2022-33981,Linux,"drivers/block/floppy.c in the Linux kernel before 5.17.6 is vulnerable to a denial of service, because of a concurrency use-after-free flaw after deallocating raw_cmd in the raw_cmd_ioctl function.",Race condition - TOUTOC,Use after free,TRUE,TRUE,"If the interface is designed correctly, this should be prevented, provided this is not triggered by manipulating the physical hardware."
CVE-2022-29156,https://www.cve.org/CVERecord?id=CVE-2022-29156,Linux,drivers/infiniband/ulp/rtrs/rtrs-clt.c in the Linux kernel before 5.16.12 has a double free related to rtrs_clt_dev_release.,Language - Lifetime violation,Double free,FALSE,TRUE,The free path has to follow a specific protocol and accurate Ref counting to know when this can be freed.
CVE-2022-28390,https://www.cve.org/CVERecord?id=CVE-2022-28390,Linux,ems_usb_start_xmit in drivers/net/can/usb/ems_usb.c in the Linux kernel through 5.17.1 has a double free.,Language - Lifetime violation,Double free,FALSE,TRUE,The free path has to follow a specific protocol and accurate Ref counting to know when this can be freed.
CVE-2022-28389,https://www.cve.org/CVERecord?id=CVE-2022-28389,Linux,mcba_usb_start_xmit in drivers/net/can/usb/mcba_usb.c in the Linux kernel through 5.17.1 has a double free.,Language - Lifetime violation,Double free,FALSE,TRUE,The free path has to follow a specific protocol and accurate Ref counting to know when this can be freed.
CVE-2022-28388,https://www.cve.org/CVERecord?id=CVE-2022-28388,Linux,usb_8dev_start_xmit in drivers/net/can/usb/usb_8dev.c in the Linux kernel through 5.17.1 has a double free.,Language - Lifetime violation,Double free,FALSE,TRUE,The free path has to follow a specific protocol and accurate Ref counting to know when this can be freed.
CVE-2022-27950,https://www.cve.org/CVERecord?id=CVE-2022-27950,Linux,"In drivers/hid/hid-elo.c in the Linux kernel before 5.16.11, a memory leak exists for a certain hid_parse error condition.",Language - Lifetime violation,Resource leak,FALSE,TRUE,"RFL has Aref spport which cane be adopted, "
CVE-2022-27223,https://www.cve.org/CVERecord?id=CVE-2022-27223,Linux,"In drivers/usb/gadget/udc/udc-xilinx.c in the Linux kernel before 5.16.12, the endpoint index is not validated and might be manipulated by the host for out-of-array access.",Semantic - Improper input validation,OOB access,TRUE,TRUE,Improper index validation
CVE-2022-26966,https://www.cve.org/CVERecord?id=CVE-2022-26966,Linux,An issue was discovered in the Linux kernel before 5.16.12. drivers/net/usb/sr9700.c allows attackers to obtain sensitive information from heap memory via crafted frame lengths from a device.,Semantic - Improper input validation,OOB access,TRUE,TRUE,Improper length validation
CVE-2022-26878,https://www.cve.org/CVERecord?id=CVE-2022-26878,Linux,drivers/bluetooth/virtio_bt.c in the Linux kernel before 5.16.3 has a memory leak (socket buffers have memory allocated but not freed).,Language - Lifetime violation,Resource leak,FALSE,TRUE,"Missing kfree in free path, won't be catched by compiler. 
But correct implementation of the drop over givem data structure can prevent incorrect cleanup "
CVE-2022-26490,https://www.cve.org/CVERecord?id=CVE-2022-26490,Linux,st21nfca_connectivity_event_received in drivers/nfc/st21nfca/se.c in the Linux kernel through 5.16.12 has EVT_TRANSACTION buffer overflows because of untrusted length parameters.,Semantic - Improper input validation,OOB access,TRUE,TRUE,Improper length validation
CVE-2022-25375,https://www.cve.org/CVERecord?id=CVE-2022-25375,Linux,An issue was discovered in drivers/usb/gadget/function/rndis.c in the Linux kernel before 5.16.10. The RNDIS USB gadget lacks validation of the size of the RNDIS_MSG_SET command. Attackers can obtain sensitive information from kernel memory.,Semantic - Improper input validation,OOB access,TRUE,TRUE,Improper length validation
CVE-2022-25258,https://www.cve.org/CVERecord?id=CVE-2022-25258,Linux,An issue was discovered in drivers/usb/gadget/composite.c in the Linux kernel before 5.16.10. The USB Gadget subsystem lacks certain validation of interface OS descriptor requests (ones with a large array index and ones associated with NULL function pointer retrieval). Memory corruption might occur.,Semantic - Improper input validation,OOB access,TRUE,TRUE,Improper index validation
CVE-2022-24959,https://www.cve.org/CVERecord?id=CVE-2022-24959,Linux,An issue was discovered in the Linux kernel before 5.16.5. There is a memory leak in yam_siocdevprivate in drivers/net/hamradio/yam.c.,Language - Lifetime violation,Resource leak,FALSE,TRUE,"This is memory leak caused by incorrect conditional checking, more related to high level design/logic error, Rust can't prevent this"
CVE-2022-24958,https://www.cve.org/CVERecord?id=CVE-2022-24958,Linux,drivers/usb/gadget/legacy/inode.c in the Linux kernel through 5.16.8 mishandles dev->buf release.,Language - Lifetime violation,Use after free,TRUE,TRUE,"The correct will require careful software pattern rewrite over gadgetfs_driver, it would required carefully reasoning about resource deallocation if a member method fails. It is doable, but non-trival"
CVE-2022-3636,https://www.cve.org/CVERecord?id=CVE-2022-3636,Linux,"A vulnerability, which was classified as critical, was found in Linux Kernel. This affects the function __mtk_ppe_check_skb of the file drivers/net/ethernet/mediatek/mtk_ppe.c of the component Ethernet Handler. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-211935.",Semantic - Logic error,Use after free,TRUE,TRUE,"Programmer still need to know which function to call, arguably correct RFL abstraction can prevent this by wrapping over correct bindgen function, but still require expertise. "
CVE-2022-3635,https://www.cve.org/CVERecord?id=CVE-2022-3635,Linux,"A vulnerability, which was classified as critical, has been found in Linux Kernel. Affected by this issue is the function tst_timer of the file drivers/atm/idt77252.c of the component IPsec. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. VDB-211934 is the identifier assigned to this vulnerability.",Race condition - TOUTOC,Use after free,TRUE,TRUE,"del_timer_sync, non trival reasoning required"
CVE-2022-3624,https://www.cve.org/CVERecord?id=CVE-2022-3624,Linux,A vulnerability was found in Linux Kernel and classified as problematic. Affected by this issue is the function rlb_arp_xmit of the file drivers/net/bonding/bond_alb.c of the component IPsec. The manipulation leads to memory leak. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211928.,Language - Lifetime violation,Resource leak,FALSE,TRUE,Aref will help here
CVE-2022-3594,https://www.cve.org/CVERecord?id=CVE-2022-3594,Linux,A vulnerability was found in Linux Kernel. It has been declared as problematic. Affected by this vulnerability is the function intr_callback of the file drivers/net/usb/r8152.c of the component BPF. The manipulation leads to logging of excessive data. The attack can be launched remotely. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-211363.,Semantic - Improper input validation,Failure to release CPU,FALSE,FALSE,"printk in a path is not ratelimited and can be remotely triggered.

What category"
CVE-2022-3577,https://www.cve.org/CVERecord?id=CVE-2022-3577,Linux,"An out-of-bounds memory write flaw was found in the Linux kernel’s Kid-friendly Wired Controller driver. This flaw allows a local user to crash or potentially escalate their privileges on the system. It is in bigben_probe of drivers/hid/hid-bigbenff.c. The reason is incorrect assumption - bigben devices all have inputs. However, malicious devices can break this assumption, leaking to out-of-bound write.",Language - Lifetime violation,Resource leak,FALSE,TRUE,"Fails to release the allocated resource, impl drop over corresponding data structure"
CVE-2022-3565,https://www.cve.org/CVERecord?id=CVE-2022-3565,Linux,"A vulnerability, which was classified as critical, has been found in Linux Kernel. Affected by this issue is the function del_timer of the file drivers/isdn/mISDN/l1oip_core.c of the component Bluetooth. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211088.",Race condition - TOUTOC,Use after free,TRUE,TRUE,"del timer sync, non-trival reasoning required"
CVE-2022-3545,https://www.cve.org/CVERecord?id=CVE-2022-3545,Linux,A vulnerability has been found in Linux Kernel and classified as critical. Affected by this vulnerability is the function area_cache_get of the file drivers/net/ethernet/netronome/nfp/nfpcore/nfp_cppcore.c of the component IPsec. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier VDB-211045 was assigned to this vulnerability.,Language - Lifetime violation,Use after free,TRUE,TRUE,"Rust will prevent UAF, but non-trival knowledge about the software still required to fix the bug"
CVE-2022-3541,https://www.cve.org/CVERecord?id=CVE-2022-3541,Linux,A vulnerability classified as critical has been found in Linux Kernel. This affects the function spl2sw_nvmem_get_mac_address of the file drivers/net/ethernet/sunplus/spl2sw_driver.c of the component BPF. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier VDB-211041 was assigned to this vulnerability.,Language - Lifetime violation,Use after free,TRUE,TRUE,Classic reuse
CVE-2022-3526,https://www.cve.org/CVERecord?id=CVE-2022-3526,Linux,A vulnerability classified as problematic was found in Linux Kernel. This vulnerability affects the function macvlan_handle_frame of the file drivers/net/macvlan.c of the component skb. The manipulation leads to memory leak. The attack can be initiated remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211024.,Language - Lifetime violation,Resource leak,FALSE,TRUE,Fails to free the memory on release path. impl drop over corresponding data structure (skb)
CVE-2022-3115,https://www.cve.org/CVERecord?id=CVE-2022-3115,Linux,An issue was discovered in the Linux kernel through 5.16-rc6. malidp_crtc_reset in drivers/gpu/drm/arm/malidp_crtc.c lacks check of the return value of kzalloc() and will cause the null pointer dereference.,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,Fails to check return value of kzalloc
CVE-2022-3114,https://www.cve.org/CVERecord?id=CVE-2022-3114,Linux,An issue was discovered in the Linux kernel through 5.16-rc6. imx_register_uart_clocks in drivers/clk/imx/clk.c lacks check of the return value of kcalloc() and will cause the null pointer dereference.,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,Fails to check return value of kzalloc
CVE-2022-3113,https://www.cve.org/CVERecord?id=CVE-2022-3113,Linux,An issue was discovered in the Linux kernel through 5.16-rc6. mtk_vcodec_fw_vpu_init in drivers/media/platform/mtk-vcodec/mtk_vcodec_fw_vpu.c lacks check of the return value of devm_kzalloc() and will cause the null pointer dereference.,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,Fails to check return value of kzalloc
CVE-2022-3112,https://www.cve.org/CVERecord?id=CVE-2022-3112,Linux,An issue was discovered in the Linux kernel through 5.16-rc6. amvdec_set_canvases in drivers/staging/media/meson/vdec/vdec_helpers.c lacks check of the return value of kzalloc() and will cause the null pointer dereference.,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,Fails to check return value of kzalloc
CVE-2022-3111,https://www.cve.org/CVERecord?id=CVE-2022-3111,Linux,"An issue was discovered in the Linux kernel through 5.16-rc6. free_charger_irq() in drivers/power/supply/wm8350_power.c lacks free of WM8350_IRQ_CHG_FAST_RDY, which is registered in wm8350_init_charger().",Language - Lifetime violation,Resource leak,FALSE,TRUE,"Fails to free the IRQ/memory on release path.

Correct RFL implementation of the drop required. "
CVE-2022-3110,https://www.cve.org/CVERecord?id=CVE-2022-3110,Linux,An issue was discovered in the Linux kernel through 5.16-rc6. _rtw_init_xmit_priv in drivers/staging/r8188eu/core/rtw_xmit.c lacks check of the return value of rtw_alloc_hwxmits() and will cause the null pointer dereference.,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,"Fails to free the memory on release path.
Driver is removed from tree: https://lore.kernel.org/linux-staging/92a9442a-cece-4179-fbdc-3c9188da073e@redhat.com/"
CVE-2022-3108,https://www.cve.org/CVERecord?id=CVE-2022-3108,Linux,An issue was discovered in the Linux kernel through 5.16-rc6. kfd_parse_subtype_iolink in drivers/gpu/drm/amd/amdkfd/kfd_crat.c lacks check of the return value of kmemdup().,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,"Fails to check return value of memory allocation, this can be fixed by simply implement memory allocation method with result type,s othe programer must check the result (unwrap)."
CVE-2022-3107,https://www.cve.org/CVERecord?id=CVE-2022-3107,Linux,An issue was discovered in the Linux kernel through 5.16-rc6. netvsc_get_ethtool_stats in drivers/net/hyperv/netvsc_drv.c lacks check of the return value of kvmalloc_array() and will cause the null pointer dereference.,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,Fails to check return value of kzalloc
CVE-2022-3106,https://www.cve.org/CVERecord?id=CVE-2022-3106,Linux,An issue was discovered in the Linux kernel through 5.16-rc6. ef100_update_stats in drivers/net/ethernet/sfc/ef100_nic.c lacks check of the return value of kmalloc().,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,Fails to check return value of kzalloc
CVE-2022-3105,https://www.cve.org/CVERecord?id=CVE-2022-3105,Linux,An issue was discovered in the Linux kernel through 5.16-rc6. uapi_finalize in drivers/infiniband/core/uverbs_uapi.c lacks check of kmalloc_array().,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,Fails to check return value of kzalloc
CVE-2022-3104,https://www.cve.org/CVERecord?id=CVE-2022-3104,Linux,An issue was discovered in the Linux kernel through 5.16-rc6. lkdtm_ARRAY_BOUNDS in drivers/misc/lkdtm/bugs.c lacks check of the return value of kmalloc() and will cause the null pointer dereference.,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,Fails to check return value of kzalloc
CVE-2022-3078,https://www.cve.org/CVERecord?id=CVE-2022-3078,Linux,An issue was discovered in the Linux kernel through 5.16-rc6. There is a lack of check after calling vzalloc() and lack of free after allocation in drivers/media/test-drivers/vidtv/vidtv_s302m.c.,Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,Fails to check return value of kzalloc. 
CVE-2022-2380,https://www.cve.org/CVERecord?id=CVE-2022-2380,Linux,The Linux kernel was found vulnerable out of bounds memory access in the drivers/video/fbdev/sm712fb.c:smtcfb_read() function. The vulnerability could result in local attackers being able to crash the kernel.,Semantic - Improper input validation,OOB access,TRUE,TRUE,Fails to validate the length and the endianness properly
CVE-2022-2308,https://www.cve.org/CVERecord?id=CVE-2022-2308,Linux,"A flaw was found in vDPA with VDUSE backend. There are currently no checks in VDUSE kernel driver to ensure the size of the device config space is in line with the features advertised by the VDUSE userspace application. In case of a mismatch, Virtio drivers config read helpers do not initialize the memory indirectly passed to vduse_vdpa_get_config() returning uninitialized memory from the stack. This could cause undefined behavior or data leaks in Virtio drivers.",Language - Improper memory initialization,Uninitialized memory access,FALSE,TRUE,"safe rust requires the value initilization, however this story is different for foreign objects (from kernel) "
CVE-2022-1734,https://www.cve.org/CVERecord?id=CVE-2022-1734,Linux,A flaw in Linux Kernel found in nfcmrvl_nci_unregister_dev() in drivers/nfc/nfcmrvl/main.c can lead to use after free both read or write when non synchronized between cleanup routine and firmware download routine.,Race condition - TOUTOC,Use after free,TRUE,TRUE,"Race condition can cause early clean up, which leads to UAF scenario"
CVE-2022-1651,https://www.cve.org/CVERecord?id=CVE-2022-1651,Linux,"A memory leak flaw was found in the Linux kernel in acrn_dev_ioctl in the drivers/virt/acrn/hsm.c function in how the ACRN Device Model emulates virtual NICs in VM. This flaw allows a local privileged attacker to leak unauthorized kernel information, causing a denial of service.",Language - Lifetime violation,Use after free,TRUE,TRUE,Fails to free the memory on error path. Implement drop trait for vm_param and cpu_reg
CVE-2022-1280,https://www.cve.org/CVERecord?id=CVE-2022-1280,Linux,A use-after-free vulnerability was found in drm_lease_held in drivers/gpu/drm/drm_lease.c in the Linux kernel due to a race problem. This flaw allows a local user privilege attacker to cause a denial of service (DoS) or a kernel information leak.,Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,Non-trival knowledge and rewrite needed
CVE-2022-1198,https://www.cve.org/CVERecord?id=CVE-2022-1198,Linux,A use-after-free vulnerabilitity was discovered in drivers/net/hamradio/6pack.c of linux that allows an attacker to crash linux kernel by simulating ax25 device using 6pack driver from user space.,Race condition - TOUTOC,Use after free,TRUE,TRUE,Protocol violation. freeing of dev happens and a concurrent thread can modify the timer from userland
CVE-2022-1195,https://www.cve.org/CVERecord?id=CVE-2022-1195,Linux,A use-after-free vulnerability was found in the Linux kernel in drivers/net/hamradio. This flaw allows a local attacker with a user privilege to cause a denial of service (DOS) when the mkiss or sixpack device is detached and reclaim resources early.,Race condition - TOUTOC,Use after free,TRUE,TRUE,"Since it is UAF, rust compiler will likely not allow the program to compile, but correct reasoning and logic still required for programmer."
CVE-2022-0494,https://www.cve.org/CVERecord?id=CVE-2022-0494,Linux,A kernel information leak flaw was identified in the scsi_ioctl function in drivers/scsi/scsi_ioctl.c in the Linux kernel. This flaw allows a local attacker with a special user privilege (CAP_SYS_ADMIN or CAP_SYS_RAWIO) to create issues with confidentiality.,Language - Improper memory initialization,Uninitialized memory access,FALSE,FALSE,Fail to initilize buffer memory to 0. Safe rust enforces value initliazation. 
CVE-2022-0487,https://www.cve.org/CVERecord?id=CVE-2022-0487,Linux,"A use-after-free vulnerability was found in rtsx_usb_ms_drv_remove in drivers/memstick/host/rtsx_usb_ms.c in memstick in the Linux kernel. In this flaw, a local attacker with a user privilege may impact system Confidentiality. This flaw affects kernel versions prior to 5.14 rc1.",Race condition - TOUTOC,Use after free,TRUE,TRUE,"Two bugs in one cve, but both are UAF, which rust compiler will complain"
CVE-2021-3753,https://www.cve.org/CVERecord?id=CVE-2021-3753,Linux,In 2022 linux dataset.,Race condition - Improper usage of synchronization primitives,OOB access,TRUE,TRUE,
CVE-2021-3744,https://www.cve.org/CVERecord?id=CVE-2021-3744,Linux,In 2022 linux dataset.,Semantic - Logic error,Resource leak,FALSE,TRUE,
CVE-2021-44733,https://www.cve.org/CVERecord?id=CVE-2021-44733,Linux,A use-after-free exists in drivers/tee/tee_shm.c in the TEE subsystem in the Linux kernel through 5.15.11. This occurs because of a race condition in tee_shm_get_from_id during an attempt to free a shared memory object.,Language - Lifetime violation,Use after free,TRUE,TRUE,UAF happens because the resource is improperly refcounted
CVE-2021-43976,https://www.cve.org/CVERecord?id=CVE-2021-43976,Linux,"In the Linux kernel through 5.15.2, mwifiex_usb_recv in drivers/net/wireless/marvell/mwifiex/usb.c allows an attacker (who can connect a crafted USB device) to cause a denial of service (skb_over_panic).",Protocol - Missing Protocol Steps,Explicit exception/panic,FALSE,FALSE,Improper resource handling in the free path
CVE-2021-43975,https://www.cve.org/CVERecord?id=CVE-2021-43975,Linux,"In the Linux kernel through 5.15.2, hw_atl_utils_fw_rpc_wait in drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c allows an attacker (who can introduce a crafted device) to trigger an out-of-bounds write via a crafted length value.",Semantic - Improper input validation,OOB access,TRUE,TRUE,Improper length validation
CVE-2021-43389,https://www.cve.org/CVERecord?id=CVE-2021-43389,Linux,An issue was discovered in the Linux kernel before 5.14.15. There is an array-index-out-of-bounds flaw in the detach_capi_ctr function in drivers/isdn/capi/kcapi.c.,Semantic - Improper input validation,OOB access,TRUE,TRUE,Improper index validation
CVE-2021-42327,https://www.cve.org/CVERecord?id=CVE-2021-42327,Linux,dp_link_settings_write in drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c in the Linux kernel through 5.14.14 allows a heap-based buffer overflow by an attacker who can write a string to the AMD GPU display drivers debug filesystem. There are no checks on size within parse_write_buffer_into_params when it uses the size of copy_from_user to copy a userspace buffer into a 40-byte heap buffer.,Semantic - Improper input validation,OOB access,TRUE,TRUE,Improper length validation
CVE-2021-42252,https://www.cve.org/CVERecord?id=CVE-2021-42252,Linux,"An issue was discovered in aspeed_lpc_ctrl_mmap in drivers/soc/aspeed/aspeed-lpc-ctrl.c in the Linux kernel before 5.14.6. Local attackers able to access the Aspeed LPC control interface could overwrite memory in the kernel and potentially execute privileges, aka CID-b49a0e69a7b1. This occurs because a certain comparison uses values that are not memory sizes.",Semantic - Improper input validation,OOB access,TRUE,TRUE,Improper length validation
CVE-2021-42008,https://www.cve.org/CVERecord?id=CVE-2021-42008,Linux,The decode_data function in drivers/net/hamradio/6pack.c in the Linux kernel before 5.13.13 has a slab out-of-bounds write. Input from a process that has the CAP_NET_ADMIN capability can lead to root access.,Semantic - Improper input validation,OOB access,TRUE,TRUE,Improper length validation
CVE-2021-38207,https://www.cve.org/CVERecord?id=CVE-2021-38207,Linux,drivers/net/ethernet/xilinx/ll_temac_main.c in the Linux kernel before 5.12.13 allows remote attackers to cause a denial of service (buffer overflow and lockup) by sending heavy network traffic for about ten minutes.,Semantic - Logic error,OOB access,TRUE,TRUE,"Logic error, because input validation was present, but there was a one off error, ie, checking for X instead of (X+1)"
CVE-2021-38205,https://www.cve.org/CVERecord?id=CVE-2021-38205,Linux,"drivers/net/ethernet/xilinx/xilinx_emaclite.c in the Linux kernel before 5.13.3 makes it easier for attackers to defeat an ASLR protection mechanism because it prints a kernel pointer (i.e., the real IOMEM pointer).",Semantic - Security and permissions,Access control violation,FALSE,FALSE,Didn't print kernel pointer with %p which could lead to security vulnerability. SInce %p sanitizes pointer based on restrictions
CVE-2021-38204,https://www.cve.org/CVERecord?id=CVE-2021-38204,Linux,drivers/usb/host/max3421-hcd.c in the Linux kernel before 5.13.6 allows physically proximate attackers to cause a denial of service (use-after-free and panic) by removing a MAX-3421 USB device in certain situations.,Language - Lifetime violation,Use after free,TRUE,FALSE,Original spec of driver saved potentially stale pointers.
CVE-2021-38160,https://www.cve.org/CVERecord?id=CVE-2021-38160,Linux,"** DISPUTED ** In drivers/char/virtio_console.c in the Linux kernel before 5.13.4, data corruption or loss can be triggered by an untrusted device that supplies a buf->len value exceeding the buffer size. NOTE: the vendor indicates that the cited data corruption is not a vulnerability in any existing use case; the length validation was added solely for robustness in the face of anomalous host OS behavior.",Semantic - Improper input validation,OOB access,TRUE,TRUE,Missing check to make sure length is not larger than buffer
CVE-2021-37159,https://www.cve.org/CVERecord?id=CVE-2021-37159,Linux,"hso_free_net_device in drivers/net/usb/hso.c in the Linux kernel through 5.13.4 calls unregister_netdev without checking for the NETREG_REGISTERED state, leading to a use-after-free and a double free.",Protocol - Missing Protocol Steps,Double free,FALSE,FALSE,"Interesting bit from the netdev developer: https://www.spinics.net/lists/linux-usb/msg202309.html
* And a lot of driver still uses the internal state: https://livegrep.com/search/linux?q=state+%3D%3D+NETREG_REGISTERED%29+path%3Adrivers%2Fnet%2Fethernet%2F&fold_case=auto&regex=false&context=true"
CVE-2021-31916,https://www.cve.org/CVERecord?id=CVE-2021-31916,Linux,An out-of-bounds (OOB) memory write flaw was found in list_devices in drivers/md/dm-ioctl.c in the Multi-device driver module in the Linux kernel before 5.12. A bound check failure allows an attacker with special user (CAP_SYS_ADMIN) privilege to gain access to out-of-bounds memory leading to a system crash or a leak of internal kernel information. The highest threat from this vulnerability is to system availability.,Semantic - Improper input validation,OOB access,TRUE,TRUE,Improper input data validation from userland
CVE-2021-30002,https://www.cve.org/CVERecord?id=CVE-2021-30002,Linux,"An issue was discovered in the Linux kernel before 5.11.3 when a webcam device exists. video_usercopy in drivers/media/v4l2-core/v4l2-ioctl.c has a memory leak for large arguments, aka CID-fb18802a338b.",Semantic - Logic error,Resource leak,FALSE,TRUE,"Classic memory leak, two allocations were done and assigned to the same variable. If this is not a void pointer and a typed struct, rust would automatically free the memory when it goes out of scope. Check with a prototype."
CVE-2021-29266,https://www.cve.org/CVERecord?id=CVE-2021-29266,Linux,"An issue was discovered in the Linux kernel before 5.11.9. drivers/vhost/vdpa.c has a use-after-free because v->config_ctx has an invalid value upon re-opening a character device, aka CID-f6bbf0010ba0.",Language - Lifetime violation,Use after free,TRUE,TRUE,Refcount is decremented but the pointer is not set to null causing the next call to cause UAF and underflow the refcount
CVE-2021-29265,https://www.cve.org/CVERecord?id=CVE-2021-29265,Linux,"An issue was discovered in the Linux kernel before 5.11.7. usbip_sockfd_store in drivers/usb/usbip/stub_dev.c allows attackers to cause a denial of service (GPF) because the stub-up sequence has race conditions during an update of the local and shared status, aka CID-9380afd6df70.",Semantic - Missing return value check,Invalid pointer dereference,TRUE,TRUE,From commit: Doesn't handle kthread_create() error and saves invalid ptr in localstate that drives rx and tx threads.
CVE-2021-29264,https://www.cve.org/CVERecord?id=CVE-2021-29264,Linux,"An issue was discovered in the Linux kernel through 5.11.10. drivers/net/ethernet/freescale/gianfar.c in the Freescale Gianfar Ethernet driver allows attackers to cause a system crash because a negative fragment size is calculated in situations involving an rx queue overrun when jumbo packets are used and NAPI is enabled, aka CID-d8861bab48b6.",Semantic - Improper input validation,OOB access,TRUE,FALSE,The length of the skb and buffer is not handled properly in a corner case. This is a integer overflow/underflow
CVE-2021-28972,https://www.cve.org/CVERecord?id=CVE-2021-28972,Linux,"In drivers/pci/hotplug/rpadlpar_sysfs.c in the Linux kernel through 5.11.8, the RPA PCI Hotplug driver has a user-tolerable buffer overflow when writing a new device name to the driver from userspace, allowing userspace to write data to the kernel stack frame directly. This occurs because add_slot_store and remove_slot_store mishandle drc_name '\0' termination, aka CID-cc7a0bb058b8.",Language - Null byte termination,OOB access,TRUE,TRUE,"Improper handling of buffer as a string. It has to be type checked, but such rust type conversions are unsafe. maybe we can type check and return an error?"
CVE-2021-28660,https://www.cve.org/CVERecord?id=CVE-2021-28660,Linux,"rtw_wx_set_scan in drivers/staging/rtl8188eu/os_dep/ioctl_linux.c in the Linux kernel through 5.11.6 allows writing beyond the end of the ->ssid[] array. NOTE: from the perspective of kernel.org releases, CVE IDs are not normally used for drivers/staging/* (unfinished work); however, system integrators may have situations in which a drivers/staging issue is relevant to their own customer base.",Semantic - Improper input validation,OOB access,TRUE,TRUE,Improper length check
CVE-2021-28375,https://www.cve.org/CVERecord?id=CVE-2021-28375,Linux,"An issue was discovered in the Linux kernel through 5.11.6. fastrpc_internal_invoke in drivers/misc/fastrpc.c does not prevent user applications from sending kernel RPC messages, aka CID-20c40794eb85. This is a related issue to CVE-2019-2308.",Semantic - Security and permissions,Access control violation,FALSE,FALSE,Improper authorization check. User is allowed to send kernel RPCs
CVE-2021-27364,https://www.cve.org/CVERecord?id=CVE-2021-27364,Linux,An issue was discovered in the Linux kernel through 5.11.3. drivers/scsi/scsi_transport_iscsi.c is adversely affected by the ability of an unprivileged user to craft Netlink messages.,Semantic - Security and permissions,Access control violation,FALSE,FALSE,Improper authorization check. User is allowed to modify arbitrary iSCSI sessions.
CVE-2021-27363,https://www.cve.org/CVERecord?id=CVE-2021-27363,Linux,"An issue was discovered in the Linux kernel through 5.11.3. A kernel pointer leak can be used to determine the address of the iscsi_transport structure. When an iSCSI transport is registered with the iSCSI subsystem, the transport's handle is available to unprivileged users via the sysfs file system, at /sys/class/iscsi_transport/$TRANSPORT_NAME/handle. When read, the show_transport_handle function (in drivers/scsi/scsi_transport_iscsi.c) is called, which leaks the handle. This handle is actually the pointer to an iscsi_transport struct in the kernel module's global variables.",Semantic - Security and permissions,Access control violation,FALSE,FALSE,Improper authorization check. User is allowed to modify arbitrary iSCSI sessions.
CVE-2021-26932,https://www.cve.org/CVERecord?id=CVE-2021-26932,Linux,"An issue was discovered in the Linux kernel 3.2 through 5.10.16, as used by Xen. Grant mapping operations often occur in batch hypercalls, where a number of operations are done in a single hypercall, the success or failure of each one is reported to the backend driver, and the backend driver then loops over the results, performing follow-up actions based on the success or failure of each operation. Unfortunately, when running in PV mode, the Linux backend drivers mishandle this: Some errors are ignored, effectively implying their success from the success of related batch elements. In other cases, errors resulting from one batch element lead to further batch elements not being inspected, and hence successful ones to not be possible to properly unmap upon error recovery. Only systems with Linux backends running in PV mode are vulnerable. Linux backends run in HVM / PVH modes are not vulnerable. This affects arch/*/xen/p2m.c and drivers/xen/gntdev.c.",Semantic - Security and permissions,High level spec violation,FALSE,FALSE,Mishandling of errors: Functional problem: The loop doesn't account for all failures and reports bogus results to the upper layers. 
CVE-2021-26931,https://www.cve.org/CVERecord?id=CVE-2021-26931,Linux,"An issue was discovered in the Linux kernel 2.6.39 through 5.10.16, as used in Xen. Block, net, and SCSI backends consider certain errors a plain bug, deliberately causing a kernel crash. For errors potentially being at least under the influence of guests (such as out of memory conditions), it isn't correct to assume a plain bug. Memory allocations potentially causing such crashes occur only when Linux is running in PV mode, though. This affects drivers/block/xen-blkback/blkback.c and drivers/xen/xen-scsiback.c.",Semantic - Spec error,Explicit exception/panic,FALSE,FALSE,Logical error: Improper error handling
CVE-2021-26930,https://www.cve.org/CVERecord?id=CVE-2021-26930,Linux,"An issue was discovered in the Linux kernel 3.11 through 5.10.16, as used by Xen. To service requests to the PV backend, the driver maps grant references provided by the frontend. In this process, errors may be encountered. In one case, an error encountered earlier might be discarded by later processing, resulting in the caller assuming successful mapping, and hence subsequent operations trying to access space that wasn't mapped. In another case, internal state would be insufficiently updated, preventing safe recovery from the error. This affects drivers/block/xen-blkback/blkback.c.",Semantic - Logic error,Uninitialized memory access,FALSE,FALSE,Logical error: Improper error handling
CVE-2021-20292,https://www.cve.org/CVERecord?id=CVE-2021-20292,Linux,"There is a flaw reported in the Linux kernel in versions before 5.9 in drivers/gpu/drm/nouveau/nouveau_sgdma.c in nouveau_sgdma_create_ttm in Nouveau DRM subsystem. The issue results from the lack of validating the existence of an object prior to performing operations on the object. An attacker with a local account with a root privilege, can leverage this vulnerability to escalate privileges and execute code in the context of the kernel.",Semantic - Improper input validation,Double free,FALSE,TRUE,Issue appears to be logic error allows potential double free. Per the bugzilla thread: https://seclists.org/oss-sec/2020/q3/127
CVE-2021-3348,https://www.cve.org/CVERecord?id=CVE-2021-3348,Linux,"nbd_add_socket in drivers/block/nbd.c in the Linux kernel through 5.10.12 has an ndb_queue_rq use-after-free that could be triggered by local attackers (with access to the nbd device) via an I/O request at a certain point during device setup, aka CID-b98e762e3d71.",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,"Race case with krealloc() could cause UAF, patch simply freezes queue instead of locking."
CVE-2020-12652,https://www.cve.org/CVERecord?id=CVE-2020-12652,Linux,"The __mptctl_ioctl function in drivers/message/fusion/mptctl.c in the Linux kernel before 5.4.14 allows local users to hold an incorrect lock during the ioctl operation and trigger a race condition, i.e., a ""double fetch"" vulnerability, aka CID-28d76df18f0a. NOTE: the vendor states ""The security impact of this bug is not as bad as it could have been because these operations are all privileged and root already has enormous destructive power.""",Race condition - TOUTOC,Explicit exception/panic,FALSE,FALSE,Improper locking logic which depends on changing memory state can create race condition. Red hat classified this as a DOS.
CVE-2020-8649,https://www.cve.org/CVERecord?id=CVE-2020-8649,Linux,There is a use-after-free vulnerability in the Linux kernel through 5.5.2 in the vgacon_invert_region function in drivers/video/console/vgacon.c.,Semantic - Logic error,OOB access,TRUE,FALSE,Bound checking logic was missing.
CVE-2020-29661,https://www.cve.org/CVERecord?id=CVE-2020-29661,Linux,"A locking issue was discovered in the tty subsystem of the Linux kernel through 5.9.13. drivers/tty/tty_jobctrl.c allows a use-after-free attack against TIOCSPGRP, aka CID-54ffccbf053b.",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,Locking wrong object can lead to improper refrence counting and UAF vulnerabilities.
CVE-2020-29660,https://www.cve.org/CVERecord?id=CVE-2020-29660,Linux,"A locking inconsistency issue was discovered in the tty subsystem of the Linux kernel through 5.9.13. drivers/tty/tty_io.c and drivers/tty/tty_jobctrl.c may allow a read-after-free attack against TIOCGSID, aka CID-c8bcd9c5be24.",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,Non-uniform locking mechanisms in code allow for UAF vulnerabilities.
CVE-2020-28974,https://www.cve.org/CVERecord?id=CVE-2020-28974,Linux,"A slab-out-of-bounds read in fbcon in the Linux kernel before 5.9.7 could be used by local attackers to read privileged information or potentially crash the kernel, aka CID-3c4e0dff2095. This occurs because KD_FONT_OP_COPY in drivers/tty/vt/vt.c can be used for manipulations such as font height.",Semantic - Logic error,OOB access,TRUE,TRUE,Incorrect logic for managing lengths of two buffers can lead to OOB issues.
CVE-2020-28941,https://www.cve.org/CVERecord?id=CVE-2020-28941,Linux,"An issue was discovered in drivers/accessibility/speakup/spk_ttyio.c in the Linux kernel through 5.9.9. Local attackers on systems with the speakup driver could cause a local denial of service attack, aka CID-d41227544427. This occurs because of an invalid free when the line discipline is used more than once.",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,Missing lock caused a race that could lead to UAF.
CVE-2020-27675,https://www.cve.org/CVERecord?id=CVE-2020-27675,Linux,"An issue was discovered in the Linux kernel through 5.9.1, as used with Xen through 4.14.x. drivers/xen/events/events_base.c allows event-channel removal during the event-handling loop (a race condition). This can cause a use-after-free or NULL pointer dereference, as demonstrated by a dom0 crash via events for an in-reconfiguration paravirtualized device, aka CID-073d0552ead5.",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,Improper locking while freeing an object allowed UAF since event loop still active.
CVE-2020-25284,https://www.cve.org/CVERecord?id=CVE-2020-25284,Linux,"The rbd block device driver in drivers/block/rbd.c in the Linux kernel through 5.8.9 used incomplete permission checking for access to rbd devices, which could be leveraged by local attackers to map or unmap rbd block devices, aka CID-f44d04e696fe.",Semantic - Security and permissions,Access control violation,FALSE,FALSE,Was missing permissions check.
CVE-2020-16166,https://www.cve.org/CVERecord?id=CVE-2020-16166,Linux,"The Linux kernel through 5.7.11 allows remote attackers to make observations that help to obtain sensitive information about the internal state of the network RNG, aka CID-f227e3ec3b5c. This is related to drivers/char/random.c and kernel/time/timer.c.",Semantic - Logic error,Access control violation,FALSE,FALSE,"*To ensure logical ""correctness"" of random.h the patch added more re-seeding to the system's state. This is an effort to prevent the RNG's internal state being guessed."
CVE-2020-15780,https://www.cve.org/CVERecord?id=CVE-2020-15780,Linux,"An issue was discovered in drivers/acpi/acpi_configfs.c in the Linux kernel before 5.7.7. Injection of malicious ACPI tables via configfs could be used by attackers to bypass lockdown and secure boot restrictions, aka CID-75b0cea7bf30.",Semantic - Security and permissions,Access control violation,FALSE,FALSE,Missing lockdown verification before loading ACPI tables allowed privilege bypass.
CVE-2020-15437,https://www.cve.org/CVERecord?id=CVE-2020-15437,Linux,The Linux kernel before version 5.8 is vulnerable to a NULL pointer dereference in drivers/tty/serial/8250/8250_core.c:serial8250_isa_init_ports() that allows local users to cause a denial of service by using the p->serial_in pointer which uninitialized.,Race condition - TOUTOC,Explicit exception/panic,FALSE,TRUE,"Error in initialization protocol leads to uninitialized pointers on certain architectures, causing kernel panic."
CVE-2020-15393,https://www.cve.org/CVERecord?id=CVE-2020-15393,Linux,"In the Linux kernel 4.4 through 5.7.6, usbtest_disconnect in drivers/usb/misc/usbtest.c has a memory leak, aka CID-28ebeb8db770.",Language - Lifetime violation,Resource leak,FALSE,TRUE,Memory leak
CVE-2020-14416,https://www.cve.org/CVERecord?id=CVE-2020-14416,Linux,"In the Linux kernel before 5.4.16, a race condition in tty->disc_data handling in the slip and slcan line discipline could lead to a use-after-free, aka CID-0ace17d56824. This affects drivers/net/slip/slip.c and drivers/net/can/slcan.c.",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,Lack of proper synchronization allowed UAF
CVE-2020-13974,https://www.cve.org/CVERecord?id=CVE-2020-13974,Linux,"An issue was discovered in the Linux kernel 4.4 through 5.7.1. drivers/tty/vt/keyboard.c has an integer overflow if k_ascii is called several times in a row, aka CID-b86dab054059. NOTE: Members in the community argue that the integer overflow does not lead to a security issue in this case.",Language - Integer overflow,High level spec violation,FALSE,TRUE,"*Int overflow leads to undefined behavior in k_ascii, but doesn't seem to cause any immediate symptoms. Red hat classified this as possible DOS."
CVE-2020-13143,https://www.cve.org/CVERecord?id=CVE-2020-13143,Linux,"gadget_dev_desc_UDC_store in drivers/usb/gadget/configfs.c in the Linux kernel 3.16 through 5.6.13 relies on kstrdup without considering the possibility of an internal '\0' value, which allows attackers to trigger an out-of-bounds read, aka CID-15753588bcd4.",Semantic - Improper input validation,OOB access,TRUE,TRUE,Malformed input could trigger buffer overflow due to the copy of a buffer being smaller than original.
CVE-2020-12771,https://www.cve.org/CVERecord?id=CVE-2020-12771,Linux,An issue was discovered in the Linux kernel through 5.6.11. btree_gc_coalesce in drivers/md/bcache/btree.c has a deadlock if a coalescing operation fails.,Race condition - Improper usage of synchronization primitives,Failure to release CPU,FALSE,TRUE,*Possible deadlock due to missing unlock on failure path.
CVE-2020-12769,https://www.cve.org/CVERecord?id=CVE-2020-12769,Linux,"An issue was discovered in the Linux kernel before 5.4.17. drivers/spi/spi-dw.c allows attackers to cause a panic via concurrent calls to dw_spi_irq and dw_spi_transfer_one, aka CID-19b61392c5a8.",Race condition - Improper usage of synchronization primitives,Invalid pointer dereference,TRUE,TRUE,"Race condition allowed for panic due to null ptr deref, ie race between data not being initialized, fix is to add lock."
CVE-2020-12654,https://www.cve.org/CVERecord?id=CVE-2020-12654,Linux,"An issue was found in Linux kernel before 5.5.4. mwifiex_ret_wmm_get_status() in drivers/net/wireless/marvell/mwifiex/wmm.c allows a remote AP to trigger a heap-based buffer overflow because of an incorrect memcpy, aka CID-3a9b153c5591.",Semantic - Improper input validation,OOB access,TRUE,TRUE,Didn't verify size before memcpy
CVE-2020-12653,https://www.cve.org/CVERecord?id=CVE-2020-12653,Linux,"An issue was found in Linux kernel before 5.5.4. The mwifiex_cmd_append_vsie_tlv() function in drivers/net/wireless/marvell/mwifiex/scan.c allows local users to gain privileges or cause a denial of service because of an incorrect memcpy and buffer overflow, aka CID-b70261a288ea.",Semantic - Improper input validation,OOB access,TRUE,TRUE,Didn't verify size before memcpy
CVE-2020-12465,https://www.cve.org/CVERecord?id=CVE-2020-12465,Linux,"An array overflow was discovered in mt76_add_fragment in drivers/net/wireless/mediatek/mt76/dma.c in the Linux kernel before 5.5.10, aka CID-b102f0c522cf. An oversized packet with too many rx fragments can corrupt memory of adjacent pages.",Semantic - Improper input validation,OOB access,TRUE,TRUE,Missing check allowed writing more data than the buffer could hold.
CVE-2020-12464,https://www.cve.org/CVERecord?id=CVE-2020-12464,Linux,"usb_sg_cancel in drivers/usb/core/message.c in the Linux kernel before 5.6.8 has a use-after-free because a transfer occurs without a reference, aka CID-056ad39ee925.",Language - Lifetime violation,Use after free,TRUE,TRUE,Didn't update refrence count in cancelling operations. Cornucopia could mitigate UAF.
CVE-2020-11668,https://www.cve.org/CVERecord?id=CVE-2020-11668,Linux,"In the Linux kernel before 5.6.1, drivers/media/usb/gspca/xirlink_cit.c (aka the Xirlink camera USB driver) mishandles invalid descriptors, aka CID-a246b4d54770.",Semantic - Improper input validation,Invalid pointer dereference,TRUE,TRUE,Null pointer dereference due to not checking for corner case which introduces null values.
CVE-2020-11609,https://www.cve.org/CVERecord?id=CVE-2020-11609,Linux,"An issue was discovered in the stv06xx subsystem in the Linux kernel before 5.6.1. drivers/media/usb/gspca/stv06xx/stv06xx.c and drivers/media/usb/gspca/stv06xx/stv06xx_pb0100.c mishandle invalid descriptors, as demonstrated by a NULL pointer dereference, aka CID-485b06aadb93.",Semantic - Improper input validation,Invalid pointer dereference,TRUE,TRUE,Null pointer derefrence due to not checking for corner case which introduces null values.
CVE-2020-11608,https://www.cve.org/CVERecord?id=CVE-2020-11608,Linux,"An issue was discovered in the Linux kernel before 5.6.1. drivers/media/usb/gspca/ov519.c allows NULL pointer dereferences in ov511_mode_init_regs and ov518_mode_init_regs when there are zero endpoints, aka CID-998912346c0d.",Semantic - Improper input validation,Invalid pointer dereference,TRUE,TRUE,Null pointer dereference due to not checking for corner case which introduces null values.
CVE-2020-11494,https://www.cve.org/CVERecord?id=CVE-2020-11494,Linux,"An issue was discovered in slc_bump in drivers/net/can/slcan.c in the Linux kernel 3.16 through 5.6.2. It allows attackers to read uninitialized can_frame data, potentially containing sensitive information from kernel stack memory, if the configuration lacks CONFIG_INIT_STACK_ALL, aka CID-b9258a2cece4.",Language - Improper memory initialization,Uninitialized memory access,FALSE,TRUE,"Memory isn't zeroed, leading to pontential memory disclosure."
CVE-2020-10942,https://www.cve.org/CVERecord?id=CVE-2020-10942,Linux,"In the Linux kernel before 5.5.8, get_raw_socket in drivers/vhost/net.c lacks validation of an sk_family field, which might allow attackers to trigger kernel stack corruption via crafted system calls.",Semantic - Spec error,OOB access,TRUE,FALSE,"Incorrect use of getname(), which may write beyond the bounds of the allocated buffer."
CVE-2020-9383,https://www.cve.org/CVERecord?id=CVE-2020-9383,Linux,"An issue was discovered in the Linux kernel 3.16 through 5.5.6. set_fdc in drivers/block/floppy.c leads to a wait_til_ready out-of-bounds read because the FDC index is not checked for errors before assigning it, aka CID-2e90ca68b0d2.",Semantic - Improper input validation,OOB access,TRUE,TRUE,Insufficient validation of input leads to OOB issues. 
CVE-2020-8647,https://www.cve.org/CVERecord?id=CVE-2020-8647,Linux,There is a use-after-free vulnerability in the Linux kernel through 5.5.2 in the vc_do_resize function in drivers/tty/vt/vt.c.,Semantic - Logic error,Use after free,TRUE,TRUE,"Logic error during cleanup, dependent data structure free'd first. Meaning it could possibly be accessed during rest of clean up. The patch reordered the free to occur last. Cornucopia could help stop UAF."
CVE-2020-7053,https://www.cve.org/CVERecord?id=CVE-2020-7053,Linux,"In the Linux kernel 4.14 longterm through 4.14.165 and 4.19 longterm through 4.19.96 (and 5.x before 5.2), there is a use-after-free (write) in the i915_ppgtt_close function in drivers/gpu/drm/i915/i915_gem_gtt.c, aka CID-7dc40713618c. This is related to i915_gem_context_destroy_ioctl in drivers/gpu/drm/i915/i915_gem_context.c.",Race condition - Improper usage of synchronization primitives,Use after free,TRUE,TRUE,Improper locking leads to UAF
,,,,,,,,
,,,,,,,,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,
,,,,,,FALSE,FALSE,